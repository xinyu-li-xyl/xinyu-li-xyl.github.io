<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang学习笔记（一）——那些“奇怪”的规定和特性</title>
    <url>/2019/12/08/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%82%A3%E4%BA%9B%E2%80%9C%E5%A5%87%E6%80%AA%E2%80%9D%E7%9A%84%E8%A7%84%E5%AE%9A%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/103444529">https://blog.csdn.net/yushuaigee/article/details/103444529</a></p>
</blockquote>
<p>这几天看了一下Go语言的基础知识，还没有在项目中使用，所以还没体会到它的性能优势。而在学习基础用法部分时我最大的感受就是它的一些特性和规定很“奇怪”。以前听说Go语言声明变量时，类型关键字在变量名称后面就感觉怪怪的，没想到还有许多这样奇怪的地方（主要是和C、Python相比），在这里将这几周的学习内容和感受记录一下以备查阅。</p>
<h3 id="1-去掉循环冗余括号"><a href="#1-去掉循环冗余括号" class="headerlink" title="1. 去掉循环冗余括号"></a>1. 去掉循环冗余括号</h3><p>C语言的数值循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;<span class="number">10</span>;a++)&#123;</span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的数值循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>;a&lt;<span class="number">10</span>;a++&#123;</span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个括号确实没什么实际作用，但是Go语言中的循环的风格和C语言太像，没有那两个括号感觉怪怪的。 </p>
<h3 id="2-去掉表达式冗余括号"><a href="#2-去掉表达式冗余括号" class="headerlink" title="2. 去掉表达式冗余括号"></a>2. 去掉表达式冗余括号</h3><p>C语言的判断语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)&#123;</span><br><span class="line">    <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的判断语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式&#123;</span><br><span class="line">    <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个括号确实也没什么实际作用，Python中也是这样写的，但是Python中又没有后面这个大括号。初学Go语言，写这行代码时有一点不适应。</p>
<h3 id="3-强制的代码风格"><a href="#3-强制的代码风格" class="headerlink" title="3.强制的代码风格"></a>3.强制的代码风格</h3><p>Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。<br>也就是说代码中，用到大括号的地方，必须写成这样： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//代码片段</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    <span class="comment">//循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能写成这样：（不然连编译都通不过）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码片段</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规定让许多人觉得蛋疼，毕竟程序员大多都有强迫症，我就在网上看到一篇diss Go语言的博文，里面狠狠得吐槽了这一点。不过对于我来说还好，像我这种选择困难症和强迫症并存的人，这个规定可以让我不再纠结到底用哪种格式，大大节省了自己做思想斗争的时间。从而有更多的时间，来纠结这篇博客每一行的排版方式。||—__—</p>
<h3 id="4-不再纠结于-i-和-i"><a href="#4-不再纠结于-i-和-i" class="headerlink" title="4. 不再纠结于 i++ 和 ++i"></a>4. 不再纠结于 i++ 和 ++i</h3><p>C语言非常经典的考试题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = i++;</span><br><span class="line">b = ++i;</span><br></pre></td></tr></table></figure>
<p>在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure>
<h3 id="5-Go语言变量的声明——标准格式"><a href="#5-Go语言变量的声明——标准格式" class="headerlink" title="5. Go语言变量的声明——标准格式"></a>5. Go语言变量的声明——标准格式</h3><p>Go原因是静态类型语言，因此变量是有明确类型的，编译器也会检查变量类型的正确性。Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。</p>
<p>声明变量的一般形式是使用 var 关键字： <code>var name type</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>var关键字没什么奇怪的，C#、js里也有，但是其他大部分语言声明变量时，类型都在变量名之前，以至于我们都认为这是理所当然的，而Go语言偏偏反了过来。教程上说，这样做的好处是：</p>
<blockquote>
<p>可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b;</code> 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：<code>var a, b *int</code></p>
</blockquote>
<p>额(⊙o⊙)，感觉这种声明方式带给我的奇怪感受，远大于将这行代码写成两行带来的“不便”。</p>
<h3 id="6-Go语言变量的声明——批量格式"><a href="#6-Go语言变量的声明——批量格式" class="headerlink" title="6. Go语言变量的声明——批量格式"></a>6. Go语言变量的声明——批量格式</h3><p>Go语言中的多个变量可以一起声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然感觉不是那么的好看，不过也算是很有自己的风格吧。就像引入多个包的时候，Go语言是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;image&quot;</span></span><br><span class="line">    <span class="string">&quot;image/color&quot;</span></span><br><span class="line">    <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 相比于C语言中的一行一个<code>include</code>”Python一行一个<code>import</code>，这样确实少写了很多个单词，但是总是觉得不太习惯。</p>
<h3 id="7-Go语言变量的声明——简短格式"><a href="#7-Go语言变量的声明——简短格式" class="headerlink" title="7. Go语言变量的声明——简短格式"></a>7. Go语言变量的声明——简短格式</h3><p>Go语言中还可以使用海象操作符<code>:=</code>，这样声明变量：<code>名字 := 表达式 </code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">i, j := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">str := <span class="string">&quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>
<p>乍一看，好像和Python中的等号效果一样，但是这个<code>:=</code>在循环的时候使用是真的香，主要是可以省掉前面声明的那一句。现在新发布的Python3.8版本也加入了海象操作符。</p>
<h3 id="8-Go语言匿名变量"><a href="#8-Go语言匿名变量" class="headerlink" title="8. Go语言匿名变量"></a>8. Go语言匿名变量</h3><p>编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），<strong>但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算</strong>。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。</p>
<p><strong>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用</strong>。在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p> 100 200 </p>
</blockquote>
<p>这个特性给我的直观感受比较有用。</p>
<h3 id="9-Go语言bool类型"><a href="#9-Go语言bool类型" class="headerlink" title="9. Go语言bool类型"></a>9. Go语言bool类型</h3><p>这里需要注意的地方就是，Go语言中的布尔值并不会隐式转换为数字值 0 或 1，反之亦然。</p>
<p>也就是说有些语言默认 <code>true==1</code>，<code>false==0</code>，这在Go语言中是不成立的，如果必须要这么用，需要手动转化一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b为bool型变量</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://c.biancheng.net/golang/">Go语言入门教程——C语言中文网</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go语言特点</tag>
        <tag>go</tag>
        <tag>go语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（三）——数据类型转换</title>
    <url>/2020/05/24/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106305233">https://blog.csdn.net/yushuaigee/article/details/106305233</a></p>
</blockquote>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>类似于其他语言，Go语言也支持强制类型转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200523205009481.png" alt="20200523205009481.png"></p>
<p>但是只有相同底层类型的变量之间可以进行相互转换（如将 int16 和 int32 相互转换，float 类型和 int 类型相互转换），不同底层类型的变量相互转换时会引发编译错误（如 bool 类型和 int 类型，string 与 int 类型之间的转换）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200523200617332.png" alt="20200523200617332.png"></p>
<h2 id="字符串和数值类型的相互转换-strconv"><a href="#字符串和数值类型的相互转换-strconv" class="headerlink" title="字符串和数值类型的相互转换 (strconv)"></a>字符串和数值类型的相互转换 (strconv)</h2><p>如果需要string、int、int64、float 等数据类型之间的转换功能，可以使用标准包中的 strconv 包。</p>
<p>strconv 包中常用的函数包括 <strong>Atoi()**、</strong>Itia()<strong>、</strong>parse** 系列函数、<strong>format **系列函数、</strong>append **系列函数等。</p>
<h3 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h3><p>integer to alphanumeric</p>
<p>函数原型：</p>
<p><code>func Itoa(i int) string    </code></p>
<p>输入 int，输出 string</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">100</span></span><br><span class="line">	str := strconv.Itoa(num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//type:string value:&quot;100&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h3><p>alphanumeric to integer</p>
<p>函数原型：</p>
<p><code>func Atoi(s string) (i int, err error)</code></p>
<p> 输入 string，输出 int 和 错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;110&quot;</span></span><br><span class="line">	str2 := <span class="string">&quot;s100&quot;</span></span><br><span class="line">	num1, err := strconv.Atoi(str1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v 转换失败！&quot;</span>, str1)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, num1, num1)</span><br><span class="line">	&#125;</span><br><span class="line">	num2, err := strconv.Atoi(str2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v 转换失败！&quot;</span>, str2)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, num2, num2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:int value:110</span></span><br><span class="line"><span class="comment">//s100 转换失败！</span></span><br></pre></td></tr></table></figure>
<h3 id="Parse-系列：str-转其他"><a href="#Parse-系列：str-转其他" class="headerlink" title="Parse 系列：str 转其他"></a>Parse 系列：str 转其他</h3><h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p>函数原型：</p>
<p><code>func ParseBool(str string) (value bool, err error)</code></p>
<p>它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;110&quot;</span></span><br><span class="line">	boo1, err := strconv.ParseBool(str1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;str1: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(boo1)</span><br><span class="line">	&#125;</span><br><span class="line">	str2 := <span class="string">&quot;t&quot;</span></span><br><span class="line">	boo2, err := strconv.ParseBool(str2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;str2: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(boo2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//str1: strconv.ParseBool: parsing &quot;110&quot;: invalid syntax</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h4><p>函数原型：</p>
<p><code>func ParseInt(s string, base int, bitSize int) (i int64, err error)</code></p>
<p>函数用于返回字符串表示的整数值，<strong>可以包含正负号</strong>。</p>
<p>参数说明：</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x” 是 16 进制，“0” 是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;-11&quot;</span></span><br><span class="line">	num, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//-11</span></span><br></pre></td></tr></table></figure>
<h4 id="ParseUint"><a href="#ParseUint" class="headerlink" title="ParseUint()"></a>ParseUint()</h4></li>
</ul>
<p>函数原型：</p>
<p><code>func ParseUint(s string, base int, bitSize int) (n uint64, err error)</code></p>
<p>函数用于返回字符串表示的整数值，但 ParseUint() 函数<strong>不接受正负号，用于无符号整型。</strong></p>
<p>参数说明：(同ParseInt())</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;11&quot;</span></span><br><span class="line">	num, err := strconv.ParseUint(str, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//11</span></span><br></pre></td></tr></table></figure>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4></li>
</ul>
<p>函数原型：</p>
<p><code>func ParseFloat(s string, bitSize int) (f float64, err error)</code></p>
<p>函数用于将一个表示浮点数的字符串转换为 float 类型。</p>
<p>参数说明：</p>
<ul>
<li>如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。</li>
<li>bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；</li>
<li>返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;3.1415926&quot;</span></span><br><span class="line">	num, err := strconv.ParseFloat(str, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//3.1415926</span></span><br></pre></td></tr></table></figure>
<h3 id="Format-系列：其他转-str"><a href="#Format-系列：其他转-str" class="headerlink" title="Format 系列：其他转 str"></a>Format 系列：其他转 str</h3></li>
</ul>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p>函数原型：</p>
<p><code>func FormatBool(b bool) string</code></p>
<p>函数可以将一个 bool 类型的值转换为对应的字符串类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="literal">true</span></span><br><span class="line">	str := strconv.FormatBool(num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:true</span></span><br></pre></td></tr></table></figure>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>函数原型：</p>
<p><code>func FormatInt(i int64, base int) string</code></p>
<p>函数用于将整型数据转换成指定进制并以字符串的形式返回。</p>
<p>参数说明：</p>
<ul>
<li>参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">	str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:64</span></span><br></pre></td></tr></table></figure>
<h4 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h4></li>
</ul>
<p>函数原型：</p>
<p><code>func FormatUint(i uint64, base int) string</code></p>
<p>函数用于将无符号的整型数据转换成指定进制并以字符串的形式返回。</p>
<p>参数说明：</p>
<ul>
<li>参数 i 必须是无符号的 uint64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">uint64</span> = <span class="number">110</span></span><br><span class="line">	str := strconv.FormatUint(num, <span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:6e</span></span><br></pre></td></tr></table></figure>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4></li>
</ul>
<p>函数原型：</p>
<p><code>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</code></p>
<p>函数用于将浮点数转换为字符串类型并以字符串的形式返回。</p>
<p>参数说明：</p>
<ul>
<li>bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。</li>
<li>fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li>prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">3.1415926</span></span><br><span class="line">	str := strconv.FormatFloat(num, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:3.1415926E+00</span></span><br></pre></td></tr></table></figure>
<h3 id="Append-系列：其他转-str-后加到切片中"><a href="#Append-系列：其他转-str-后加到切片中" class="headerlink" title="Append 系列：其他转 str 后加到切片中"></a>Append 系列：其他转 str 后加到切片中</h3></li>
</ul>
<p><code>Append</code> 系列函数和 <code>Format</code> 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。</p>
<p>相比之下，入参多了一个 <code>[]string</code> 类型的数组，返回值是加完元素的数组。</p>
<p>函数原型：</p>
<p><code>func FormatBool(slice []string, b bool) []string</code></p>
<p><code>func FormatInt(slice []string, i int64, base int) []sting</code></p>
<p><code>func FormatUint(slice []string, i uint64, base int)  []string</code></p>
<p><code>func FormatFloat(slice []string, f float64, fmt byte, prec, bitSize int) []string</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明一个slice</span></span><br><span class="line">	b10 := []<span class="keyword">byte</span>(<span class="string">&quot;int (base 10):&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将转换为10进制的string，追加到slice中</span></span><br><span class="line">	b10 = strconv.AppendInt(b10, <span class="number">-42</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(b10))</span><br><span class="line">	b16 := []<span class="keyword">byte</span>(<span class="string">&quot;int (base 16):&quot;</span>)</span><br><span class="line">	b16 = strconv.AppendInt(b16, <span class="number">-42</span>, <span class="number">16</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(b16))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//int (base 10):-42</span></span><br><span class="line"><span class="comment">//int (base 16):-2a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><strong><a href="http://c.biancheng.net/view/5112.html"> Go语言strconv包：字符串和数值类型的相互转换</a></strong></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（二）——计算字符串长度 len()和RuneCountInString()</title>
    <url>/2020/01/17/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%20len()%E5%92%8CRuneCountInString()/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/103446306">https://blog.csdn.net/yushuaigee/article/details/103446306</a></p>
</blockquote>
<h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>该函数是内建函数，用来获取字符串的 ASCII 字符个数或字节长度。</p>
<p>由于 Go 语言的字符串都以 UTF-8 格式保存，每个中文占用 3 个字节，因此使用 len() 获得两个中文文字对应的 6 个字节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(str1)) <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">	str2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(str2)) <span class="comment">//6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="utf8-RuneCountInString"><a href="#utf8-RuneCountInString" class="headerlink" title="utf8.RuneCountInString()"></a>utf8.RuneCountInString()</h3><p>该函数由 UTF-8 包提供，用来统计 Uncode 字符数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str1)) <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">	str2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str2)) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ASCII-和-Unicode-的区别"><a href="#ASCII-和-Unicode-的区别" class="headerlink" title="ASCII 和 Unicode 的区别"></a>ASCII 和 Unicode 的区别</h3><p>在遍历一个字符串时，要注意 ascii 和 Unicode 的区别。</p>
<h4 id="用普通的-for-循环遍历时，取到的是对应的ascii码"><a href="#用普通的-for-循环遍历时，取到的是对应的ascii码" class="headerlink" title="用普通的 for 循环遍历时，取到的是对应的ascii码"></a>用普通的 for 循环遍历时，取到的是对应的ascii码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &amp;lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ascii: %c\n&quot;</span>, str[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 输出：</p>
<blockquote>
<p> 12<br> ascii: h<br> ascii: e<br> ascii: l<br> ascii: l<br> ascii: o<br> ascii:<br> ascii: ä<br> ascii: ¸<br> ascii:<br> ascii: ç<br> ascii:<br> ascii: </p>
</blockquote>
<h4 id="用-for-…-range-循环遍历时，取到的是对应的Unicode码"><a href="#用-for-…-range-循环遍历时，取到的是对应的Unicode码" class="headerlink" title="用 for … range 循环遍历时，取到的是对应的Unicode码"></a>用 for … range 循环遍历时，取到的是对应的Unicode码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str))</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">	    fmt.Printf(<span class="string">&quot;Unicode: %c\n&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>  8<br> Unicode: h<br> Unicode: e<br> Unicode: l<br> Unicode: l<br> Unicode: o<br> Unicode:<br> Unicode: 世<br> Unicode: 界</p>
</blockquote>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go字符串长度</tag>
        <tag>RuneCountInString</tag>
        <tag>len</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（四）——Go语言的指针</title>
    <url>/2020/05/24/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106309176">https://blog.csdn.net/yushuaigee/article/details/106309176</a></p>
</blockquote>
<p><strong>Go语言中的指针和C/C++ 中的指针用法基本相似。</strong></p>
<p>指针（pointer）在Go语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。<br>受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</li>
</ul>
<h2 id="认识指针地址和指针类型"><a href="#认识指针地址和指针类型" class="headerlink" title="认识指针地址和指针类型"></a>认识指针地址和指针类型</h2><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加<code>&amp;amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p>
<blockquote>
<p>ptr := &amp;v   // 其中 v 的类型为 T</p>
</blockquote>
<p> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">	t := *a</span><br><span class="line">	<span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">	*a = *b</span><br><span class="line">	<span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">	*b = t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	<span class="comment">// 交换变量值</span></span><br><span class="line">	swap(&amp;amp;x, &amp;amp;y)</span><br><span class="line">	<span class="comment">// 输出变量值</span></span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//2 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建指针的另一种方法：new"><a href="#创建指针的另一种方法：new" class="headerlink" title="创建指针的另一种方法：new()"></a>创建指针的另一种方法：new()</h2><p>Go语言还提供了另外一种方法来创建指针变量，格式如下：</p>
<blockquote>
<p> new(类型) </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">*str = <span class="string">&quot;Go语言教程&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></table></figure>
<p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>python3 线程池实现批量ping某一网段，获得可用ip列表——futures模块</title>
    <url>/2018/12/25/python3%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8Fping%E6%9F%90%E4%B8%80%E7%BD%91%E6%AE%B5%EF%BC%8C%E8%8E%B7%E5%BE%97%E5%8F%AF%E7%94%A8ip%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94futures%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/85244394">https://blog.csdn.net/yushuaigee/article/details/85244394</a></p>
</blockquote>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><strong>工作中需要找出指定网段里，哪些ip是没被占用的，然后使用这些ip。</strong></p>
<p>实现方法很简单，就是依次ping一下，看看哪些是不通的，就代表没被占用。ping是很耗时间的，于是想到多线程，考虑到线程数量多且每个线程的任务很简单，所以使用线程池。参考了网上博主的代码，原文链接：《<a href="http://blog.51cto.com/maoxian/2119898">Python多线程批量Ping主机IP的脚本</a>》，主要学到了Python队列queue的概念和后台调用cmd控制台的方法。</p>
<p>我的代码如下：</p>
<p>第一个参数<code>net_segment</code>代表要查找的网段，</p>
<p>第二个参数<code>ip_num</code>代表所需 ip 的数量。</p>
<p>通过修改<code>max_workers=100</code> 的值可以调整程序运行的速度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_list</span>(<span class="params">net_segment, ip_num</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    IP_QUEUE = Queue()</span><br><span class="line">    ip_list = []</span><br><span class="line">    list_segment = net_segment.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ip_index = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将需要 ping 的 ip 加入队列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">254</span>):</span><br><span class="line">        list_segment[-<span class="number">1</span>] = <span class="built_in">str</span>(ip_index + i)</span><br><span class="line">        addr = (<span class="string">&#x27;.&#x27;</span>).join(list_segment)</span><br><span class="line">        IP_QUEUE.put(addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个执行 ping 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping_ip</span>(<span class="params">ip</span>):</span></span><br><span class="line">        res = subprocess.call(<span class="string">&#x27;ping -n 2 -w 5 %s&#x27;</span> % ip, stdout=subprocess.PIPE)  <span class="comment"># linux 系统将 &#x27;-n&#x27; 替换成 &#x27;-c&#x27;</span></span><br><span class="line">        <span class="comment"># 打印运行结果</span></span><br><span class="line">        print(ip, <span class="literal">True</span> <span class="keyword">if</span> res == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> res != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> lock.acquire():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(ip_list) &amp;lt; ip_num:</span><br><span class="line">                    ip_list.append(ip)</span><br><span class="line">                lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个最大任务为100的线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">100</span>)</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> IP_QUEUE.empty():</span><br><span class="line">        all_task.append(pool.submit(ping_ip, IP_QUEUE.get()))</span><br><span class="line">    <span class="comment"># 等待所有任务结束</span></span><br><span class="line">    wait(all_task, return_when=ALL_COMPLETED)</span><br><span class="line">    print(<span class="string">&#x27;ping耗时：%s&#x27;</span> % (time.time() - start_time))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ip_list) &amp;lt; ip_num:</span><br><span class="line">        print(<span class="string">&quot;Warning：当前网段可用ip不够，需要数量：%s，可用数量：%s&quot;</span> % (<span class="built_in">str</span>(ip_num), <span class="built_in">str</span>(<span class="built_in">len</span>(ip_list))))</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_list = get_ip_list(<span class="string">&quot;202.169.50.0&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    print(ip_list)</span><br><span class="line">    print(<span class="built_in">len</span>(ip_list))</span><br></pre></td></tr></table></figure>
<p>部分运行结果：</p>
<blockquote>
<p>202.169.50.238 False<br>202.169.50.253 False<br>202.169.50.239 False<br>202.169.50.230 False<br>ping耗时：6.348670959472656<br>Warning：当前网段可用ip不够，需要数量：200，可用数量：168<br>[‘202.169.50.3’, ‘202.169.50.20’, ‘202.169.50.19’, ‘202.169.50.78’,…………………………………………………………]<br>168 </p>
</blockquote>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>代码稍作修改，可以查看某两个ip之间哪些地址ping的通，哪些ping不通。</strong></p>
<p>这里用到处理ip地址的标准库 <code>ipaddress</code> 模块，来处理ip地址的计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> ip_address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_list</span>(<span class="params">ip_start, ip_end</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    IP_QUEUE = Queue()</span><br><span class="line">    ip_used = []</span><br><span class="line">    ip_not_used = []</span><br><span class="line">    ip_start = ip_address(ip_start)</span><br><span class="line">    ip_end = ip_address(ip_end)</span><br><span class="line">    <span class="keyword">while</span> ip_start &amp;lt;= ip_end:</span><br><span class="line">        IP_QUEUE.put(<span class="built_in">str</span>(ip_start))</span><br><span class="line">        ip_start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个执行 ping 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping_ip</span>(<span class="params">ip</span>):</span></span><br><span class="line">        res = subprocess.call(<span class="string">&#x27;ping -n 2 -w 5 %s&#x27;</span> % ip, stdout=subprocess.PIPE)  <span class="comment"># linux 系统将 &#x27;-n&#x27; 替换成 &#x27;-c&#x27;</span></span><br><span class="line">        <span class="comment"># 打印运行结果</span></span><br><span class="line">        print(ip, <span class="literal">True</span> <span class="keyword">if</span> res == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> lock.acquire():</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">                ip_used.append(ip)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ip_not_used.append(ip)</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个最大任务为100的线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">120</span>)</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> IP_QUEUE.empty():</span><br><span class="line">        all_task.append(pool.submit(ping_ip, IP_QUEUE.get()))</span><br><span class="line">    <span class="comment"># 等待所有任务结束</span></span><br><span class="line">    wait(all_task, return_when=ALL_COMPLETED)</span><br><span class="line">    print(<span class="string">&#x27;ping耗时：%s&#x27;</span> % (time.time() - start_time))</span><br><span class="line">    <span class="keyword">return</span> ip_used, ip_not_used</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_used, ip_not_used = get_ip_list(<span class="string">&quot;202.169.50.1&quot;</span>, <span class="string">&quot;202.169.51.255&quot;</span>)</span><br><span class="line">    print(<span class="built_in">str</span>(<span class="built_in">len</span>(ip_used))+<span class="string">&quot;已用&quot;</span>, <span class="string">&quot;\n&quot;</span>, ip_used)</span><br><span class="line">    print(<span class="built_in">str</span>(<span class="built_in">len</span>(ip_not_used))+<span class="string">&quot;未用&quot;</span>, <span class="string">&quot;\n&quot;</span>, ip_not_used)</span><br></pre></td></tr></table></figure>
<p>部分运行结果：</p>
<blockquote>
<p>202.169.51.222 False<br>202.169.51.249 False<br>202.169.51.200 False<br>202.169.51.208 False<br>ping耗时：10.248608827590942<br>86已用<br> [‘202.169.50.2’, ‘202.169.50.8’, ‘202.169.50.7’,…………………………………………]<br>425未用<br> [‘202.169.50.3’, ‘202.169.50.19’, ‘202.169.50.78’…………………………………………] </p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>批量ping</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Python获取多网卡的IP地址的几种方法(Linux系统)</title>
    <url>/2019/03/23/Python%E8%8E%B7%E5%8F%96%E5%A4%9A%E7%BD%91%E5%8D%A1%E7%9A%84IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95(Linux%E7%B3%BB%E7%BB%9F)/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86682583">https://blog.csdn.net/yushuaigee/article/details/86682583</a></p>
</blockquote>
<p>过年之前，有一个任务是将原来的windows工具客户端改写一个Linux版本，对于python来说，很好移植。不过其中有一个很关键的步骤是获取当前设备的ip地址，window版的函数不能直接拿来用了。</p>
<p>本来很简单的一件事，由于公司许多机器的Linux版本不同，机器的网卡数量也不一样，本来在自己的机器测试完没问题，拿给别人一用就出现各种问题，适配完，换了机器又出现新的问题，导致前前后后竟然改了四种方法。</p>
<p>思路无非就是通过获取linux命令的输出结果来解析出每个ip，试过很多命令加正则表达式的组合，实现是肯定可以实现，但是越弄越复杂，感觉不够优雅，而且不能保证适配所有版本的系统，最后竟然在一篇博客发现了一个命令只需要一行代码，当时的心情真的是哭笑不得。这里记录一下，以备不时之需。</p>
<p>命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrs</span>(<span class="params">self</span>):</span></span><br><span class="line">    p = Popen(<span class="string">&quot;hostname -I&quot;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">    data = p.stdout.read() <span class="comment"># 获取命令输出内容</span></span><br><span class="line">    data = <span class="built_in">str</span>(data,encoding = <span class="string">&#x27;UTF-8&#x27;</span>) <span class="comment"># 将输出内容编码成字符串</span></span><br><span class="line">    ip_list = data.split(<span class="string">&#x27; &#x27;</span>) <span class="comment"># 用空格分隔输出内容得到包含所有IP的列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">in</span> ip_list: <span class="comment"># 发现有的系统版本输出结果最后会带一个换行符</span></span><br><span class="line">        ip_list.remove(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    print(ip_list)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p> [202.196.1.0, 202.196.1.1] </p>
</blockquote>
<p>之前用的方法（Linux）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV2</span>(<span class="params">self</span>):</span></span><br><span class="line">    p = Popen(<span class="string">&quot;ifconfig | grep &#x27;inet &#x27; | grep -v &#x27;127.0.0.1&#x27; | awk &#x27;&#123;print $2&#125;&#x27;&quot;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">    data = p.stdout.read()</span><br><span class="line">    data = <span class="built_in">str</span>(data,encoding = <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    ip_list = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    ip_list.remove(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    ip_list2 = []</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> ip:</span><br><span class="line">            ip_list2.append(ip.split(<span class="string">&quot;:&quot;</span>)[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip_list2.append(ip)</span><br><span class="line">    print(ip_list2)</span><br><span class="line">    <span class="keyword">return</span> ip_list2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV3</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">import</span> psutil</span><br><span class="line">    netcard_info = []</span><br><span class="line">    info = psutil.net_if_addrs()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> v:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> item[<span class="number">1</span>] == <span class="string">&#x27;127.0.0.1&#x27;</span>:</span><br><span class="line">                <span class="comment"># netcard_info.append((k, item[1]))</span></span><br><span class="line">                netcard_info.append( item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> netcard_info</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV4</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">import</span> fcntl</span><br><span class="line">    <span class="keyword">import</span> struct</span><br><span class="line">    ifname = <span class="string">b&#x27;enp0s31f6&#x27;</span> <span class="comment"># 网卡名字</span></span><br><span class="line">    ip_list = []</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    ip = socket.inet_ntoa(fcntl.ioctl(s.fileno(),<span class="number">0x8915</span>,struct.pack(<span class="string">b&#x27;256s&#x27;</span>, ifname[:<span class="number">15</span>]))[<span class="number">20</span>:<span class="number">24</span>])</span><br><span class="line">    ip_list.append(ip)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>
<p>之前用的方法（Windows）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;获取pc的IPv4地址&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrs</span>(<span class="params">self</span>):</span></span><br><span class="line">    ip_list = socket.gethostbyname_ex(socket.gethostname())</span><br><span class="line">    <span class="keyword">for</span> ips <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(ips) == <span class="built_in">list</span> <span class="keyword">and</span> <span class="built_in">len</span>(ips) != <span class="number">0</span>:</span><br><span class="line">            IPlist = ips</span><br><span class="line">    <span class="keyword">return</span> IPlist</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV2</span>(<span class="params">self</span>):</span></span><br><span class="line">     p = Popen(<span class="string">&#x27;ipconfig|findstr IPv4&#x27;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">     data = p.stdout.read().decode(encoding=<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line">     IPlist = []</span><br><span class="line">     splitlist = re.split(<span class="string">&#x27;[\r:]&#x27;</span>, data)</span><br><span class="line">     <span class="keyword">for</span> eachpart <span class="keyword">in</span> splitlist:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> eachpart <span class="keyword">and</span> <span class="string">&#x27;IP&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> eachpart:</span><br><span class="line">             IPlist.append(eachpart.strip())</span><br><span class="line">     <span class="keyword">return</span> IPlist</span><br></pre></td></tr></table></figure>
<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>获取网卡ip</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</title>
    <url>/2021/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%81%E7%A7%BB%20CSDN%20%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第六篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——<a href="https://yushuaigee.gitee.io/2021/01/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">三个站点一键发布博客</a></li>
<li><strong>从零开始免费搭建自己的博客(七)——<a href="https://yushuaigee.gitee.io/2021/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%81%E7%A7%BB%20CSDN%20%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/">迁移 CSDN 博客到个人博客站点</a></strong></li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSDN 没有提供文章导出功能，只有导入功能，我们想把自己以前写的文章迁移到其他平台或者自己的博客网站，还得自己想办法爬取下来。可是那是我写的文章啊，竟然不能想拿就拿回来。。。</p>
<p>我看到需多人的实现思路，是使用文章界面点击编辑按钮的接口，获取自己之前的文章 Markdown 源码。这样还得先登录自己的账号，而且前提是之前文章是用 Markdown 编辑器写的。其实不管是富文本编辑器还是 Markdown 编辑器写的，最终呈现的都是一个 html 网页，不需要登录就可以看到。之前介绍 Typora 时说过， Markdown 语法和 html 语法本来就类似，所以本文思路是直接下载 html 然后转化为 Markdown 格式。</p>
<p>在 CSDN 页面结构不发生改变的情况下，我们可以用这种方法下载 CSDN 上任意文章并保存成 Markdown 格式。只有写过博客的人才知道原创一篇文章要花费多少精力，所以希望大家如果下载别人的文章一定要标明原地址，这是基本节操。</p>
<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>语言：<code>Python3</code>。</p>
<p>第三方库：<code>requests</code>、<code>parsel </code>、<code>tomd</code>。</p>
<p>当然可以使用上一篇用到的 <a href="https://github.com/miyakogi/pyppeteer">pyppeteer</a>，不多对于这个需求来说速度太慢。CSDN 目前没有设置很多反爬虫机制，所以用轻量的 <a href="https://github.com/psf/requests">requests</a> 就够了。</p>
<p><code>parsel </code>是 <a href="https://github.com/scrapy">Scrapy</a> 框架内置的 html 解析库，后来独立出来。选择 <a href="https://github.com/scrapy/parsel">parsel </a>也是因为够用，且比 <a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a> 更轻。</p>
<p>html 转 Markdown 的库找到两个：<a href="https://github.com/gaojiuli/tomd">tomd</a> 和 <a href="https://github.com/aaronsw/html2text">html2text</a> ，试了一下都挺好用的，美中不足的是两个库转换完的代码块都没有标识语言类别，导致代码无法高亮。我看了 html 源码是有是语言类别信息的，所以需要对库稍作改动才能达到完美的效果。<code>tomd</code> 的原理比较简单粗暴，直接是正则表达式查找替换，源码就一个文件，比较好改，改动点和源码在下面。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li>获取自己主页文章列表，包括标题和文章地址。</li>
<li>根据上一步获取的文章地址，获取文章的标题、正文、标签、分类、发布时间。</li>
<li>根据上一步获取的文章正文，将 html 格式文本转为 md 格式。</li>
<li>新建<code>.md</code>文件，先添加标题、标签、分类、发布时间，再写入 md 正文。</li>
<li>使用上一篇文章中实现的一键发布脚本将本地保存的博客发布到自己的博客。</li>
</ol>
<h2 id="tomd修改"><a href="#tomd修改" class="headerlink" title="tomd修改"></a>tomd修改</h2><p>在使用<code>tomd</code>的过程中遇到两个问题，好在源码只有一个文件，原理也很简单，稍微看一下代码逻辑就可以解决。</p>
<ol>
<li><p>无序列表转化后没有换行，导致无序列表只有一行。需要修改<code>tomd.py</code>文件第<code>103</code>行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126224109198.png" alt="image-20210126224109198"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> self.tag == <span class="string">&#x27;ul&#x27;</span> <span class="keyword">and</span> tag == <span class="string">&#x27;li&#x27;</span>:</span><br><span class="line">    self.content = re.sub(pattern, <span class="string">&#x27;\n- \g&lt;1&gt;&#x27;</span>, self.content)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126224458389.png" alt="image-20210126224458389"></p>
</li>
<li><p>代码块没有标识语言类别，无法代码高亮。需要修改<code>tomd.py</code>文件第<code>19</code>行和第<code>50</code>行。各加三行，根据实际用到的语言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230335050.png" alt="image-20210126230335050"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230422905.png" alt="image-20210126230422905"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#x27;block_code&#x27;: (&#x27;\n```\n&#x27;, &#x27;\n```\n&#x27;),</span></span><br><span class="line"><span class="string">&#x27;block_code_go&#x27;</span>: (<span class="string">&#x27;\n```go\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),</span><br><span class="line"><span class="string">&#x27;block_code_py&#x27;</span>: (<span class="string">&#x27;\n```python\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),</span><br><span class="line"><span class="string">&#x27;block_code_java&#x27;</span>: (<span class="string">&#x27;\n```java\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),   </span><br><span class="line"><span class="string">&#x27;block_code_cpp&#x27;</span>: (<span class="string">&#x27;\n```c\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>), </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># &#x27;block_code&#x27;: &#x27;&lt;pre.*?&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;,</span></span><br><span class="line">   <span class="string">&#x27;block_code_go&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?Go.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;block_code_py&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?python.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;block_code_java&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?java.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;block_code_cpp&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?cpp.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230230535.png" alt="image-20210126230230535"></p>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csdn_to_md.py</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> parsel</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tomd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article_info</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=headers).text</span><br><span class="line">    selector = parsel.Selector(html)</span><br><span class="line">    urls = selector.css(<span class="string">&#x27;#articleMeList-blog &gt; div.article-list &gt; div &gt; h4 &gt; a&#x27;</span>).xpath(<span class="string">&#x27;.//@href&#x27;</span>).getall()</span><br><span class="line">    print(<span class="string">&#x27;共找到%d篇文章...&#x27;</span> % <span class="built_in">len</span>(urls))</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html_from_csdn</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=headers).text</span><br><span class="line">    selector = parsel.Selector(html)</span><br><span class="line">    title = selector.css(<span class="string">&#x27;div.article-title-box &gt; h1::text&#x27;</span>).get()</span><br><span class="line">    article = selector.css(<span class="string">&#x27;div.article_content&#x27;</span>).get()</span><br><span class="line">    category = selector.css(<span class="string">&#x27;div.blog-tags-box &gt; div &gt; a::text&#x27;</span>).getall()[<span class="number">0</span>]</span><br><span class="line">    tags = selector.css(<span class="string">&#x27;div.blog-tags-box &gt; div &gt; a[data-report-click*=&quot;mod&quot;]::text&#x27;</span>).getall()</span><br><span class="line">    time_stamp = selector.css(<span class="string">&#x27;div &gt; span.time::text&#x27;</span>).get()</span><br><span class="line">    author = selector.css(<span class="string">&#x27;#uid &gt; span.name::text&#x27;</span>).get()</span><br><span class="line">    origin = url</span><br><span class="line">    <span class="keyword">return</span> title, article, category, tags, time_stamp, author, origin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_to_md</span>(<span class="params">title, article, category, tags, time_stamp, author, origin</span>):</span></span><br><span class="line">    md = tomd.convert(article)</span><br><span class="line">    <span class="comment"># 图片url标准化</span></span><br><span class="line">    url_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;img.*?(https://.*?\.gif|https://.*?\.png).*?&quot;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> src_url <span class="keyword">in</span> url_pattern.finditer(md):</span><br><span class="line">        img_name = src_url.group(<span class="number">1</span>).split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        md = md.replace(src_url.group(<span class="number">0</span>), <span class="string">&#x27;![%s](%s)&#x27;</span> % (img_name, src_url.group(<span class="number">1</span>)))</span><br><span class="line">    print(<span class="string">&#x27;正在下载 %s&#x27;</span> % title)</span><br><span class="line">    text = <span class="string">&quot;---\ntitle: %s\ndate: %s\ntags: [%s]\ncategories: %s\n---\n\n&gt; 作者: %s\n&gt; 原文链接: %s\n%s&quot;</span> % (</span><br><span class="line">        title, time_stamp, <span class="string">&#x27;, &#x27;</span>.join(tags), category, author, origin, md)</span><br><span class="line">    <span class="comment"># Windows下文件名字不能包含特殊符号</span></span><br><span class="line">    file_name = re.sub(<span class="string">r&#x27;[\\/:*?&quot;&lt;&gt;|]&#x27;</span>, <span class="string">&#x27; &#x27;</span>, title)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;articles/%s.md&#x27;</span> % file_name.strip(), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;articles&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;articles&#x27;</span>)</span><br><span class="line">    article_urls = get_article_info(url)</span><br><span class="line">    <span class="keyword">for</span> article_url <span class="keyword">in</span> article_urls:</span><br><span class="line">        title, article, category, tags, time_stamp, author, origin = get_html_from_csdn(article_url)</span><br><span class="line">        html_to_md(title, article, category, tags, time_stamp, author, origin)</span><br><span class="line">    print(<span class="string">&#x27;完成%d篇文章的下载&#x27;</span> % <span class="built_in">len</span>(article_urls))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;blog.csdn.net&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start_url = <span class="string">&quot;https://blog.csdn.net/用户名&quot;</span></span><br><span class="line">    main(start_url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>本文解决了将 CSDN 上使用富文本编辑器写的文章下载到本地转化成 Markdown 格式的问题，然后再配合上一篇中实现的一键发布脚本，就可以实现三个博客站点的同步了。到这里，已经实现了我自认为很完美的效果，以后就可以开开心心安安静静的写博客了。</p>
<p>我们看别人的独立博客，包括一些博主自己定制的博客园页面时，经常会看到一些有意思的特效，比如切换页签时原标题会变成调皮搞笑的文字，页面点击出现文字或爱心，页面出现跟随鼠标的随机线条，页面动态下雨或雪花，还有可以点击互动的小老鼠、二次元妹子等等，这些效果有的 Hexo 主题就内置了只需要把开关打开，有的需要自己手动加代码实现，因为它们本质上就是一段 js 代码(突然想起在以前公司有一次被安排到前端帮忙，曾经“沉迷”于在系统登录页面添加这些特效，hh)。还有一些针对 Hexo 的优化内容，比如提升页面加载速度，seo 优化，全文搜索插件等。这两项内容准备在最后一篇文章介绍。</p>
<p>写本系列文章第一篇之前，我并没有接触过 Hexo 这些东西，不知道 GitHub Pages 还能这样用，更不知道原来搭建博客里面有这么大的名堂，甚至一直没用 Markdown 写博客。决定自己搭建博客后，我先大概查了一下资料，然后把 8 篇文章的标题确定下来，形成一个大纲。其实在写前面几篇文章的时候，我还没把自己的博客搭起来，是后面一边学习一边操作一边记录，从小白的角度去弄懂每个步骤的原理，将过程记录下来，希望可以帮助更多的小伙伴。还有个意外收获，那就是发现了这是一个学习新东西的好方法。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>html转markdown</tag>
        <tag>下载csdn文章</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(三)——基于 Gitee pages 建站</title>
    <url>/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%89)%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%20Gitee%20pages%20%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第三篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li><strong>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></strong></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇文章里，我们利用 Hexo 框架在本地搭建了一个精美的博客，第二篇文章里，我们利用 GitHub 提供的免费静态网页托管服务建立了个人博客网站，将博客发布到了互联网上。</p>
<p>可是我们写博客的原因，一个是方便自己在不同的地方能直接打开网页就可以回顾知识，一个是为了方便他人查阅参考。由于国内网络环境的原因，某些地方某些时间，访问 GitHub 会比较慢，这就会导致博客无法被别人访问或者自己换个地方上网时也打不开自己的博客。</p>
<p>好消息是现在国内有和 GitHub 功能类似的 Gitee，中文名码云。之前也有注意到这个平台，当时以为他仅仅是山寨 GitHub 而已，肯定火不起来。没想到随着 GitHub 网络环境越来越差，下载个工程才几kb的速度，经常等了很久之后下载失败。有一次尝试了下将 GitHub 项目同步到 Gitee 再下载，速度直接起飞，真香。随着许多有影响力的项目加入了 Gitee ，一些大佬的博客也开始推荐使用码云了，使用的人也越来越多了。</p>
<p>当然了，使用 Gitee Pages 相对于 GitHub Pages 网速是上来了，也有很多缺点。我在实际使用过程中遇到了许多DAN疼的地方，比如每次提交需要手动更新部署，以及大于1M图片登陆后可见等，我会在下面文章中用<strong>加粗</strong>字体指出。没办法，鱼和熊掌不可兼得( ╯▽╰)。准备在第八篇讲优化的文章中尝试一种完美解决方案(GitHub + CDN加速)。</p>
<p>本篇文章介绍怎样利用 Gitee  提供的免费静态网页托管服务 Gitee Pages 建站。</p>
<h2 id="一、-Gitee-Pages-简介"><a href="#一、-Gitee-Pages-简介" class="headerlink" title="一、 Gitee Pages 简介"></a>一、 Gitee Pages 简介</h2><p>上篇说了，GitHub 设计 Pages 功能是为了让用户能设计一个图文并茂的网页作为项目首页，提升新手友好度。那么Gitee为什么要提供网页托管服务呢？应该是同样的原因，或者说是因为 GitHub 有这个功能？( ╯▽╰)</p>
<p><a href="https://gitee.com/help/articles/4136">Gitee pages 官网</a> 的介绍：Gitee Pages 是一个免费的静态网页托管服务，您可以使用 Gitee Pages 托管博客、项目官网等静态网页。如果您使用过 Github Pages 那么您会很快上手使用 Gitee 的 Pages服务。目前 Gitee Pages 支持 Jekyll、Hugo、Hexo编译静态资源。</p>
<h2 id="二、Gitee-Pages-准备"><a href="#二、Gitee-Pages-准备" class="headerlink" title="二、Gitee Pages 准备"></a>二、Gitee Pages 准备</h2><p>在发布之前，要先准备好自己的 Gitee Pages 。</p>
<p>Gitee Pages 仓库的创建方法和 GitHub 略有不同，官网的帮助文档提供了两种创建方法，第一种是直接在 Gitee 上创建仓库，第二种是直接把 GitHub 创建好的仓库同步过来。比如已经按照上一篇的方法在 GitHub 建立了博客，想在 Gitee 再搭建一次作为一个备份，可以直接用第二种方法同步过来。</p>
<h3 id="1-注册-Gitee-账号"><a href="#1-注册-Gitee-账号" class="headerlink" title="1. 注册 Gitee 账号"></a>1. 注册 Gitee 账号</h3><p>首先需要注册一个 Gitee 账号，如果已经有账号直接看下一步。</p>
<p>打开 Gitee 官网：<a href="https://gitee.com/">gitee.com</a>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193126082.png" alt="image-20201231193126082"></p>
<p>点击右上角<kbd>注册</kbd>按钮，填写用户名，手机，验证码。也可以根据下面的选项使用其他平台账号登录。注意，此处用户名是唯一ID，建议取个有意义的名字。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193349306.png" alt="image-20201231193349306"></p>
<h3 id="2-创建-Gitee-Pages-仓库"><a href="#2-创建-Gitee-Pages-仓库" class="headerlink" title="2. 创建 Gitee Pages 仓库"></a>2. 创建 Gitee Pages 仓库</h3><p>登录账号后，点击页面右上角的<kbd>+</kbd>，选择<kbd>新建仓库</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193543517.png" alt="image-20201231193543517"></p>
<p>仓库名称这里建议填写<code>你的用户名</code>，这样生成出来的网页地址是比较纯净的形式，如<code>https://&lt;你的用户名&gt;.github.io</code>。当然也可以自定义名称，比如<code>blog </code>，但是这样后面生成出来的网页地址会带一个子目录，像<code>https://&lt;你的用户名&gt;.github.io/blog</code>这样。</p>
<p>仓库介绍填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p>
<p>注意勾选 <code>使用Readme文件初始化这个仓库</code>，会自动创建<code>master</code>分支并生成一个 <code>readme.md</code>文件。</p>
<p>最后点击下面的<kbd>创建</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231214142085.png" alt="image-20201231214142085"></p>
<p>点击页面右上角的<kbd>服务</kbd>，选择<kbd>Gitee Pages</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231215720997.png" alt="image-20201231215720997"></p>
<p>勾选<code>强制使用HTTPS</code>，点击<kbd>启动</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231220540958.png" alt="image-20201231220540958"></p>
<h3 id="3-测试-Gitee-Pages-页面"><a href="#3-测试-Gitee-Pages-页面" class="headerlink" title="3. 测试  Gitee Pages 页面"></a>3. 测试  Gitee Pages 页面</h3><p>创建 Gitee Pages 仓库后，为了测试能否访问 Pages 服务，我们给它添加一个静态网页。</p>
<p>先点击左边的<kbd>代码</kbd>回到文件页面，然后点击<kbd>文件</kbd> – <kbd>新建文件</kbd>在仓库下新建文件。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231220911962.png" alt="image-20201231220911962"></p>
<p>输入文件名<code>index.html</code>，在下面输入内容<code>&lt;h1&gt;这是我的博客!&lt;/h1&gt;</code>，这是 html 标记语言，表示一级标题。</p>
<p>其他保持默认，点击最下面的<kbd>提交</kbd>，提交文件到仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231221057010.png" alt="image-20201231221057010"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231195353883.png" alt="image-20201231195353883"></p>
<p><strong>与 GitHub 提交自动部署不同的是，Gitee上提交后需要手动部署。</strong>(网上有许多实现了 Gitee Pages 自动部署的脚本，其实就是用脚本模拟下面的操作，可以参考)</p>
<p>点击页面右上角的<kbd>服务</kbd>，选择<kbd>Gitee Pages</kbd>回到部署界面。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222024946.png" alt="image-20201231222024946"></p>
<p>点击下面的<kbd>更新</kbd>，下图中红框圈出的就是你的博客地址了，格式为<code>https://&lt;你的用户名&gt;.github.io</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222215450.png" alt="image-20201231222215450"></p>
<p>点击博客地址或者在浏览器输入博客地址。此时就可以看见我们刚创建的网页，其中的内容就是刚才写的内容。说明 Gitee Pages 服务已经正常。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222626659.png" alt="image-20201231222626659"></p>
<h2 id="三、Gitee-Pages-发布"><a href="#三、Gitee-Pages-发布" class="headerlink" title="三、Gitee Pages 发布"></a>三、Gitee Pages 发布</h2><p>上一步 “测试  Gitee Pages 页面” 中，我们在 Gitee Pages 仓库目录下新建了一个<code>index.html</code>，就可以在自己的专属网址看到这个网页了。同理我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。当然，对于 Hexo 来说，部署提交只需要几条命令。</p>
<h3 id="1-配置-Git-参数"><a href="#1-配置-Git-参数" class="headerlink" title="1. 配置 Git 参数"></a>1. 配置 Git 参数</h3><p>过程跟上篇文章一样，已经做过的步骤不用再重复，直接到复制公钥那一步。</p>
<p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>配置用户名和邮箱，这两个参数用于 Git 提交时的身份识别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username 和 username@XXX.com 是你注册 Gitee 的用户名和邮箱，如果账号不是邮箱注册的话，填自己的一个邮箱地址就行了</span></span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233907818.png" alt="image-20201229233907818"></p>
<p>生成 SSH keys，主要用于Git 提交时的权限控制和加密，本地根据 RSA 算法生成公私密钥对，然后将公钥添加到 Gitee 上，本机就可以提交代码到自己的 GitHub 库了。这个是根据当前使用的电脑的一些信息生成的，所以换电脑提交时要重新生成并添加。</p>
<p>输入下面命令，然后一直按<kbd>回车</kbd>，直到结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username@XXX.com 同上，是你的注册邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image-20201229233801498"></p>
<p>输入下面的命令，查看公钥内容，应该是一个<code>ssh-rsa</code>开头，以<code>你的邮箱</code>结尾的长字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat后面的路径就是上图中的公钥文件路径，直接复制过来就可以。其中XXX是你的电脑用户名。</span></span><br><span class="line">cat /c/Users/XXX/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229234452012.png" alt="image-20201229234452012"></p>
<p>复制公钥内容（其实在<kbd>Git Bash</kbd>命令行里，默认选中文字松开鼠标就会自动把选中内容复制到剪贴板，点击鼠标中键是粘贴）。</p>
<p>打开自己的 Gitee 主页，点击右上角的头像，点击<kbd>设置</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231223248489.png" alt="image-20201231223248489"></p>
<p>点击<kbd>SSH公钥</kbd>。<code>标题</code>可以随便起一个名字，<code>公钥</code>填写上一步复制的公钥内容，然后点击<kbd>确定</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231223630767.png" alt="image-20201231223630767"></p>
<p>最后执行下面的命令，测试一下 Git 参数是否配置成功。出现<code>你的用户名</code>和<code>successfully</code>字样，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的命令什么都不用改</span></span><br><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210101125339173.png" alt="image-20210101125339173"></p>
<h3 id="2-安装-Hexo-发布插件"><a href="#2-安装-Hexo-发布插件" class="headerlink" title="2. 安装 Hexo 发布插件"></a>2. 安装 Hexo 发布插件</h3><p>上一篇已经安装过可以跳过这一步。</p>
<p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>输入下面的命令，安装<code>hexo-deployer-git</code>。（安装失败或者卡住，参考第一篇文章修改 npm 源。）</p>
<p>这个插件用于把生成好的静态页面上传到 Gitee Pages 仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230001107308.png" alt="image-20201230001107308"></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3.  发布 ! ! !"></a>3.  发布 ! ! !</h3><p>从第一篇到现在这么多步骤过去了，可以说前面的所有操作都是在为最后的这一步<code>发布</code>做准备，现在终于到了见证奇迹的时刻了。</p>
<p>先别着急激动，让我们完成最最后一步配置，我们需要告诉 hexo 发布到哪里去，也就是把文件上传到哪个仓库。</p>
<p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名，注意是master分支</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@gitee.com:xxxxxx/xxxxxx.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>OK，现在万事俱备了，执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>待命令执行完毕，还记得<strong>Gitee上提交后需要手动部署</strong>吗？此时需要按照<code>3. 测试  Gitee Pages 页面</code>的方法更新部署。</p>
<p>打开浏览器，输入网址<code>https://你的用户名.gitee.io</code>，可以看到一个和第一篇中本地部署的一模一样的博客出现了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210102003427597.png" alt="image-20210102003427597"></p>
<p>之前为了测试而发布的文章也在。<code>https://你的用户名.gitee.io</code>就是你的个人博客地址了，其他人都可以访问。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210102003454287.png" alt="image-20210102003454287"></p>
<h2 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h2><p>至此，我们从零开始搭建一个博客的任务初步完成了。</p>
<p>本篇文章介绍了利用 Gitee Pages 发布个人博客的方法，如果觉得 Gitee 每次发布博客需要手动更新太麻烦，可以参考上一篇文章，基于 Github Pages 搭建博客站点。</p>
<p>我看到许多人的博客搭建好了，一直停留在一开始初始化的状态，没有新增过一篇文章，希望大家别把最重要事情忘了，我们搭网站是为了写博客，一定要坚持下去。工欲善其事，必先利其器，接下来第四篇文章，介绍怎么更方便地写 Markdown 格式的博客。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(二)——基于 GitHub pages 建站</title>
    <url>/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%8C)%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%20GitHub%20pages%20%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第二篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li><strong>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></strong></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇文章里，我们利用 Hexo 框架在本地搭建了一个精美的博客，可是只能本地访问，要想发布到互联网上，还需要将它部署在网站上。</p>
<p>博客的功能只要能阅读文章就够了，因此可以考虑将其部署在提供静态网页托管服务的网站上，这样就省去了购买服务器(云主机)，购买域名，购买大网 IP 这些步骤，不仅省钱，更重要的是省事儿。</p>
<p>当前云计算如此流行，许多平台都提供了静态网页托管服务，其中最方便的当然是 GitHub Pages，只需要注册一个账号就可以使用。GitHub Pages的服务器毕竟在国外，如果觉得访问太慢，也可以选择国内功能相似的 Gitee Pages。</p>
<p>本篇文章介绍怎样利用 GitHub 提供的免费静态网页托管服务 GitHub Pages 建站。</p>
<h2 id="一、-GitHub-Pages-简介"><a href="#一、-GitHub-Pages-简介" class="headerlink" title="一、 GitHub Pages 简介"></a>一、 GitHub Pages 简介</h2><p>GitHub 是世界上最流行的软件源代码托管服务平台，为什么要提供网页托管服务呢？</p>
<p>这是因为一个项目的主页如果只有源码，对新接触的人很不友好，不知从何处下手。虽然已经有了 readme.md 文件，但毕竟不如一个直观的网页来的直接。于是 GitHub 就设计了 Pages 功能，允许用户设计一个图文并茂的网页作为项目首页。</p>
<p>虽然 GitHub Pages 的初衷是提供自定义的项目首页，但是它的玩法不止这一个。因此许多博主都用这个功能来搭建自己的博客，因为它实在是太太方便了。</p>
<p>去GitHub Pages 官网 <a href="https://pages.github.com/">pages.github</a> ，拉到最后，可以看到官方也推荐使用 GitHub Pages 搭建博客，并且提供了示例教程。</p>
<h2 id="二、GitHub-Pages-准备"><a href="#二、GitHub-Pages-准备" class="headerlink" title="二、GitHub Pages 准备"></a>二、GitHub Pages 准备</h2><p>在发布之前，要先准备好自己的GitHub Pages 。</p>
<h3 id="1-注册-GitHub-账号"><a href="#1-注册-GitHub-账号" class="headerlink" title="1. 注册 GitHub 账号"></a>1. 注册 GitHub 账号</h3><p>首先需要注册一个 GitHub 账号，如果已经有账号直接看下一步。</p>
<p>打开 GitHub 官网：<a href="https://github.com/">github.com</a>。如果这里打开速度已经不容忍受了，建议直接看下一篇使用 Gitee 建站。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229223941265.png" alt="image-20201229223941265"></p>
<p>点击右上角<kbd>Sign up</kbd>注册，填写用户名，邮箱，密码。注意，此处用户名是唯一ID，建议取个有意义的名字。点击注册后会发送一封验证邮件到填写的邮箱，登录自己的邮箱点击链接进行验证，GitHub 账号就注册好了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224251159.png" alt="image-20201229224251159"></p>
<h3 id="2-创建-GitHub-Pages-仓库"><a href="#2-创建-GitHub-Pages-仓库" class="headerlink" title="2. 创建 GitHub Pages 仓库"></a>2. 创建 GitHub Pages 仓库</h3><p>点击右上角<kbd>Sign in</kbd>登录后，点击左上角<kbd>New</kbd>新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224505117.png" alt="image-20201229224505117"></p>
<p>由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 Repository name 必须填<code>&lt;你的用户名&gt;.github.io</code>，否则就会建立一个普通仓库，GitHub Pages 功能不会生效。比如用户名是<code>jacksparrow</code>，Repository name 这里就填<code>jacksparrow.github.io</code>，不知道用户名是哪个，可以点击页面右上角头像，看到第一行“Signed in as <code>xxx</code>”字样， <code>xxx</code>即为这里的用户名。</p>
<p>Description 填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p>
<p>注意勾选 <code>Public</code> ，否则 GitHub Pages 功能不会生效。建议勾选 <code>Add a README file</code>，会自动生成一个 <code>readme.md</code>文件。</p>
<p>最后点击<kbd>Create repository</kbd>创建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image-20201229224741804"></p>
<h3 id="3-测试-GitHub-Pages-页面"><a href="#3-测试-GitHub-Pages-页面" class="headerlink" title="3. 测试  GitHub Pages 页面"></a>3. 测试  GitHub Pages 页面</h3><p>创建 GitHub Pages 仓库后，为了测试能否访问 GitHub Pages 服务，我们给它添加一个静态网页。</p>
<p>点击<kbd>Add file</kbd> – <kbd>Create new file</kbd>在仓库下新建文件。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225208056.png" alt="image-20201229225208056"></p>
<p>输入文件名<code>index.html</code>，在下面输入内容<code>&lt;h1&gt;Hello My Blog!&lt;/h1&gt;</code>，这是 html 标记语言，表示一级标题。</p>
<p>其他保持默认，点击最下面<kbd>Commit new file</kbd>提交文件到仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image-20201229225639083"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225731351.png" alt="image-20201229225731351"></p>
<p>然后在浏览器打开一个新的网页，输入网址<code>https://&lt;你的用户名&gt;.github.io</code>，就可以看见我们刚创建的网页，其中的内容就是刚才写的内容。说明 GitHub Pages 服务已经正常。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image-20201229230057034"></p>
<h2 id="三、GitHub-Pages-发布"><a href="#三、GitHub-Pages-发布" class="headerlink" title="三、GitHub Pages 发布"></a>三、GitHub Pages 发布</h2><p>上一步 “测试  GitHub Pages 页面” 中，我们在 GitHub Pages 仓库目录下新建了一个<code>index.html</code>，就可以在自己的专属网址看到这个网页了。同理我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。当然，对于 Hexo 来说，提交部署只需要几条命令。</p>
<h3 id="1-配置-Git-参数"><a href="#1-配置-Git-参数" class="headerlink" title="1. 配置 Git 参数"></a>1. 配置 Git 参数</h3><p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>配置用户名和邮箱，这两个参数用于 Git 提交时的身份识别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username 和 username@XXX.com 是你注册 GitHub 的用户名和邮箱</span></span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233907818.png" alt="image-20201229233907818"></p>
<p>生成 SSH keys，主要用于Git 提交时的权限控制和加密，本地根据 RSA 算法生成公私密钥对，然后将公钥添加到 GitHub 上，本机就可以提交代码到自己的 GitHub 库了。这个是根据当前使用的电脑的一些信息生成的，所以换电脑提交时要重新生成并添加。</p>
<p>输入下面命令，然后一直按<kbd>回车</kbd>，直到结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username@XXX.com 是你注册 GitHub 的邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image-20201229233801498"></p>
<p>输入下面的命令，查看公钥内容，应该是一个<code>ssh-rsa</code>开头，以<code>你的邮箱</code>结尾的长字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat后面的路径就是上图中的公钥文件路径，直接复制过来就可以</span></span><br><span class="line">cat /c/Users/XXX/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229234452012.png" alt="image-20201229234452012"></p>
<p>复制公钥内容（其实在<kbd>Git Bash</kbd>命令行里，默认选中文字松开鼠标就会自动把选中内容复制到剪贴板，默认鼠标中键是粘贴）。</p>
<p>打开自己的 Github 主页，点击右上角的头像，点击<kbd>Settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235035462.png" alt="image-20201229235035462"></p>
<p>点击<kbd>SSH and GPG keys</kbd>，然后点击<kbd>New SSH keys</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image-20201229235220955"></p>
<p>Title 可以随便起一个名字，Key 填写上一步复制的公钥内容，然后点击<kbd>Add SSH key</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235704322.png" alt="image-20201229235704322"></p>
<p>最后执行下面的命令，测试一下 Git 参数是否配置成功。出现<code>你的用户名</code>和<code>successfully</code>字样，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的命令什么都不用改</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230000424483.png" alt="image-20201230000424483"></p>
<h3 id="2-安装-Hexo-发布插件"><a href="#2-安装-Hexo-发布插件" class="headerlink" title="2. 安装 Hexo 发布插件"></a>2. 安装 Hexo 发布插件</h3><p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>输入下面的命令，安装<code>hexo-deployer-git</code>。（安装失败或者卡住，参考第一篇文章修改 npm 源。）</p>
<p>这个插件用于把生成好的静态页面上传到 GitHub Pages 仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230001107308.png" alt="image-20201230001107308"></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3.  发布 ! ! !"></a>3.  发布 ! ! !</h3><p>从第一篇到现在这么多步骤过去了，可以说前面的所有操作都是在为最后的这一步<code>发布</code>做准备，现在终于到了见证奇迹的时刻了。</p>
<p>先别着急激动，让我们完成最最后一步配置，我们需要告诉 hexo 发布到哪里去，也就是把文件上传到哪个仓库。</p>
<p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxxxx/xxxxxx.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>OK，现在万事俱备了，执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>待命令执行完毕，打开浏览器，输入网址<code>https://你的用户名.github.io</code>，可以看到一个和第一篇中本地部署的一模一样的博客出现了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230002849289.png" alt="image-20201230002849289"></p>
<p>之前为了测试而发布的文章也在。<code>https://你的用户名.github.io</code>就是你的个人博客地址了，其他人都可以访问。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230003033418.png" alt="image-20201230003033418"></p>
<h2 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h2><p>至此，我们从零开始搭建一个博客的任务初步完成了。</p>
<p>本篇文章介绍了利用 GitHub Pages 发布个人博客的方法，如果觉得 GitHub 访问速度太慢，可以参考下面一篇文章，基于 Gitee Pages 搭建国内博客站点。如果觉得 GitHub Pages 很满意了，可以关注本系列后续文章，会继续介绍怎么更方便地写博客、老博客迁移到新站点以及主题个性化设置等内容。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>实用软件推荐(一)——自动更换壁纸 (Dynamic theme)</title>
    <url>/2020/08/23/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90(%E4%B8%80)%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8%20(Dynamic%20theme)/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107904698">https://blog.csdn.net/yushuaigee/article/details/107904698</a></p>
</blockquote>
<p>我对自己的电脑整洁要求比较高，安装的软件都要精挑细选，每次都要去找几个同类功能的软件下载下来，比较一番，最终留下最合适的一个。如果没有一个满足要求的又必须使用这个软件功能，那就装完用一下赶紧卸载，所以最后电脑上剩下的软件都是“精品”，哈哈(●´∀｀●)。平时逛网站看到一些比较强大、方便、有意思的软件，即使暂时用不到我也会收藏起来，积累了一大批实用工具，前段时间趁着换硬盘迁移数据的机会，我又把这些软件筛选了一下，把一些过时的、有更好的替代品的软件都删掉了。现在我就把这些“宝藏”分享一下。</p>
<p>我自己选择软件，有几个原则，优先级由高到低：</p>
<ul>
<li> 功能满足。肯定肯定要满足需要的功能，不然下载它干啥 </li>
<li> 界面美观。软件的界面一定要让人看着舒服，但是也不能花里胡哨。 </li>
<li> 功能简洁。我不喜欢一个软件塞很多根本用不到的功能，看见就很烦，破坏简洁美。 </li>
<li> 最好开源。这个原因是一般开源软件都会满足上面三个条件，而且比较好获取，直接去下载就行了。 </li>
<li> 绿色免安装。绿色软件解压即用，免去纠结安装在哪个盘，要不要检查开机启动之类的烦恼。 </li>
</ul>
<h2 id="Dynamic-theme"><a href="#Dynamic-theme" class="headerlink" title="Dynamic theme"></a>Dynamic theme</h2><p>今天推荐的第一款软件 Dynamic theme，每天自动更新桌面壁纸，壁纸源可以选Windows聚焦和Bing每日壁纸。微软Bing搜索的首页每天会更新一张非常漂亮图片，相信很多人看到都会有把这些图片设为桌面壁纸的冲动，这款软件就满足了这个功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823174716788.png" alt="20200823174716788.png"></p>
<p>Dynamic theme的界面非常简洁，模仿Win10的风格，用起来感觉是系统自带的设置一样。</p>
<p><strong>图标：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823175437664.png" alt="20200823175437664.png"></p>
<p><strong>主界面：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823175419211.png" alt="20200823175419211.png"></p>
<p>默认是从Bing首页下载壁纸，可以点击切换。点击“查看历史”，可以查看最近更新的壁纸。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823192343810.gif" alt="20200823192343810.gif"></p>
<p>它不仅能自动换桌面壁纸，也可以换锁屏界面和windows动态磁贴的背景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182101938.png" alt="20200823182101938.png"></p>
<p>有些图片可能太美了想收藏到电脑里，这里可以设置每日壁纸自动保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182343564.png" alt="20200823182343564.png"></p>
<p>软件安装打开后默认会开机启动，但是除了每天桌面壁纸会自动更换之外，你不会有任何感觉，系统托盘也不会出现图标。如果不想使用，可以直接卸载。如果不想卸载，可以到windows设置里把它的“后台应用”权限关闭。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823184026498.png" alt="20200823184026498.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823184102552.png" alt="20200823184102552.png"></p>
<h2 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h2><p>Win10或Win8系统，下载方法非常简单，直接在应用商店搜索Dynamic theme下载安装即可，软件一共就100多k，即使微软商店很慢也不用等很久。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182924271.png" alt="20200823182924271.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823183354895.png" alt="20200823183354895.png"></p>
<h2 id="WinDynamicDesktop"><a href="#WinDynamicDesktop" class="headerlink" title="WinDynamicDesktop"></a>WinDynamicDesktop</h2><p>如果是Win7用户，可以试试这款功能类似的开源软件 WinDynamicDesktop，它是模仿macOS的动态桌面，可以根据时间变化动态调整桌面壁纸，让我们的桌面壁纸跟随一天从早到晚的时间变化呈现不同的视觉效果。这个软件比 Dynamic theme 强大，不过设置也更复杂，我还是推荐上面说的 Dynamic theme。</p>
<p>软件发布地址：<a href="https://github.com/t1m0thyj/WinDynamicDesktop/releases">https://github.com/t1m0thyj/WinDynamicDesktop/releases</a></p>
<p>源码地址：<a href="https://github.com/t1m0thyj/WinDynamicDesktop">https://github.com/t1m0thyj/WinDynamicDesktop</a></p>
<p>因为我是Win10，这个我没有亲测过，截图是在网上找的，详细介绍看这篇 <a href="https://sspai.com/post/59458">WinDynamicDesktop：让 Windows 10 拥有随时间变化的动态壁纸</a>。</p>
<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3NwYWkuY29tLzIwMjAvMDMvMTMvNDczMjY3MTRiN2JmYmQyMzRmNDFkYjc0YzlhMWFmM2EucG5n?x-oss-process=image/format,png">

<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3NwYWkuY29tLzIwMjAvMDMvMTMvY2IzZDE5MDJjYTM0NWE0NWI4M2ZlYzEwZWJiMDIyYzgucG5n?x-oss-process=image/format,png">
]]></content>
      <categories>
        <category>软件推荐</category>
      </categories>
  </entry>
  <entry>
    <title>彻底弄懂 Linux 下的文件描述符（fd）</title>
    <url>/2020/08/14/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107883964">https://blog.csdn.net/yushuaigee/article/details/107883964</a></p>
</blockquote>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#1%E3%80%81%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E8%B5%B7">1、从一个最常见的例子说起</a></p>
</li>
<li><p><a href="#2%E3%80%81Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88file%20descriptor%EF%BC%89">2、Linux中的文件描述符（file descriptor）</a></p>
</li>
<li><p><a href="#3%E3%80%81Linux%E4%B8%8A%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%BE%E4%BE%8B">3、Linux上打开文件举例</a></p>
</li>
<li><p><a href="#4%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8">4、C语言中文件描述符的使用</a></p>
</li>
<li><p><a href="#5%E3%80%81Python%E4%B8%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8">5、Python中文件描述符的使用</a></p>
</li>
<li><p><a href="#6%E3%80%81Linux%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0">6、Linux配置系统最大打开文件描述符个数</a></p>
</li>
<li><p><a href="#7%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7、参考链接</a></p>
</li>
</ul>
<h3 id="1、从一个最常见的例子说起"><a href="#1、从一个最常见的例子说起" class="headerlink" title="1、从一个最常见的例子说起"></a>1、从一个最常见的例子说起</h3><p>在使用Linux的过程中， 我们平时经常看到下面这样的用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo log &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>&gt;</strong> ：表示将输出结果重定向到哪里，例如：echo “123” &gt; /home/123.txt</li>
<li><strong>/dev/null</strong> ：表示空设备文件</li>
</ul>
<p>所以 <strong>echo log &gt; /dev/null</strong> 表示把日志输出到空文件设备，也就是将打印信息丢弃掉，屏幕上什么也不显示。</p>
<ul>
<li><strong>1</strong> ：表示stdout标准输出</li>
<li><strong>2</strong> ：表示stderr标准错误</li>
<li><strong>&amp;</strong> ：表示等同于的意思</li>
</ul>
<p>所以 <strong>2&gt;&amp;1</strong> 表示2的输出重定向等同于1，也就是标准错误输出重定向到标准输出。因为前面标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>
<p>这个用法平时很常见，重点是为什么这里是用 <strong>2</strong> 和 <strong>1</strong> ，不是3456什么的呢？这要从 Linux 中的文件描述符说起。</p>
<h3 id="2、Linux中的文件描述符（file-descriptor）"><a href="#2、Linux中的文件描述符（file-descriptor）" class="headerlink" title="2、Linux中的文件描述符（file descriptor）"></a>2、Linux中的文件描述符（file descriptor）</h3><p>我们知道在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。</p>
<p>文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……</p>
<p>Linux内核对所有打开的文件有一个文件描述符表格，里面存储了每个文件描述符作为索引与一个打开文件相对应的关系，简单理解就是下图这样一个数组，文件描述符（索引）就是文件描述符表这个数组的下标，数组的内容就是指向一个个打开的文件的指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200813212007131.png" alt="20200813212007131.png"></p>
<p><strong>上面只是简单理解，实际上关于文件描述符，Linux内核维护了3个数据结构</strong>：</p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ul>
<p>一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。进程级的描述符表的每一条记录了单个进程所使用的文件描述符的相关信息，进程之间相互独立，一个进程使用了文件描述符<strong>3</strong>，另一个进程也可以用<strong>3</strong>。除了进程级的文件描述符表，系统还需要维护另外两张表：打开文件表、i-node 表。这两张表存储了每个打开文件的打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息。</p>
<p><strong>系统级的打开文件描述符表：</strong></p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时的标识（open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node 表指针</li>
</ul>
<p><strong>文件系统的i-node表：</strong></p>
<ul>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限</li>
<li>一个指针，指向该文件所持有的锁列表</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</li>
</ul>
<p><strong>文件描述符、打开的文件句柄以及i-node之间的关系如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/MDFINDVTMTMuZ2lm.gif" alt="MDFINDVTMTMuZ2lm"></p>
<ul>
<li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</li>
<li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li>
<li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </li>
</ul>
<p><strong>这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。</strong></p>
<h3 id="3、Linux上打开文件举例"><a href="#3、Linux上打开文件举例" class="headerlink" title="3、Linux上打开文件举例"></a>3、Linux上打开文件举例</h3><p>比如在Linux上用 <strong>vim test.py</strong> 打开一个文件，保持打开状态，再新打开一个新的shell，输入命令<strong>pidof vim</strong> 获取vim进程的pid号，然后 <strong>ll /proc/$pid/fd</strong> 查看vim 进程所使用的文件描述符列表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200813200300316.png" alt="20200813200300316.png"></p>
<p><strong>/dev/pts</strong>是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。因为我是通过Xshell远程登录的，所以标准输入0，标准输出1，标准错误2的文件描述符都指向虚拟终端控制台 <strong>/dev/pts/6 。</strong>再看下面是新打开的 test.py 的文件描述符，竟然是<strong>4</strong>，说好的从<strong>3</strong>开始呢？</p>
<p>这个我也困扰了好久，查了各种资料，终于在一个大佬的帮助下在一个论坛找到原因，有时候中文查不到还是要试试英文搜索啊。因为vim这种编辑器的原理是先打开源文件并拷贝，然后关闭源文件再打开自己的副本，修改完文件保存的时候直接将副本重命名覆盖源文件。所以打开源文件的时候用的文件描述符<strong>3</strong>，然后打开自己的副本是时候就该用文件描述符<strong>4</strong>了，然后关闭源文件，文件描述符<strong>3</strong>就被释放了，我们查看的时候就只剩下了<strong>4</strong>，这里它指向的是vim创建的副本文件。这里只是说个大概意思，具体深究要去深入了解一下 <a href="https://blog.csdn.net/weixin_43535689/article/details/104750148">vim的实现原理——奥尔特星云大使</a>，下面是当时我看到的论坛上的资料截图，链接在这：<a href="https://stackoverflow.com/questions/48588284/lsof-command-can-not-return-files-being-opened-by-kwrite">StackOverFlow</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200813204121774.png" alt="20200813204121774.png"></p>
<p>如果不相信可以试一试别的进程，比如 tail。</p>
<p>在Linux上用 <strong>tail -f test.py</strong> 打开一个文件，保持打开状态，再新打开一个新的shell，输入命令<strong>pidof tail</strong> 获取tail进程的pid号，然后 <strong>ll /proc/$pid/fd</strong> 查看tail进程所使用的文件描述符列表，可以看到文件描述符确实是从<strong>3</strong>开始使用的。tail不是编辑器不存在修改文件的情况，所以直接文件描述符直接打开的源文件。实际上可以使用 <strong>ll /proc/$pid/fd</strong> 命令获取当前运行的任意进程的文件描述符使用情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2020081321574073.png" alt="2020081321574073.png"></p>
<h3 id="4、C语言中文件描述符的使用"><a href="#4、C语言中文件描述符的使用" class="headerlink" title="4、C语言中文件描述符的使用"></a>4、C语言中文件描述符的使用</h3><p>C语言中可以通过 open 函数返回一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test.c 文件，输入下面代码保存。 编译后执行，发现新打开文件的文件描述符是<strong>3</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;test.py&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test.py fd = %d \n&quot;</span>, fd);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814150406203.png" alt="20200814150406203.png"></p>
<h3 id="5、Python中文件描述符的使用"><a href="#5、Python中文件描述符的使用" class="headerlink" title="5、Python中文件描述符的使用"></a>5、Python中文件描述符的使用</h3><p>Python中通过 sys 模块封装了标准输入、标准输出和错误输出。通过我们平时常用的内建函数 open 可以获取一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test2.py 文件，输入下面代码保存。 执行，发现新打开文件的文件描述符是<strong>3</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">print(<span class="string">&#x27;stdin fd = &#x27;</span>, sys.stdin.fileno())</span><br><span class="line">print(<span class="string">&#x27;stdout fd = &#x27;</span>, sys.stdout.fileno())</span><br><span class="line">print(<span class="string">&#x27;stderr fd = &#x27;</span>, sys.stderr.fileno())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">&#x27;test.py fd = &#x27;</span>, f.fileno())</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814153527764.png" alt="20200814153527764"></p>
<h3 id="6、Linux配置系统最大打开文件描述符个数"><a href="#6、Linux配置系统最大打开文件描述符个数" class="headerlink" title="6、Linux配置系统最大打开文件描述符个数"></a>6、Linux配置系统最大打开文件描述符个数</h3><p><strong>（1）系统级限制</strong></p>
<p>理论上系统内存有多少就可以打开多少的文件描述符，但是在实际中内核是会做相应的处理，一般最大打开文件数会是系统内存的10%（以KB来计算），称之为系统级限制。这个数字可以通过 <strong>cat /proc/sys/fs/file-max</strong> 或者 <strong>sysctl -a | grep fs.file-max</strong> 命令查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814163652927.png" alt="20200814163652927"></p>
<p>更改系统级限制有临时更改和永久更改两种方式：</p>
<ul>
<li>临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 <strong>sysctl -w fs.file-max=xxxx</strong>，其中xxxx就是要设置的数字。</li>
<li>永久更改：vim编辑 <strong>/etc/sysctl.conf</strong> 文件，在后面添加 <strong>fs.file-max=xxxx</strong>，其中xxxx就是要设置的数字。保存退出后还要使用<strong>sysctl -p</strong> 命令使其生效。</li>
</ul>
<p><strong>（2）用户级限制</strong></p>
<p>同时为了控制每个进程消耗的文件资源，内核也会对单个进程最大打开文件数做默认限制，即用户级限制。32位系统默认值一般是1024，64位系统默认值一般是65535，可以使用 <strong>ulimit -n</strong> 命令查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814164901908.png" alt="20200814164901908"></p>
<h3 id="7、参考链接"><a href="#7、参考链接" class="headerlink" title="7、参考链接"></a>7、参考链接</h3><ol>
<li><a href="https://blog.csdn.net/cywosp/article/details/38965239">每天进步一点点——Linux中的文件描述符与打开文件之间的关系——cywosp</a></li>
<li> <a href="http://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？——C语言中文网</a></li>
<li> <a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符（FD）——阳光丶不锈</a></li>
<li> <a href="https://juejin.im/post/6844903962043236365#heading-0">带你破案：文件描述符到底是什么？——vran</a></li>
<li> <a href="http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/">Linux配置调优：最大打开文件描述符个数——Idea Buffer</a></li>
<li> <a href="https://blog.csdn.net/BlueguyChui/article/details/5676059">修改Linux系统下的最大文件描述符限制——BlueguyChui</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂 Python3中入参里的*号的作用</title>
    <url>/2020/07/25/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Python3%E4%B8%AD%E5%85%A5%E5%8F%82%E9%87%8C%E7%9A%84%E6%98%9F%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107567001">https://blog.csdn.net/yushuaigee/article/details/107567001</a></p>
</blockquote>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#Python3%E4%B8%AD%E5%87%A0%E7%A7%8D%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A">Python3中几种传递参数的方式：</a></p>
</li>
<li><p><a href="#1.%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">1.位置参数</a></p>
</li>
<li><p><a href="#2.%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">2.默认参数</a></p>
</li>
<li><p><a href="#3.%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">3.关键字参数</a></p>
</li>
<li><p><a href="#4.%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">4.可变参数</a></p>
</li>
<li><p><a href="#5.keyword-only%E5%8F%82%E6%95%B0">5.keyword-only参数</a></p>
</li>
<li><p><a href="#6.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">6.参考链接</a></p>
</li>
</ul>
<p>我们在看代码时，除了能看到普通的定义函数的入参写法，比如 <code>def func(param1, param2):</code> ，可能也会看到入参用 <code>*args, **kwargs</code>  来代替的写法，比如 <code>def func(*args, **kwargs)</code>:，此外还有一种写法，比如 <code>def func(param1, *, param2):</code>，中间多了一个单纯的<strong>星号</strong>，这个用法又是什么意思呢？先从Python中的几种传递参数的方式说起。</p>
<h3 id="Python3-中几种传递参数的方式"><a href="#Python3-中几种传递参数的方式" class="headerlink" title="Python3 中几种传递参数的方式"></a>Python3 中几种传递参数的方式</h3><ol>
<li>位置参数</li>
<li>默认参数</li>
<li>关键字参数</li>
<li>可变参数 (包括可变位置参数，可变关键字参数)</li>
<li>keyword-only参数 (命名关键字参数)</li>
</ol>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p><strong>位置参数</strong>是最普通、最常见的传参方式，位置参数必须按照先后顺序传入，传入的参数和定义时的参数，一一对应，例如下面的“<code>1</code>”传给了<code>param1</code>，“<code>2</code>”传给了<code>param2</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">param1, param2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;param1:&quot;</span>, param1)</span><br><span class="line">    print(<span class="string">&quot;param2:&quot;</span>, param2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 2</span></span><br></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数</strong>也比较常见，函数定义时给某个参数设置默认值，调用函数时如果不传这个参数，就使用默认值，如果传了就用传入值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">param1, param2=<span class="number">1</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;param1:&quot;</span>, param1)</span><br><span class="line">    print(<span class="string">&quot;param2:&quot;</span>, param2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;未传入默认参数时&quot;</span>)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;传入默认参数时&quot;</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 未传入默认参数时</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 1</span></span><br><span class="line"><span class="comment"># 传入默认参数时</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 2</span></span><br></pre></td></tr></table></figure>
<p>但是这里要注意，定义函数时如果同时有位置参数和默认参数，默认参数一定要在普通参数的后面，否则会报错如。这是Python语法规定，其实也很好理解，如果不规定顺序，像下面这个函数 <code>def func(param1, param2=1, param3):</code> ，如果传入2个参数，<code>func(1, 2)</code>，这个“<code>2</code>”是传给<code>param2</code>的还是<code>param3</code>的会有歧义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725192042437.png" alt="20200725192042437.png"></p>
<p>使用默认参数还有一个需要注意的地方，默认参数的默认值尽量使用不可变对象，<code>param2=1</code>、<code>param2=&quot;txt</code>“这种，否则会引起意想不到的问题。关于不可变对象可以参考：<a href="https://blog.csdn.net/yushuaigee/article/details/96745994#%E4%BA%8C%E3%80%81Python%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">Python中的不可变对象和可变对象</a></p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p><strong>关键字参数</strong>其实不能单独算作一类参数，是Python中比较方便的一个传参方式。就是在调用函数时，指定将哪个实参传给哪个形参，当然指定的形参名字必须是函数定义时所用的名字。其实普通的位置参数、默认参数、可变参数、keyword-only参数都可以用关键字参数的方式传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b,  c=<span class="number">3</span>, d=<span class="number">4</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">    print(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line">    print(<span class="string">&quot;c:&quot;</span>, c)</span><br><span class="line">    print(<span class="string">&quot;d:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">4</span>, c=<span class="number">3</span>)</span><br><span class="line">    func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(d=<span class="number">4</span>, c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出都是:</span></span><br><span class="line"><span class="comment"># a: 1</span></span><br><span class="line"><span class="comment"># b: 2</span></span><br><span class="line"><span class="comment"># c: 3</span></span><br><span class="line"><span class="comment"># d: 4</span></span><br></pre></td></tr></table></figure>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变</strong>参数</h3><p><strong>可变参数</strong>也叫动态参数，在Python标准库中见到的比较多。使用可变参数传入的参数的个数是动态的，可以是1个、2个到任意个，还可以是0个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&quot;type of args: &quot;</span>, <span class="built_in">type</span>(args))</span><br><span class="line">    print(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    print(<span class="string">&quot;type of kwargs: &quot;</span>, <span class="built_in">type</span>(kwargs))</span><br><span class="line">    print(<span class="string">&quot;kwargs:&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">3</span>, b=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># type of args:  &amp;lt;class &#x27;tuple&#x27;&amp;gt;</span></span><br><span class="line"><span class="comment"># args: (1, 2)</span></span><br><span class="line"><span class="comment"># type of kwargs:  &amp;lt;class &#x27;dict&#x27;&amp;gt;</span></span><br><span class="line"><span class="comment"># kwargs: &#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到动态参数分两种，一个是<em>开头，例如</em><code>args</code>，另一个是<code>**</code>开头，例如<code>**kwargs</code>。其中<code>args</code>和<code>kwargs</code>完全可以像其他参数一样自己命名，只是约定俗成的用<code>*args</code>和<code>**kwargs</code>，使用这两个IDE也会自动联想补全。<code>args</code>的类型是元组，调用函数时可以传入任意多的参数，这些参数会自动封装到<code>args</code>里，成为一个元组。<code>kwargs</code>的类型是字典，调用函数时可以传入任意多的自定义键值对参数，这些参数会自动封装到<code>kwargs</code>里，成为一个字典。</p>
<p>用<code>*args，**kwargs</code>组合的方式理论上可以传入任意值，许多标准库代码都是这样写的，<code>*args</code>必须写在<code>**kwargs</code>前面。但是我觉得如果真的所有函数入参都这样写，代码看起来会比较难懂，还是尽量不用这种方法。</p>
<p>那么在函数里面<code>args</code>和<code>*args</code>，<code>kwargs</code>、<code>*kwargs</code>、<code>**kwargs</code>有什么区别呢？可以试一下对比看看，下图中可以看出，<code>*</code>号在这里只是一个标识作用，是给解释器看的，相当于把元组和字典的键的内容取出来，不用太纠结这个，就是一种规定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725195231373.png" alt="20200725195231373.png"></p>
<p>同样可变参数位置参数和默认参数使用时也要注意顺序：位置参数、默认参数或<code>*args</code>、<code>**kwargs</code>。也就是说下面这两种方式都是可以的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725200127553.png" alt="20200725200127553.png"></p>
<h3 id="keyword-only参数"><a href="#keyword-only参数" class="headerlink" title="keyword-only参数"></a>keyword-only参数</h3><p><strong>keyword-only参数</strong>是 Python3 中新加入的特性，比较不多见。</p>
<p>定义时有一个单独的<em>号，其实这也只是一种规定，</em>号看上去像是一个参数，其实它不占参数个数，是给解释器看的。规定<code>*</code>号后面的参数，能且只能用<code>key=value</code>的方式传入，也就是上面第3步那种关键字参数传参形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, *, c=<span class="number">3</span>, d=<span class="number">4</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">    print(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line">    print(<span class="string">&quot;c:&quot;</span>, c)</span><br><span class="line">    print(<span class="string">&quot;d:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># a: 1</span></span><br><span class="line"><span class="comment"># b: 2</span></span><br><span class="line"><span class="comment"># c: 3</span></span><br><span class="line"><span class="comment"># d: 4</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数如果没有单独的星号，我们可以<code>func(1, 2, 3, 4)</code>, <code>func(1, 2, c=3, 4)</code>, <code>func(1, 2, c=3, d=4)</code>这样调用，而有了这个星号标识，就只能用 <code>func(1, 2, c=3, d=4)</code> 这种方式调用。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.liujiangblog.com/course/python/31">Python参数类型——刘江</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python中的GIL锁</title>
    <url>/2019/08/04/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E4%B8%AD%E7%9A%84GIL%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86537474">https://blog.csdn.net/yushuaigee/article/details/86537474</a></p>
</blockquote>
<p>刚学习python时，我关注了许多介绍python的公众号，也经常会在头条和知乎上收到关于python的文章的推送。在这些文章的评论区中，我经常会看到这样的说法：“Python是垃圾语言，先把GIL解决再说吧”，“又在吹Python，GIL不解决我永远不用Python”。刚开始，我也没去关注。后来Python用的越来越多，我不禁纳闷儿，我没感觉到GIL锁在使用python过程中有什么影响啊，事实上我根本感受不到它的存在，怎么会有这么多人因为GIL对python做出如此极端的评价？于是我决定研究一下GIL，看看这些人究竟是因为将Python的性能发挥到了极限，还是因为他们是一些Python的误(wu)解(nao)者(pen)。</p>
<h3 id="初识GIL"><a href="#初识GIL" class="headerlink" title="初识GIL"></a>初识GIL</h3><p>GIL，全称 Global Interpreter Lock ，全局解释锁。下面是<a href="https://wiki.python.org/moin/GlobalInterpreterLock">官方解释</a>中第一段：</p>
<blockquote>
<p> In CPython, the <strong>global interpreter lock</strong>, or <strong>GIL</strong>, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) </p>
</blockquote>
<p>我在金山词霸的帮助下翻译一下： </p>
<blockquote>
<p> 在cpython中，gil是一个互斥锁，用来保护对python对象的访问，防止多个线程同时执行python字节码。这个锁是必要的，主要是因为cpython的内存管理不是线程安全的。(然而，由于GIL的存在，其他新增的特性，为了省事都在默认线程安全的前提下进行，导致GIL成了不可或缺的依赖。) </p>
</blockquote>
<p>就是说，GIL在多线程编程时才会起作用，你如果用不到多线程就不必关心这个问题了。在多线程编程时，为了防止多个线程同时操作一个变量时发生冲突，我们会设置一个互斥锁，只有获取到这个锁的线程才可以操作这个变量，这样就确保了同一时间只有一个线程操作这个变量，这样做虽然安全了，但是并行变串行影响了程序的效率。而GIL是Python解释器为了程序的稳定性，在解释多线程的程序时加一把全局解释锁，保证同一时刻只有一个线程在被解释，也是并行变串行，效率自然也就变低了。本来我用了多线程就是为了并行提高效率，可是Python解释器告诉我，不好意思在我这里只有串行，那也怪不得有这么多人会很生气。</p>
<p>不过要明确一点，GIL不是Python的特性，它是Python的C解释器在实现的时候引入的特性，不是说我们的Python代码写出来就自带了GIL，而是在执行时，CPython解释器在解释多线程程序时会受到GIL锁的影响。 </p>
<p>首先说什么是解释器，我们知道像Python这样的动态语言，是边解释边执行的。我们写的源代码在运行时要先被转换成字节码，然后再转换为机器码，CPU才能执行。这个源代码–&gt;字节码–&gt;机器码的过程，就是Python解释器帮我们完成的。其实和C语言这种静态语言程序写好之后的编译链接的过程差不多，不过C语言只需要一次，而python是每次执行都要来一遍。那什么是Python的C解释器呢？因为Python的解释器有很多种，用C语言实现的就叫做CPython。此外还有IPython，PyPy，Jython，IronPython等，这么多类型有啥区别，下篇博客再做研究。而使用最广泛的、我们绝大多数使用的都是CPython，因为我们从官网下载python自带的解释器就是CPython，这就是为什么大家都把GIL作为诟病Python的理由。</p>
<p>我在想，既然有的解释器不存在GIL，那它们的流行程度为什么没有超过CPyhon呢？我猜想有两种可能，一是GIL锁这个缺点影响并不大，二就是因为CPython有着其他解释器无法替代的更多优点。到底是哪一个？下面继续研究。</p>
<h3 id="引入GIL的原因"><a href="#引入GIL的原因" class="headerlink" title="引入GIL的原因"></a>引入GIL的原因</h3><p>为什么说GIL的产生是历史原因？因为多线程编程是随着多核CPU发展而发展的，而Python第一版出来的时候还是单核CPU的时代，所以都是在单核CPU的前提下设计的。任由Guido这样的神人也不会想到多核CPU会发展的如此之快，再说当时Python的产生也是个“意外”，Guido也不会想到他1989年为了打发圣诞节假期发明的一种编程语言需要好好设计一下多线程的部分，否则会影响2019年地球对面的程序员在使用这个语言做多线程编程的效率。</p>
<p>以下引用自<a href="https://www.cnblogs.com/SuKiWX/p/8804974.html">python中的GIL详解——背着吉他的王小可</a></p>
<blockquote>
<p> 为了利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。<br> 慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。有多难？做个类比，像MySQL这样的“小项目”为了把Buffer Pool Mutex这把大锁拆分成各个小锁也花了从5.5到5.6再到5.7多个大版为期近5年的时间，本且仍在继续。MySQL这个背后有公司支持且有固定开发团队的产品走的如此艰难，那又更何况Python这样核心开发和代码贡献者高度社区化的团队呢？<br> 所以简单的说GIL的存在更多的是历史原因。如果推到重来，多线程的问题依然还是要面对，但是至少会比目前GIL这种方式会更优雅。  </p>
</blockquote>
<h3 id="解决GIL？"><a href="#解决GIL？" class="headerlink" title="解决GIL？"></a>解决GIL？</h3><p>Python社区这么多大牛，不会没有人想过去解决这个问题，只是到现在没有找到比现有方案更加有效和优雅的方案。经过几天的查阅资料，我意识到GIL在某些情况下确实算作Python的一个缺陷，但仅仅是某些情况下，所以不能因为这个全盘而否定Python这门编程语言，事实上否定也没用了，因为它现在实在是太火了。</p>
<p>我认为我们要认清事情的本质，不要谈GIL色变。作为编程语言的使用者，我们先分析自己的需求。</p>
<p>首先，如果没有用到多线程编程，整个程序只需要串行执行，你完全不必在意GIL的存在，看看热闹就行了。</p>
<p>其次，用到了多线程编程，但是对并行（同时做不同事情）没有要求，只是对并发（交替做不同事情）有要求。例如设想这样一个场景：一个服务器接收端，需要时刻监听发送端发送的消息，进行不同的操作，如果所做的操作需要耗时较长，这时如果只有一个线程，去执行耗时较长的操作时，会造成监听下一条消息的阻塞，这时候我们可以启动一个子线程去执行耗时的操作，同时主线程又继续监听下一条消息。这个情况下，我们受到GIL锁的影响不大，完全可以接受。</p>
<p>再者，如果确实对并行要求比较高，那么Python还有用multiprocess（多进程）替代Thread可供选择。multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。</p>
<p>最后，你如果觉得无论如何Python也不能解决你的问题，它实在太影响程序的效率了，那么为什么不换一个语言呢，从来没有人说速度是Python的强项。编程语言只是一门工具，程序员才是工具的使用者，我们不能让工具限制人，而是要合理利用不同的工具来达到自己的目的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结，我的两个问题也得到了答案，首先听到Python就喷GIL肯定是不对的。为什么其他解释器无法替代CPython的地位，既是因为GIL锁这个缺点影响并没有想像的那么大，也是因为CPython有着其他解释器无法替代的更多优点。GIL锁由于历史局限性而存在，作为一个效率方面的缺陷，它正在被积极的解决，但毫无疑问的是它还将继续长期存在。联想到最近香港的新闻，这使我想起了我们国家的“一国两制”和“搁置争议”，虽然看起来后面带来了一些难题，但是这不能改变这是当时最富有智慧的解决办法的事实。竟然和GIL的问题有些许的异曲同工之妙。。。</p>
<p>参考链接：</p>
<ul>
<li>1. GlobalInterpreterLock：<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a></li>
<li>2. Inside the Python GIL (David Beazley)：<a href="http://www.dabeaz.com/python/GIL.pdf">http://www.dabeaz.com/python/GIL.pdf</a></li>
<li>3. Understanding the Python GIL (David Beazley)：<a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">http://www.dabeaz.com/python/UnderstandingGIL.pdf</a></li>
<li>4. python中的GIL详解 (背着吉他的王小可)：<a href="https://www.cnblogs.com/SuKiWX/p/8804974.html">https://www.cnblogs.com/SuKiWX/p/8804974.html</a></li>
<li>5. 聊聊Python中的GIL (青山牧云人)：<a href="https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html">https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html</a></li>
<li>6. Python简史 (Vamei)：<a href="https://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html">https://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gil</tag>
        <tag>GIL</tag>
        <tag>全局解释锁</tag>
        <tag>全局锁</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（零）—— 学习计划</title>
    <url>/2020/05/25/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E9%9B%B6%EF%BC%89%E2%80%94%E2%80%94%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106329590">https://blog.csdn.net/yushuaigee/article/details/106329590</a></p>
</blockquote>
<p>之前看到一张图，把各种编程语言比作不同的工具，非常形象生动。这里把Python比作电锯，简单粗暴，威力巨大，用起来得心应手。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200525220244606.png" alt="20200525220244606.png"></p>
<p>这张图片说明了编程语言只是一种工具，我们要善于根据不同的实际情况选择趁手的工具。但是作为一个Coder，要想达到更高的水平，不仅要把工具用起来得心应手，还要明白工具背后设计的原理。这样我们才能够深入地学习这些编程语言作者们的思想，先不说自己是否能成长为大神，至少可以更好地理解和使用这些编程语言吧。本着“知其然，还要知其所以然”的态度，我决定系统地学习一下Python的源码。</p>
<p>我暂且把学习计划分为三步：第一步，学习Python标准库源码，也就是Python自带模块中那些用纯Python实现的部分，源码文件在Lib目录下，参考这个<a href="https://docs.python.org/zh-cn/3/library/index.html">官方标准库文档</a>。第二步，学习Python内置模块源码和内置类型的实现源码，也就是Python自带模块中那些用C语言实现的部分，源码文件在Modules和Objects目录目录下，参考这个<a href="https://docs.python.org/zh-cn/3/py-modindex.html">官方模块索引</a>。第三步，学习Python解释器的实现源码，源码文件在Python目录下。</p>
<p>本次研究的是CPython的源码，使用当前最新版本Python3.8.3，源码在<a href="https://www.python.org/downloads/source/">这里</a>下载。考虑到自己的水平和时间，如果还没完成我的学习计划，Python就已经发布了新版本，那就换新版本研究吧，反正也不会有太大的区别，总之要紧跟时代潮流，hh。</p>
<p>《<a href="https://blog.csdn.net/yushuaigee/article/details/106329590">彻底弄懂Python标准库源码</a>》系列作为学习计划的第一部分，<strong>首先要明确学习目的和学习目标：通过阅读分析标准库的Python代码，学习Pythonic的风格和习惯，同时熟悉常用库的常用API （有需要的时候不用再百度），并了解一些不常用库的作用（有需要的时候能想到）。</strong></p>
<p>学习Python源码这个计划几个月前就在想了，奈何拖延症发作，希望这个博客系列以后可以做到每月更新一篇！</p>
<p> </p>
<h3 id="Python-源代码主要目录结构"><a href="#Python-源代码主要目录结构" class="headerlink" title="Python 源代码主要目录结构"></a>Python 源代码主要目录结构</h3><ul>
<li>Grammar。EBNF描述的语法规则在这个目录下。</li>
<li>Include。整个解释器所有的头文件放在这个目录下。</li>
<li>Lib。纯Python实现的标准库。</li>
<li>Modules。C实现的标准库。</li>
<li>Objects。所有的内置类型的实现。</li>
<li>Python。Python虚拟机的核心代码。
 </li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol>
<li><a href="https://www.cnblogs.com/pluse/p/8667864.html">Python内置模块与标准库 - impluse</a> </li>
</ol>
<p>2. <a href="https://www.lightxue.com/python-internals-locate-source-code">Python源码寻宝记——地图篇 — 0xFEE1C001</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂python3中的回调函数</title>
    <url>/2019/03/01/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82python3%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86313697">https://blog.csdn.net/yushuaigee/article/details/86313697</a></p>
</blockquote>
<blockquote>
<p><strong>百度百科说：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</strong></p>
</blockquote>
<p><strong>通俗理解就是：把一个函数作为参数传给另一个函数，第一个函数称为回调函数。</strong></p>
<p>这个被传入的参数其实是函数指针，即指向一个函数的指针（地址）。</p>
<p>在python中，指针的概念被淡化，先举个c++的例子：</p>
<blockquote>
<p>  本段引用自  <a href="https://blog.csdn.net/qq_21210467/article/details/80706277">python 回调函数（Callback）——天涯海阁未走远</a><br>  编写一个计算函数computer，对于两个整数进行各种计算（通用的，什么计算都能做）。有一个形参是指向具体算法函数的指针，根据不同的实参函数，用不同的算法进行计算。<br>  编写三个函数：求两个整数的最大值，最小值，和。分别用这三个函数作为实参，测试computer函数。<br>  那么肯定有人会问，一个函数怎么可能做各种计算呢？——这个时候，我们在computer的形参中设置一个函数指针，每次调用的时候传递给它一个函数指针。<br>  用函数名去初始化形参函数指针。这样的话，我们写computer函数的时候就只管说我要调用一个对两个整数做运算的函数，至于要做什么运算，只需要把代表这个运算的函数名传给我，我用函数指针来接收，用函数指针充当函数名，去调用函数体。这就是函数指针的好处，也就是函数回调。 </p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computer</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>(*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &gt; b ? b : a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, res;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入整数a：&quot;</span>; <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入整数b：&quot;</span>; <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">	res = computer(a, b, &amp;max);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	res = computer(a, b, &amp;min);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Min of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	res = computer(a, b, &amp;sum);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190301101204190.png" alt="20190301101204190"></p>
</blockquote>
<p> <strong>现在再说python的情况：</strong></p>
<p>类似上面，编写三个函数：求两个整数的最大值，最小值，和。</p>
<p>分别用这三个函数作为实参，测试computer函数。</p>
<p>在调用max,min,sum时，这三个函数就是此处的回调函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computer</span>(<span class="params">a, b, func</span>):</span></span><br><span class="line">    <span class="keyword">return</span> func(a, b)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [a, b][a &lt; b]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [a, b][a &gt; b]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(a) + <span class="built_in">int</span>(b))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&quot;请输入整数a:&quot;</span>)</span><br><span class="line">    b = <span class="built_in">input</span>(<span class="string">&quot;请输入整数b:&quot;</span>)</span><br><span class="line">    res = computer(a, b, <span class="built_in">max</span>)</span><br><span class="line">    print(<span class="string">&quot;Max of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br><span class="line">    res = computer(a, b, <span class="built_in">min</span>)</span><br><span class="line">    print(<span class="string">&quot;Min of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br><span class="line">    res = computer(a, b, <span class="built_in">sum</span>)</span><br><span class="line">    print(<span class="string">&quot;Sum of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190301105100724.png" alt="20190301105100724.png"></p>
<blockquote>
<p> PS：一开始在测试上面python代码的时候，我没有加类型转换str()和int()，出现了输出 Sum of 5 and 12 is 512 的情况。看来python用起来是方便，但是编译器帮我们做了太多的事情，有时候会让我们忽略一些程序的本质，所以不能光学python啊，c++还是要多看看，有助于对程序本质的理解。 </p>
</blockquote>
<p>说白了，回调函数和普通函数在定义的时候没有什么区别，只有在调用时才看出来是不是回调函数，正常调用就是普通函数，作为一个函数的参数在需要的时候分情况调用，就是回调函数。</p>
<p>另外，回调函数还可以进行异步调用，即非阻塞调用，通常用在多线程或者多进程中。暂时没用到，先了解。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>回调函数</tag>
        <tag>Callback</tag>
      </tags>
  </entry>
  <entry>
    <title>我认识到了记录博客对于工作和学习的重要性</title>
    <url>/2018/12/24/%E6%88%91%E8%AE%A4%E8%AF%86%E5%88%B0%E4%BA%86%E8%AE%B0%E5%BD%95%E5%8D%9A%E5%AE%A2%E5%AF%B9%E4%BA%8E%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/85138684">https://blog.csdn.net/yushuaigee/article/details/85138684</a></p>
</blockquote>
<h3 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a>我为什么要写博客？</h3><p>在学习和工作的过程中，不管是安装软件，还是配置环境，或者写代码的过程中，总会遇到很多问题。常规问题还好，跟着教程按步骤进行就行了。一旦遇到刁钻的问题，或者在教程里没有出现的错误，就很让人头大，而且更令人头疼的是感觉我们遇到的问题大多数都是刁钻的问题，很少有跟着教程一步一步顺利完成的。这时候就只能寄希望于各大搜索引擎了，经过不断更换关键字，废了九牛二虎之力，如果能解决问题，那还是很开心的，如果通过自己尝试解决了问题，那就更开心了。这时候如果能记录一下，以后有其他人遇到这种问题，看到你的博客就能够很快定位并解决。因为平时在别人的博客学到很多东西，许多博主的那种乐于助人的精神令我很佩服，我常常在想：如果自己有机会能将这份“赠人玫瑰，手有余香”的差事传递下去，那也算为这个代码世界里贡献了一份微薄的力量。</p>
<p>上面的原因只是其一，更重要的一个原因是，记录博客可以有利于自己的学习和成长。首先，学习一个新的知识，你感觉自己学会了其实不一定，只有你能给别人讲明白，才算真正掌握了。而写博客的过程，可以看做给别人讲解的过程。在写博客时，对新学习的知识做一个回顾和总结，也可以方便以后自己忘了的时候进行快速查阅。正所谓“学而时习之”。</p>
<h3 id="我为什么现在才开始写博客？"><a href="#我为什么现在才开始写博客？" class="headerlink" title="我为什么现在才开始写博客？"></a>我为什么现在才开始写博客？</h3><p>说来惭愧，我在大学时就知道写博客有很多好处，也曾经听师兄说过坚持写博客是一件很有意义的事。但是由于自己的懒散，导致迟迟也没有开始。我在大四的时候曾经用有道云笔记记录自己学习python的笔记，当做一种回顾，很可惜后来老是感觉只是把人家的东西抄了一遍，从而中途中断了，后来也没有再看过那些笔记。在做毕设的时候，我那个课题是个那年老师新出的题目，遇到一个问题卡住了，当时找遍了各个网站，使用中文英文关键字进行搜索，大概花了一星期时间，终于在一篇英文博客里摘到了一些线索，然后自己尝试了一下搞定了。当时寻找解决办法的过程中就想着，等解决了，一定把解决方案写成一个博客，以方便自己和别人查询。可是搞定了之后离交论文就剩一星期时间了，当然没有立刻实行，然后……，等交完论文，光想着放松，更没有了提笔的动力。这件事不了了之，果不其然，现在毕业仅仅5个月时间，回想一下，只记得是关于AR和MFC的东西，然后记得当时很费劲，根本不记得具体细节。如果当时我能马上记录下来，是多么有意义的事情啊。</p>
<h3 id="为什么现在终于要开始了？"><a href="#为什么现在终于要开始了？" class="headerlink" title="为什么现在终于要开始了？"></a>为什么现在终于要开始了？</h3><p>7月2号参加工作，到现在有差不多6个月了。从一开始接触什么都是新鲜的东西，到现在感觉逐渐适应工作。有时候仔细想想，这看似忙忙碌碌的半年自己真正学到了什么？最大的感受就是，虽然感觉了解到了很多新东西，但是只是了解了一些皮毛而已，而且了解的新事物越多，越感到要学的东西更多，自己真的是一个小小的小菜鸟。看到那些工作一年多的老员工，就已经懂那么多，随便说起一个自己刚刚百度到的东西，他们竟然都能说出一堆关于这个的话题，这让我既佩服又羡慕，同时也反省自己，等我工作一年之后能达到那个水平吗？如果达不到，自己是不是也太弱了？回顾半年来的工作，我竟然不能思路清晰地列出所学到的东西，然后只能得出结论：没学到啥……。半年时间，说长也长，说短也短，人生又有几个半年呢？如果一直这样浑浑噩噩地混下去，没有什么提高，那就要注定过一个得过且过没有意义的人生。</p>
<p>我认识到了记录博客对于工作和学习的重要性。以后每学到一个东西或者解决一个难题，就记录成博客，即使是一条命令的用法，也可以当做笔记记下来，方便以后查阅和总结，同时也能够激励自己，万一有别人看到呢。我希望当我下一个半年，来回顾工作和学习时，可以打开自己的博客，总结一下这一段时间的成果，就不会感觉自己碌碌无为了。真的是想想都感觉美滋滋啊。</p>
<p>这就是我的第一篇博客了，万事开头难，总算开始了~~加油！</p>
<p> </p>
<p> </p>
]]></content>
      <categories>
        <category>感想随笔</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
        <tag>写博客的意义</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解Python中的“指针”</title>
    <url>/2019/09/07/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E2%80%9C%E6%8C%87%E9%92%88%E2%80%9D/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/96745994">https://blog.csdn.net/yushuaigee/article/details/96745994</a></p>
</blockquote>
<p>学过C，C++语言的同学都知道一个重要的概念——指针。</p>
<p>Python中有指针的概念吗？我查了许多资料，没人认明确地说Python中有“指针”这一定义。在我看来，Python中虽然没有“指针”的定义，但是却随处可见“指针”的影子。不过这里的“指针”并不完全等同于c语言中的指针，只能是加引号的“指针”。</p>
<h3 id="两个Python例子引发的思考"><a href="#两个Python例子引发的思考" class="headerlink" title="两个Python例子引发的思考"></a>两个Python例子引发的思考</h3><p>第一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --coding=utf-8--</span></span><br><span class="line"><span class="comment"># 第一个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：将参数发送出去（这里简化为打印）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;send: &#x27;</span>, param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list删掉最后一个元素发送出去，也就是[&#x27;a&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun1...&#x27;</span>)</span><br><span class="line">    param.pop()</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list增加一个元素&#x27;c&#x27;发送出去，也就是[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun2...&#x27;</span>)</span><br><span class="line">    param.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list发送出去，也就是[&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun3...&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    fun1(test_list)</span><br><span class="line">    fun2(test_list)</span><br><span class="line">    fun3(test_list)</span><br></pre></td></tr></table></figure>
<p>我预期的结果为：</p>
<blockquote>
<p>run fun1…<br>send:  [‘a’]<br>run fun2…<br>send:  [‘a’, ‘b’, ‘c’]<br>run fun3…<br>send:  [‘a’, ‘b’] </p>
</blockquote>
<p>实际的结果为：</p>
<blockquote>
<p>run fun1…<br>send:  [‘a’]<br>run fun2…<br>send:  [‘a’, ‘c’]<br>run fun3…<br>send:  [‘a’, ‘c’] </p>
</blockquote>
<p> 按照代码表面来理解，三个函数只是对传进来的“形参” <code>param </code>进行了改变，对原来的“实参”<code>test_list</code>并没有影响，所以每个函数传进去的<code>test_list</code>应该都是<code> [&#39;a&#39;, &#39;b&#39;]</code>。可是从结果来看，每个函数里的“形参”被改变后，外面的“实参”也跟着改变了。在原来的代码基础上加几条打印，可以看到就是这样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun1(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun2(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun3(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>test_list: [‘a’, ‘b’]<br>run fun1…<br>send:  [‘a’]<br>test_list: [‘a’]<br>run fun2…<br>send:  [‘a’, ‘c’]<br>test_list: [‘a’, ‘c’]<br>run fun3…<br>send:  [‘a’, ‘c’]<br>test_list: [‘a’, ‘c’] </p>
</blockquote>
<p>所以上面例子中三个函数里的<code>param</code>和<code>test_list</code>其实是一个对象，fun1里的pop和fun2里的append都是操作的同一个变量(对象)，也就是说传递到三个函数中的参数是<code>test_list</code>的“地址”。类似C语言中，函数的参数为指针类型。</p>
<p> 第二个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --coding=utf-8--</span></span><br><span class="line"><span class="comment"># 第二个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：将参数发送出去（这里简化为打印）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;send: &#x27;</span>, param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value的值加上1发送出去，也就是2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun1...&#x27;</span>)</span><br><span class="line">    param += <span class="number">1</span></span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value的值减去1发送出去，也就是0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun2...&#x27;</span>)</span><br><span class="line">    param -= <span class="number">1</span></span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value发送出去，也就是1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun3...&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_value = <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun1(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun2(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun3(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br></pre></td></tr></table></figure>
<p>实际输出结果：</p>
<blockquote>
<p>run fun1…<br>send:  2<br>run fun2…<br>send:  0<br>run fun3…<br>send:  1 </p>
</blockquote>
<p> 这次的结果和上次不太一样，结果表明三个函数里的<code>param</code>和<code>test_value</code>并不是一个对象，fun1里的加1和<strong>fun2</strong>里的减1操作之后，并没有影响<code>test_value</code>的值，也就是说传递到三个函数中的参数是<code>test_list</code>的“值”(的拷贝)。那么什么时候传的是指针，什么时候传的是值呢？其实只要了解一下Python中创建对象的具体过程，问题就迎刃而解了。</p>
<h3 id="Python中的不可变对象和可变对象"><a href="#Python中的不可变对象和可变对象" class="headerlink" title="Python中的不可变对象和可变对象"></a>Python中的不可变对象和可变对象</h3><p>众所周知，Python中一切皆对象，每个对象至少包含三个数据：引用计数、类型和值。引用计数用于Python的GC机制，类型用于在CPython层运行时保证类型安全性，值就是对象关联的实际值。</p>
<p>Python对象分为不可变对象和可变对象。可变对象可以修改，上面第一个例子中的test_list（list类型）就属于可变对象，不可变对象无法更改，类似C语言中加了const修饰，上面第二个例子中的test_value（int类型）就属于不可变对象。</p>
<p><strong>不可变对象：int(整形)、str(字符串)、float(浮点型)、tuple(元组)</strong></p>
<p><strong>可变对象：dict(字典)、list(列表)、 set(集合）</strong></p>
<p>        <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2019090622412710.png" alt="2019090622412710.png"></p>
<p>这里 x += 1 看似更改了 x 的值，实际上已经改变了ID，所以是新建了一个值。 </p>
<p>        <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2019090622470785.png" alt="2019090622470785.png"></p>
<p>同样str类型的v可以重新赋值，但是不能更改元素。这就类似于C语言中加了const修饰的数组，不能更改它的内容，但是你可以将原来指向它指针改为指向别人。</p>
<p>可变对象的情形就不一样了，可以任意更改元素。ID不会变，直到重新赋值：</p>
<p>         <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190906225303542.png" alt="20190906225303542.png"></p>
<h3 id="C语言中定义变量的过程"><a href="#C语言中定义变量的过程" class="headerlink" title="C语言中定义变量的过程"></a>C语言中定义变量的过程</h3><blockquote>
<p> 例如：<strong>int x = 2337;</strong> </p>
</blockquote>
<p>在C语言中，这行代码的执行分为三步：</p>
<p><strong>1. 为整数分配足够的内存</strong></p>
<p><strong>2. 将值2337分配给该内存位置</strong></p>
<p><strong>3. 将x指向该值</strong></p>
<p>简化的内存视图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/zZTgyLnBuZ.png" alt="zZTgyLnBuZ.png"></p>
<blockquote>
<p> 如果将x重新赋值：<strong>x = 2338;</strong> </p>
</blockquote>
<p>上面的代码为变量 x 重新分配了一个新值2338，从而<strong>覆盖</strong>了以前的值2337。这意味着在这里变量 x 是<strong>可变的</strong>。更新简化的内存视图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/mNzE4LnBuZ.png" alt="mNzE4LnBuZ.png"></p>
<p>x 的地址并没有变，<strong>这意味着在C语言中定义变量时, x 它代表的是一个内存位置</strong>，可以理解为一个空盒子，而关键字 int 就确定了这个盒子的大小，我们可以将值2337放进这个盒子，也可以将2338放进这个盒子，因为它们是 int 型的值。</p>
<blockquote>
<p> 此时再引入一个新的变量：<strong>int y = x;</strong> </p>
</blockquote>
<p> 这时会创建一个新的 int 型的盒子 y ，再把 x 中的值赋值过来。在内存中是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/hZjRkLnBuZ.png" alt="hZjRkLnBuZ.png"></p>
<p>两个变量除了值都是 2338 之外，其他并没有任何关系。任意更改其中一个变量的值，另一个不会受到任何影响。</p>
<blockquote>
<p> 例如更改 y 的值为 2339：<strong>y = 2339;</strong> </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/mYWFiLnBuZ.png" alt="mYWFiLnBuZ.png"></p>
<h3 id="Python中定义对象的过程"><a href="#Python中定义对象的过程" class="headerlink" title="Python中定义对象的过程"></a>Python中定义对象的过程</h3><p>再看一下同样的代码，在Python中运行的情况。严格上来讲Python中的变量和C中的变量的意义不是等价的，Python中的变量或许叫做“名称”会更加贴切一点，看了下面的分析就会有所体会。</p>
<blockquote>
<p>  定义一个变量 x：<strong>x = 2337</strong> </p>
</blockquote>
<p>与C类似，上面的代码在执行过程中会分解为5步：</p>
<p><strong>1. 创建一个PyObject</strong></p>
<p><strong>2. 将PyObject的类型设置为整数型</strong></p>
<p><strong>3. 将PyObject的值设置为2337</strong></p>
<p><strong>4.创建一个变量（名称）x</strong></p>
<p><strong>5.将 x 指向新建的PyObject</strong></p>
<p><strong>6.将该PyObject的引用计数加 1</strong></p>
<p>简化的内存视图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/NWJjOS5wbm.png" alt="NWJjOS5wbm.png"></p>
<blockquote>
<p>  如果将x重新赋值：<strong>x = 2338</strong> </p>
</blockquote>
<p> 上面这行代码在Python中的执行过程和在C中有很大不同，具体过程是这样：</p>
<p><strong>1. 创建一个新的PyObject</strong></p>
<p><strong>2. 将PyObject的类型设置为整数型</strong></p>
<p><strong>3. 将PyObject的值设置为2338</strong></p>
<p><strong>4.将 x 指向新的PyObject</strong></p>
<p><strong>5.将新的PyObject的引用计数加 1</strong></p>
<p><strong>6.将旧的PyObject的引用计数减 1</strong></p>
<p>内存中的情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/MzQzMi5wbm.png" alt="MzQzMi5wbm.png"></p>
<p>引用计数位为0的原对象，将会被Python的内存管理机制销毁。这说明 x 它不是一个空盒子。</p>
<blockquote>
<p> 如果是这样呢：<strong>y = x</strong>  </p>
</blockquote>
<p> 在内存中会新建一个新名称（变量），但不用创建一个新对象，原来对象的引用计数变成了 2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/zYmY2LnBuZ.png" alt="zYmY2LnBuZ.png"></p>
<p> 现在 x 和 y 都指向同一个对象，但是他们还是不可改变对象。</p>
<blockquote>
<p> 比如如果执行： <strong>y += 1</strong> </p>
</blockquote>
<p> 这和执行 y = 2339 的过程是一样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/NWExNS5wbm.png" alt="NWExNS5wbm.png"></p>
<p> 这样看来，我们在Python中不是新建变量，而是新建名称并绑定到变量，所以说Python中的变量和C中的变量的意义不是等价的。当然这只是不可变对象的情况，如果 x, y 是 list 这种类型可变对象，上面的代码改为：</p>
<blockquote>
<p> <strong>x = [1]</strong>              # 新建一个 PyObject1 ,名称为x，值为 [1] ,引用计数为 1<br> <strong>x = [2]</strong>              # 新建一个 PyObject2 ,名称x指向 PyObject2 ,值为 [2],引用计数为1, PyObject1 引用计数为0(回收)<br> <strong>y = x</strong>                # 新建一个名称y,指向 PyObject2，值为 [2] ,引用计数改为 2<br> <strong>y.append(3)</strong>  # PyObject2 的值改为 [2,3],名称x和y依然都指向 PyObject2,引用计数还是2 </p>
</blockquote>
<p>前三行代码执行时，内存情况和不可变对象是一样的，但是最后一行执行时，将不会新建一个新的对象，因为 list 是可变对象，它可以对象的值改成[2,3] , id还是原来的id（其实这里的id和C语言中的地址也不是完全等价的，只是类似）。这就是Python中可变对象和不可变对象的不同之处。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，由Python中的两个例子产生Python中是否像C语言一样也有指针的疑惑，研究了Python中可变对象和不可变对象的区别，接着对比C语言和Python在创建变量时的不同。我以前总是想把Python和C语言联系起来，总是想将C语言中已有的定义和用法套用在Python上，这样虽然方便理解，但是也会产生许多困惑。随着对Python的底层探究地越来越多，我越来越发现Python中有许多新的东西，不能将它们简单地等价于C语言中已有的术语。</p>
<p>回到最开始的问题，Python中有“指针”吗？我的理解是，如果此处的指针是指C语言中的指针，那么答案是没有，如果这里的指针指的是C语言中的指针思想，那么答案是有。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul>
<li>Pointers in Python: What’s the Point? (Logan Jones) :<a href="https://realpython.com/pointers-in-python/#real-pointers-with-ctypes">https://realpython.com/pointers-in-python/#real-pointers-with-ctypes</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python指针</tag>
        <tag>可变对象</tag>
        <tag>Python</tag>
        <tag>python原理</tag>
        <tag>不可变对象</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式初探——六大设计原则</title>
    <url>/2020/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/104543281">https://blog.csdn.net/yushuaigee/article/details/104543281</a></p>
</blockquote>
<p>最近看了两本关于设计模式的书，在此记录一下感想。</p>
<p>第一次听说设计模式是在网上查询MVC模式的时候，顺便搜了一下设计模式，才了解到武林中存在着“23种设计模式”这么个东西。当时以为觉得设计模式就是倚天剑、屠龙刀，一个代码写的很烂的菜鸟看了设计模式就会成为“武林至尊”，代码水平立刻变得很厉害。学习了之后才知道我想错了，设计模式只是倚天剑和屠龙刀中的“九阴真经”，就算得到了还是要苦苦练习，结合实际的编程和项目才能够把其中的思想融会贯通，真正成为一个编程高手。</p>
<p>“设计模式”是一套被反复利用、被多数人知晓的、被无数工程师实践的代码设计经验的总结。因为它比较抽象，没有一定编程经验很难读懂，更不能理解其精髓。23种设计模式总体看下来，有的当时就能理解，有的需要思考一番才能理解，就像以前不会的很难的那种数学题，看了答案，跟着答案的思路捋一捋就理解了，然后下次遇到类似的题稍微变一变又不会做了。这次初探设计模式也是一样，合上书之后自己写代码，很难想到该怎么将刚学到的设计模式用到自己代码中去，或许这就是经验太少的原因吧。</p>
<p>我最大的感受就是<strong>单一职责原则、开放封闭原则、依赖倒转原则、里氏代换原则、迪米特法则、接口隔离原则</strong>这六大设计原则比设计模式更加重要，如果说设计模式是面向对象编程的编程思想，那么设计原则就是这些编程思想的指导总纲，而这六大设计原则的目的又可以概括为六个字，就是<strong>“高内聚，低耦合”</strong>。（感觉看完书我就记住了这六个字）高内聚就是说，设计的接口内部功能要单一紧凑，不要想起什么都往里面塞，最后搞的非常臃肿，没有办法复用。然后低耦合是说，设计的接口之间的关联要尽量小，不要出现更改一个地方的时候牵一发而动全身，几十个地方都要跟着改，要不就没法用。说起来我们学习设计模式的最终目的就是要实现代码的最大化复用。</p>
<p>单一职责原则：一个类只负责一项功能或相似的功能，承担尽可能少的职责。这样可以增强可读性，方便维护和修改，当然缺点就是在小的项目里运用会显得拆分的太详细，类的数量会急剧增加。（然后就想着反正是小项目没必要考虑单一职责原则，然后后后来项目的功能越加越多，又变成了又臭又长的烂代码。。。）</p>
<p>开放封闭原则：类、模块、函数等对扩展开放，对修改封闭。增加一个功能时，应当尽可能的不去改动已有的代码，当修改一个模块时不应该影响到其他模块。（这个相信大家不能同意更多，因为谁也不想让原来跑的好好的代码经过自己的手之后，出现各种奇怪的问题，所以不会去想动以前的代码。问题是根据我的经验，由于“已有”的代码在设计的时候没有考虑“低耦合”，导致改动的时候牵一发而动全身，不得不去动已有的代码。。。）</p>
<p>里氏替换原则：所有能引用基类的地方必须能透明地使用其子类的对象。只要父类能出现的地方，就可以用子类来替换它，反之，子类能出现地方父类不一定能出现，因为子类拥有父类的所有属性和行为，但是子类拓展了更多的功能。子类重写父类方法的时候功能不能改动太多，功能实在差很多的话就不要重写了，应扩展一个新方法，这一点我做的很不好。</p>
<p>依赖倒置原则：高层模块不应该依赖低层模块，二者应该依赖其抽象。把具有相同特征或相似功能的类，抽象成接口或者抽象类，让具体的实现类继承这个抽象类。抽象类（接口）负责定义统一的方法，实现类负责具体功能的实现。</p>
<p>接口隔离原则：用多个细粒度的接口来代替由多个方法组成的复杂接口，每一个接口服务于一个子模块，不要试图建立一个很庞大的接口供所有依赖它的类调用。这其实还是强调“高内聚”的事儿。</p>
<p>迪米特原则：一个对象应该对其他对象有最少的了解。对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。这其实还是强调“低耦合”的事儿。</p>
<p>设计模式在编程中的作用，就像《孙子兵法》在战争中的作用。设计模式是前辈们归纳总结出来的指导思想，对设计模式的运用不能纸上谈兵，丰富的项目经验是很重要的。不同的阶段来看看这些理论，会有不同的收获。这次只是初探，随着以后的代码写的越来越多，还要随时注意学习和运用这些设计模式。</p>
]]></content>
      <categories>
        <category>感想随笔</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(一)——本地搭建hexo框架</title>
    <url>/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第一篇，其他文章链接：</p>
<ol>
<li><strong>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></strong></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>本文思路：使用 Hexo 框架搭建网站，发布到 GitHub pages 或者 Gitee pages .</p>
<p>首先先看一下最终效果：</p>
<p>GitHub pages 链接(国际站点)：<a href="https://yushuaige.github.io/">杰克小麻雀的博客</a><br>Gitee pages 链接(国内站点)：<a href="https://yushuaigee.gitee.io/">杰克小麻雀的博客</a></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/myblog.gif" alt="myblog"></p>
<hr>
<h2 id="一、Hexo-框架简介"><a href="#一、Hexo-框架简介" class="headerlink" title="一、Hexo 框架简介"></a>一、Hexo 框架简介</h2><p>首先，都 0202 年了，我们想搭建一个网站，当然不用自己从头开始写 html，因为有许多开源的代码可以供我们选择。Hexo 就是一个专门用于博客类网站的开源项目，使用 Node.js 语言开发，GitHub 上目前已经有 31.8k 的 star 了，现在网上大多数的个人博客都是使用这个框架搭建的。Hexo不仅搭建过程简单快捷，配置灵活，可定制型非常高，因此众多大佬开发者为它开发了丰富的主题库，而作为菜鸟我们只需要选择一个符合自己审美的主题直接用就行了，当然如果你懂前端和 js ，也可以自己修改定制，或者自己制作主题并分享到互联网上。</p>
<p> Hexo 中文官网：<a href="https://hexo.io/zh-cn/">hexo.io</a> ，GitHub 地址：<a href="https://github.com/hexojs/hexo">hexojs/hexo</a> 。</p>
<h2 id="二、Hexo-依赖环境安装-：Node-js"><a href="#二、Hexo-依赖环境安装-：Node-js" class="headerlink" title="二、Hexo 依赖环境安装 ：Node.js"></a>二、Hexo 依赖环境安装 ：Node.js</h2><p>Hexo 是使用 Node.js 开发的，所以我们安装 Hexo 之前需要先安装 Node.js 环境。</p>
<p>Node.js 是什么？简单的说 Node.js 就是运行在服务端的 JavaScript 。安装了 Node.js 环境，就可以不用依赖浏览器就可以运行 js 代码，其实它也是基于 Chrome 引擎开发的一个开源项目。简单理解， Node.js 对于 js 代码的作用类似 Python 解释器对于 Python 代码的作用。</p>
<p>这里注意，不是说博客框架必须用 Node.js 来开发，博客框架本质上是一个网站，可以用任何语言开发，也有用 Python 的 Flask/Django 或者 Java 开发的博客框架，只是没有 Hexo 这么流行。</p>
<h3 id="1-官网下载-Node-js"><a href="#1-官网下载-Node-js" class="headerlink" title="1. 官网下载  Node.js"></a>1. 官网下载  Node.js</h3><p>Node.js 中文官网：<a href="https://nodejs.org/zh-cn/">nodejs.org</a></p>
<p>打开官网直接下载安装包就行了，左边是稳定版，右边是尝鲜版。任选一个点击下载，尝鲜版包含了比较新的特性，但是没有经过充分测试。我这里下载了 15.4.0 版本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220164653416.png" alt="image-20201220164653416"></p>
<p>我这里是用浏览器自带下载器，下载速度还可以，如果没速度可以在下载按钮上右键，选择“复制链接地址”，然后粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220165109254.png" alt="image-20201220165109254"></p>
<h3 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2. 安装  Node.js"></a>2. 安装  Node.js</h3><p>下载完安装包后双击打开，一路点 Next 就行了。注意这一步是安装额外工具，没必要勾选。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220165451877.png" alt="image-20201220165451877"></p>
<h3 id="3-测试-Node-js-是否安装成功"><a href="#3-测试-Node-js-是否安装成功" class="headerlink" title="3. 测试 Node.js 是否安装成功"></a>3. 测试 Node.js 是否安装成功</h3><p>安装完成后，<kbd>Win</kbd> + <kbd>R</kbd> 打开运行框，输入<code>cmd</code>打开命令行窗口，输入<code>npm -v</code>回车，如果出现版本号说明安装成功。就跟安装完 Python 解释器一样，npm 就类似 Python 中的 pip 工具。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220170553434.png" alt="image-20201220170553434"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220180008301.png" alt="image-20201220180008301"></p>
<h2 id="三、Hexo-依赖环境安装-：Git"><a href="#三、Hexo-依赖环境安装-：Git" class="headerlink" title="三、Hexo 依赖环境安装 ：Git"></a>三、Hexo 依赖环境安装 ：Git</h2><p>作为程序员，Git 应该不陌生，如果你已经安装了 Git，那这一步可以跳过。</p>
<p>Git（读音/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。简单理解就是下载代码的工具，因为 Hexo 是一个托管于 GitHub 上的开源项目，所以安装 Hexo 的时候需要使用 Git 来下载源码和依赖代码，而且后面要将自己的博客发布到 GitHub pages 或者 Gitee pages 上面也需要使用 Git。</p>
<h3 id="1-官网下载-Git"><a href="#1-官网下载-Git" class="headerlink" title="1. 官网下载  Git"></a>1. 官网下载  Git</h3><p>Git 官网：<a href="https://git-scm.com/">git</a></p>
<p>打开官网直接下载安装包就行了。由于网络环境原因，浏览器下载可能会非常慢，可以按照上面的方法，在下载按钮上右键，选择“复制链接地址”，然后粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220171653488.png" alt="image-20201220171653488"></p>
<h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装  Git"></a>2. 安装  Git</h3><p>下载完安装包后双击打开，没有特殊需要的话，一路点 Next 就行了。安装完毕，在桌面空白处右键，可以看到多了两个选项。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220172655709.png" alt="image-20201220172655709"></p>
<h3 id="3-测试-Git-是否安装成功"><a href="#3-测试-Git-是否安装成功" class="headerlink" title="3.  测试 Git 是否安装成功"></a>3.  测试 Git 是否安装成功</h3><p>Git 安装完成后，自带了一个命令行窗口，通过上面新增的右键菜单<kbd>Git Bash Here</kbd>就可以打开，比 Windows自带的命令行要好用，后面都使用这个命令行窗口。在桌面空白处右键，选择<kbd>Git Bash Here</kbd>，输入<code>git --version</code>回车，如果出现版本号说明安装成功</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220175806607.png" alt="image-20201220175806607"></p>
<h2 id="四、安装-Hexo"><a href="#四、安装-Hexo" class="headerlink" title="四、安装 Hexo"></a>四、安装 Hexo</h2><p>下面开始正式安装 Hexo，有了前面的准备工作，安装 Hexo 就非常简单了，就跟使用 pip 安装一个 Python 第三方库一样方便。</p>
<h3 id="1-本地安装-hexo"><a href="#1-本地安装-hexo" class="headerlink" title="1. 本地安装 hexo"></a>1. 本地安装 hexo</h3><p>首先在本地新建一个空文件夹，用来存放 Hexo 的文件和以后要写的博客文件，注意不要有中文路径，避免可能出现的问题。我这里建立在 D 盘根目录，取名 MyBlog。</p>
<p>进入新建的文件夹，右键，选择<kbd>Git Bash Here</kbd>，依次输入下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 框架</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 依赖包</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>命令很好理解，第一行安装 hexo 模块，<code>-g</code>表示安装全局模块；第二行是 hexo 初始化，会用 <code>git clone</code>命令去 GitHub 下载一个 hexo 默认模板代码库；第三行是安装依赖包，类似安装 pip 的 requirement 文件，会根据刚下载的代码库中的配置文件，下载并安装所需依赖包。安装成功结果，如下图。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220175707251.png" alt="image-20201220175707251"></p>
<h3 id="2-可能遇到的问题"><a href="#2-可能遇到的问题" class="headerlink" title="2. 可能遇到的问题"></a>2. 可能遇到的问题</h3><ul>
<li><p><strong><code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上</strong></p>
<p>可能是 npm 源速度太慢，可以尝试修改淘宝源解决，再重新执行安装命令。npm 源的概念就和 Python 中的 pip 源一样，默认源是<code>https://registry.npmjs.org/</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 npm 源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 临时修改 npm 源安装 hexo (仅本条命令有效)</span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者永久修改 npm 源</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>如果是公司内网使用代理访问外网 (比如<code>ping registry.npmjs.org</code> <code>ping registry.npm.taobao.org</code>都不通)，可以尝试给 npm 配置代理解决，再重新执行安装命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line">npm config set proxy http://serverip:port</span><br><span class="line">npm confit set https-proxy http:/serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置带用户名密码的代理</span></span><br><span class="line">npm config set proxy http://username:password@serverip:port</span><br><span class="line">npm confit set https-proxy http://username:password@serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>hexo init</code>命令执行卡住，或者报错连接不上</strong></p>
<p>如果是公司内网使用代理访问外网 (比如<code>ping GitHub.com</code> 不通)，可以尝试给 git 配置代理解决，再重新执行初始化命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line">git config --global http.proxy http://serverip:port</span><br><span class="line">git config --global https.proxy http:/serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置带用户名密码的代理</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：如果密码中带了特殊字符需要进行转义, 将特殊字符替换为下面对应的转义字符即可</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  !   <span class="comment">#   $   &amp;   &#x27;   (    )  *   +   ,   /   :   ;   =   ?   @   [   ]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %21 %23 %24 %26 %27 %28 %29 %2A %2B %2C %2F %3A %3B %3D %3F %40 %5B %5D</span></span><br><span class="line">npm config set proxy http://username:password@serverip:port</span><br><span class="line">npm confit set https-proxy http://username:password@serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h3 id="3-本地博客效果"><a href="#3-本地博客效果" class="headerlink" title="3. 本地博客效果"></a>3. 本地博客效果</h3></li>
</ul>
<p>前面三条命令执行成功，Hexo 框架在本地就已经搭建好了，下面看看效果。</p>
<p>还是在<kbd>Git Bash</kbd>命令行窗口里，依次执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成静态网站</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>或者直接执行<code>hexo g &amp;&amp; hexo s</code>，其中<code>hexo g</code>是 <code>hexo generate</code>命令的简写，<code>hexo s</code>是 <code>hexo server</code>命令的简写。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204316929.png" alt="image-20201220204316929"></p>
<p>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们 Hexo 搭建的博客示例了。此时是默认主题，比较简洁，下一步我们换一个更精美的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="image-20201220204625063"></p>
<h2 id="五、更换-Hexo-博客主题"><a href="#五、更换-Hexo-博客主题" class="headerlink" title="五、更换 Hexo  博客主题"></a>五、更换 Hexo  博客主题</h2><h3 id="1-如何找主题"><a href="#1-如何找主题" class="headerlink" title="1. 如何找主题"></a>1. 如何找主题</h3><p>默认主题非常简洁，适合大佬使用，像我等菜鸟，自己不会做却又想使用花里胡哨的主题，就要学会找主题了。</p>
<p>下面是我寻找主题的三个方法。</p>
<ul>
<li><p><strong>官方网站</strong></p>
<p>Hexo 官网收录了几百个第三方主题，其中有许多中文开发者开发的主题。</p>
<p>在 Hexo 官网点击“主题”，或者直接进入 Hexo 主题页：<a href="https://hexo.io/themes/">themes</a></p>
<p>通过上方的搜索框可以根据标签搜索。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231238616.png" alt="image-20201222231238616"></p>
</li>
<li><p><strong>Github 搜索</strong></p>
<p>大多数流行的主题都在 GitHub 托管开源了，我们可以直接去 GitHub  下载。</p>
<p>在 Github 官网搜索<code>hexo-theme</code>，选择<code>All GitHub</code>，或者直接进入搜索页：<a href="https://github.com/search?q=hexo-theme">search?q=hexo-theme</a></p>
<p>点击右上角<code>Sort</code>可以选择按<code>Most stars</code>数量排序，根据流行程度找到心仪的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231133883.png" alt="image-20201222231133883"></p>
</li>
<li><p><strong>网上搜索</strong></p>
<p>直接在搜索引擎搜索<code>Hexo主题推荐</code>，会有许多别人推荐的主题，不过大多数的推荐前面两种方法都能覆盖到，偶尔也能发现一些冷门却又戳中你的审美的宝藏，这就看耐心和运气了。</p>
</li>
</ul>
<h3 id="2-主题推荐"><a href="#2-主题推荐" class="headerlink" title="2. 主题推荐"></a>2. 主题推荐</h3><p>我挑选了几个自己觉得简单美观而又不过分花哨的主题，其实都是 GitHub 热门的，很好发现。这些主题都太漂亮了，以至于我都不知道该选哪个，额。</p>
<p>下面几个主题切换时可能会遇到一些问题，多数是依赖包未安装完整的原因，解决办法见<code>4. 出错解决办法</code>。</p>
<ul>
<li><p><strong>Next</strong></p>
<p>Demo 示例：<a href="https://theme-next.js.org/">NexT</a> | <a href="https://dandyxu.me/">Dandy</a> | <a href="https://raincal.com/">Raincal</a> </p>
<p>GitHub 主页：<a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a></p>
<p>这个是 Hexo 最流行的主题，GitHub 上 15.5k stars，在 Hexo 主题中排行第一。</p>
<p>这个主题跟默认主题一样简洁，但是却漂亮了很多，尤其是文章浏览界面，排版非常干净舒服，大佬必备。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221224929253.png" alt="image-20201221224929253"></p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221222603632.png" alt="image-20201221222603632"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>stun</strong></p>
<p>Demo 示例：<a href="https://liuyib.github.io/">Liuyib’s Blog</a></p>
<p>GitHub 主页：<a href="https://github.com/liuyib/hexo-theme-stun">hexo-theme-stun</a></p>
<p>这是一个漂亮、简洁的 Hexo 主题，增加了首页图片，和白天黑夜模式，最重要的是文章浏览界面非常干净美观。我就是看到一篇博客使用的这个主题，特别漂亮，才有了想自己搭博客的强烈愿望。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608904463540.gif" alt="test"></p>
<hr>
<p>文章浏览界面：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608904209387.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>matery</strong></p>
<p>Demo 示例：<a href="http://blinkfox.com/">闪烁之狐</a></p>
<p>GitHub 主页：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></p>
<p>同样是一个很漂亮的主题，除了首页的图片，它会为每一篇文章添加一张非常漂亮的封面图，而且集成了很多强大的功能插件，比喻词云，访问统计，音乐播放，视频播放，在线聊天等等。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608995730975.gif" alt="test"></p>
<hr>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608995969178.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>butterfly</strong></p>
<p>Demo 示例： <a href="https://butterfly.js.org/">Butterfly</a> |  <a href="https://jerryc.me/">JerryC</a></p>
<p>GitHub 主页：<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p>
<p>这个主题和上面这个同样强大、漂亮，且色彩更加丰富。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201226233544278.png" alt="image-20201226233544278"></p>
<hr>
<p>![Butterfly - A Simple and Card UI Design theme for ](<a href="https://yushuaigee.gitee.io/myblog/img/Butterfly">https://yushuaigee.gitee.io/myblog/img/Butterfly</a> - A Simple and Card UI Design theme for .png)</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608997237304.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>ayer</strong></p>
<p>Demo 示例：<a href="https://shen-yu.gitee.io/">岛</a></p>
<p>GitHub 主页：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-ayer</a></p>
<p>这个主题在这几个里面算是最小众的，但是功能却不少，界面比较简洁，我就选择了这一款主题。</p>
<hr>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608998694257.gif" alt="test"></p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608998820660.gif" alt="test"></p>
<hr>
</li>
</ul>
<h3 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h3><p>以 <strong>ayer</strong> 主题为例。</p>
<p>在 Hexo 博客根目录(<code>D:\MyBlog</code>)下，右键，选择<code>Git Bash Here</code>，执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载主题仓库到 themes 文件夹， git <span class="built_in">clone</span> &lt;仓库地址&gt; themes/&lt;主题名&gt;</span> </span><br><span class="line">git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>
<p>其中，&lt;仓库地址&gt;可以在每个主题的 GitHub 主页获取到。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231736247.png" alt="image-20201222231736247"></p>
<p>此时打开博客根目录下的 themes 文件夹可以看到多了个 ayer 文件夹。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231910652.png" alt="image-20201222231910652"></p>
<p>然后用记事本打开博客根目录下的 _config.yml (<code>D:\MyBlog\_config.yml</code>)，找到<code>theme</code>标签，默认值是<code>landscape</code>主题，把它改为要更换的主题名字<code>ayer</code>，然后执行启动命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理 &amp;&amp; 生成 &amp;&amp; 启动</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222232806309.png" alt="image-20201222232806309"></p>
<p>此时再到浏览器打开网址<code>http://localhost:4000</code>，可以看到我们的博客已经换上一款非常精美的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/Hexo-1608650994521.png" alt="Hexo"></p>
<h3 id="4-出错解决办法"><a href="#4-出错解决办法" class="headerlink" title="4. 出错解决办法"></a>4. 出错解决办法</h3><ul>
<li><p><strong>Next</strong></p>
<p>打开网页<code>http://localhost:4000</code>出现下面的错误，是因为没有安装依赖库<code>hexo-renderer-swig</code></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221221407462.png" alt="image-20201221221407462"></p>
<p>先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止，执行下面命令安装swig，再执行<code>hexo g &amp;&amp; hexo s</code>重新发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure></li>
<li><p><strong>stun</strong></p>
<p>打开网页<code>http://localhost:4000</code>出现下面的错误，是因为没有安装依赖库<code>hexo-renderer-pug</code></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221223418827.png" alt="image-20201221223418827"></p>
<p>先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止，执行下面命令安装pug，再执行<code>hexo g &amp;&amp; hexo s</code>重新发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug</span><br></pre></td></tr></table></figure>
<h3 id="5-修改主题"><a href="#5-修改主题" class="headerlink" title="5. 修改主题"></a>5. 修改主题</h3></li>
</ul>
<p>更换主题后，我们需要修改一些基本属性，比如博客名字、首页图片等，或者增加一些个性化属性，比如鼠标指针样式，雪花特效，点击特效等。本篇文章先介绍一下如何修改基本属性，以便于接下来发布网站，在本系列文章第七篇再介绍高级的个性化设置。</p>
<p>Hexo 的配置大部分都保存在博客根目录下的<code>_config.yml</code>文件，我这里是<code>D:\MyBlog\_config.yml</code>，我们叫它<code>根目录配置文件</code>，直接修改这个文件就可以更改博客的一些设置，像前面更换主题就是修改这个文件的参数实现的。关于这个文件的每个参数的详细意义，可以在 <a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>里查看，每一个参数都有示例，讲解的非常详细。</p>
<p>此外，下载的第三方主题的根目录下也有一个<code>_config.yml</code>文件，比如 <strong>ayer</strong> 主题，我这里就是<code>D:\MyBlog\themes\ayer\_config.yml</code>文件，我们叫它<code>主题配置文件</code>。关于这个文件每个参数的详细意义，可以在每个主题的 GitHub 主页看到详细说明。</p>
<p>如果你使用的是自带的默认主题，那么所有配置都应该在<code>根目录配置文件</code>修改。如果是用的是第三方那个主题，需要两个文件配合修改。</p>
<p>以 <strong>ayer</strong> 主题为例。</p>
<p>首先，按上面第3步更换主题的方法，将<code>根目录配置文件</code>的 theme 属性设置为对应的主题名字 <code>ayer</code>。打开<code>根目录配置文件</code>(D:\MyBlog_config.yml)。</p>
<p>修改第6/10/11行，修改博客基本信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客标题，冒号后面自定义</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">节日美食</span></span><br><span class="line"><span class="comment"># 博客作者，冒号后面自定义</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">杰克小麻雀</span></span><br><span class="line"><span class="comment"># 网站语言，zh-CN 表示中文，en表示英文。不改成 zh-CN，某些浏览器总会提示是否需要翻译网页</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>然后，参考 <strong>ayer</strong> 主题官方帮助文档 <a href="https://shen-yu.gitee.io/2019/ayer/">Ayer中文说明</a>。打开 <strong>ayer</strong> 主题的<code>主题配置文件</code>(D:\MyBlog\themes\ayer_config.yml)。</p>
<p>修改第 2 ~ 10行，关掉不需要的侧边栏。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line"><span class="comment">#  旅行: /tags/旅行/</span></span><br><span class="line"><span class="comment">#  摄影: http://shenyu-vip.lofter.com</span></span><br><span class="line"><span class="comment">#  友链: /friends</span></span><br><span class="line">  <span class="string">关于我:</span> <span class="string">/2019/about</span></span><br></pre></td></tr></table></figure>
<p>修改第 14 ~ 18行，自定义首页滚动显示的标题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启动效</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">欢迎来到杰克小麻雀的博客</span></span><br><span class="line">  <span class="attr">text2:</span> <span class="string">临渊羡鱼，不如退而结网</span> </span><br><span class="line">  <span class="attr">text3:</span> <span class="string">问渠哪得清如许,为有源头活水来</span></span><br></pre></td></tr></table></figure>
<p>修改第 26 ~ 27行，修改网站图标和侧边栏logo。只需要把自己的图标文件按覆盖原来的文件，完整目录为<code>‪D:\MyBlog\themes\ayer\source\favicon.ico</code>。关于图标，推荐一个可以下载各种尺寸图标的网站： <a href="https://www.easyicon.net/">easyicon</a>，也可以把自己准备好的图片进行在线格式转换： <a href="https://convertio.co/zh/ico-converter/">在线ico转换</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浏览器标签栏显示图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span> </span><br><span class="line"><span class="comment"># 首页侧边栏图标</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure>
<p>修改第 31 ~ 34行，更换封面为自己的图片。先将自己准备好的封面图片 <code>cover8.jpg</code> 放到<code>D:\MyBlog\themes\ayer\source\images</code>目录下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/images/cover8.jpg</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>第 125 行，关闭右上角的 GitHub forkme。在这个背景下有点丑。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github:</span></span><br><span class="line">  <span class="comment"># (关闭请设置为false)</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/Shen-Yu/hexo-theme-ayer</span></span><br></pre></td></tr></table></figure>
<p>第 83 行，关闭打赏。如果不改下面的图片，你的打赏就直接给主题作者了哦，我没有改打赏图片，所以直接关了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reward_type: 0</span><br></pre></td></tr></table></figure>
<p>以上只修改了一些最最基本的配置，毕竟先发布网站要紧，其他配置可以慢慢来，建议看一下主题配置文件的每一行注释以及官方文档。</p>
<p>改完后，执行<code>hexo g &amp;&amp; hexo s</code>，刷新网页看下效果：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227192058171.png" alt="image-20201227192058171"></p>
<h2 id="六、本地发布文章"><a href="#六、本地发布文章" class="headerlink" title="六、本地发布文章"></a>六、本地发布文章</h2><p>博客搭建好了，可是现在只有示例的<code>Hello World</code>一篇文章，怎么发布自己的文章呢？</p>
<h3 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h3><p>在博客根目录下右键，选择<kbd>Git Bash Here</kbd>，输入下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;我的第一篇博客&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227193541930.png" alt="image-20201227193541930"></p>
<p>此时进入博客根目录下的<code>source\_posts</code>(D:\MyBlog\source_posts)文件夹，可以看到多了一个<code>我的第一篇博客.md</code>文件，这便是新生成的博客文章，因为 Hexo 默认使用 Markdown 格式，所以文件后缀是md，可以使用记事本或者<code>Typora</code>打开并编辑。关于 Markdown 语法和<code>Typora</code>软件的使用，将在本系列文章第四篇中介绍。</p>
<p>此时先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止服务器，执行<code>hexo g &amp;&amp; hexo s</code>重新部署，刷新<code>http://localhost:4000/</code>，可以看到博客上多了一篇文章。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227195815659.png" alt="image-20201227195815659"></p>
<h3 id="2-修改模板"><a href="#2-修改模板" class="headerlink" title="2. 修改模板"></a>2. 修改模板</h3><p>打开新建的文章<code>我的第一篇博客.md</code>，可以看到它并不是空的，可是页面上却显示为空，因为 Hexo 根据默认模板帮我们自动生成了一些参数，比如文章创建时间等。这个模板是可更改的。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227194608547.png" alt="image-20201227194608547"></p>
<p>这就需要修改<code>根目录配置文件</code>(‪D:\MyBlog_config.yml)的<code>new_post_name</code>参数了，其中year month day 分别表示创建文章的年月日，这样，再新建文章时，文件名将会自动加上年月日信息，便于通过日期来管理文章。当然，这个时间后面也是可以修改的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year-:month-:day-:title.md</span></span><br></pre></td></tr></table></figure>
<p>编辑上面打开的文章<code>我的第一篇博客.md</code>，添加一些正文，并改一下自动生成三个参数。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227201533968.png" alt="image-20201227201533968"></p>
<p>此时先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止服务器，执行<code>hexo g &amp;&amp; hexo s</code>重新部署，刷新<code>http://localhost:4000/</code>，看看效果。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227201741602.png" alt="image-20201227201741602"></p>
<h2 id="七、后续"><a href="#七、后续" class="headerlink" title="七、后续"></a>七、后续</h2><p>至此，我们的博客已经基本可以用了，只是现在还部署在本地，其实本地的效果就是发布的效果，后面只把这一整套文件都部署到远程服务器上就可以了，针不戳。第一部分说了， 0202 年我们想搭建一个网站不用自己从头开始写 html，有 Hexo 这么优秀的框架供我们选择，而且还完全免费，那么部署网站怎么办呢？</p>
<p>毕竟马上就要 2021 年了，现在部署网站也不用买服务器啦，有 GitHub Page 和 Gitee Page 等免费服务可供我们选择，只需要注册一个帐号就可以了。虽然 GitHub 在程序员界是最流行的，但是由于网络环境原因访问速度很慢，再加上最近的形势变化，说不定哪天这网站甚至会打不开了，所以国内平台Gitee成了一个不错的选择。</p>
<p>网站部署步骤详情见本系列文章的第二篇和第三篇，这两个步骤只需任选其一即可。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(五)——Typora + PicGo + GitHub/Gitee图床</title>
    <url>/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第五篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li><strong>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></strong></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们搭建好了博客，选择了 Typora 作为创作软件，但是现在一篇博客从写完到发布到网站还是有许多步骤要手动处理，比如处理图片路径，发布更新等。写博客已经很耗费时间了，我们肯定不希望花费大量时间在部署上，毕竟使用 CSDN 等平台写博客时只需一键就可以发布博客，所以有必要把一些重复工作自动化，提升自己的创作体验。接下来两篇文章就做这件事情，首先是完成图床的搭建，然后是通过脚本一键发布博客。</p>
<p>本篇文章先介绍怎么搭建自己的免费图床。我尝试了各种组合方案，最终选用了最方便的 Typora + PicGo + GitHub + jsDelivr CDN加速的方案。不过既然前面讲了使用 Gitee Pages 建站，这里也介绍一下使用 Gitee 搭建图床的方法。关于 Typora 的使用介绍见上一篇文章。</p>
<h2 id="什么是图床"><a href="#什么是图床" class="headerlink" title="什么是图床"></a>什么是图床</h2><p>图床是什么？Picture bed？No ，其实是 Picture host，即提供外链访问的图片存储服务器（看了《西部世界》，见到 “host” 最先想到的竟是“接待员” -.-）。通俗讲就是你把图片上传到一个图床提供者的图片服务器上，它会生成一个存储链接，你就可以随时通过这个链接就下载这个图片，而且还可以把这个链接放到 html 里或者 Markdown 文件里，浏览时再由浏览器或者阅读器自动加载出来。</p>
<p>具体有什么用呢？对于我们的 Markdown 格式的博客而言，图片就成了一个文本，你可以把文章复制到 CSDN/简书/知乎/个人博客等地方，每次换地方不需要重新上传图片，这些网站都能根据图床链接将图片加载出来。这样一说是不是发现“图床”这个翻译还挺贴切的。</p>
<p>当然也有翻车的时候，有时候我们浏览网页时，发现文字都能加载出来，图片都变成了一个个的叉号，这就是因为图床挂了，网站无法根据链接加载到图片，所以图床的稳定性就很重要了。还有一个问题，就是外链大家都可以访问，那么你的图片就很容易被盗链，别人直接用你的链接就可以下载到你的高清大图，版权问题不说，如果你是使用付费图床，一般是按访问流量收费，别人在文章中直接用你的图片链接，走的都是你的流量费，不过现在的图床都提供了防盗链方案。</p>
<p>图床服务国内的有微博图床、聚合图床、七牛云、阿里云、腾讯云等，国外的有 imgur、imgbox、SM图床等，大都是要收费的。此外也有些免费的图床服务，但是不敢用啊，万一哪天没了。</p>
<p>其实我们可以利用 GitHub 的存储能力和对外开放访问的特点，将 GitHub 仓库作为图床。不但免费，而且不用担心图床挂掉，毕竟如果 GitHub 挂了，部署在 GitHub Pages 的博客网站也打不开了，还管什么图片能不能加载出来。当然也请大家合理利用资源，GitHub仓库有 1G 大小的上限。</p>
<h2 id="什么是-PicGo"><a href="#什么是-PicGo" class="headerlink" title="什么是 PicGo"></a>什么是 PicGo</h2><p>PicGo 是一位中国开发者基于 electron-vue 开发的用于快速上传图片并获取图片 URL 链接的开源工具，GitHub主页：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，作者博客：<a href="https://molunerfinn.com/">MARKSZのBlog</a>。</p>
<p>写文章需要引用图片时，我们要打开浏览器将图片上传到图床服务器，再把链接复制粘贴到文章中。这太影响效率了，能不能每次插入图片时自动把图片上传并返回链接地址呢？PicGo 便是做这件事的软件，只要配置好图床类型，就可以直接拖拽图片进行上传并自动返回图片链接，配合 Typora 还可以实现在文章中插入图片时自动上传并替换为链接内容，完全不用感知上传图片的过程。</p>
<p>PicGo 本体支持七牛云、腾讯云、又拍云、阿里云、SM、Imgur、GitHub这些图床，而且还支持自己扩展第三方图床的支持插件，比如就有人开发了 Gitee 的插件。更多介绍见<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B9%9F%E6%83%B3%E7%94%A8picgo">官方文档</a>，下载地址：<a href="https://molunerfinn.com/PicGo/">PicGo</a></p>
<p>打开下载地址，选择一个版本点进去，点击下载对应的安装包安装即可。同样的，如果下载速度太慢，右键<code>复制链接地址</code>，粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000207889.png" alt="image-20210113000207889"></p>
<h2 id="GitHub-图床"><a href="#GitHub-图床" class="headerlink" title="GitHub 图床"></a>GitHub 图床</h2><h4 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h4><p>第一步要先在 GitHub 新建一个仓库用于存储图片。</p>
<p>打开自己 GitHub <a href="https://github.com/">主页</a>，点击<kbd>New</kbd>新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000300203.png" alt="image-20210113000300203"></p>
<p><code>Repository name</code>填写仓库名字，<code>Description</code>填写仓库描述，勾选<code>Add a README file</code>，点击<kbd>Create repository</kbd>创建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000500752.png" alt="image-20210113000500752"></p>
<h4 id="2-获取-repo-tokens"><a href="#2-获取-repo-tokens" class="headerlink" title="2. 获取 repo tokens"></a>2. 获取 repo tokens</h4><p>这个 token 主要用于让 PicGo 有权限往我们的仓库 push 代码(图片)。</p>
<p>点击自己的头像，选择<kbd>Settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000533777.png" alt="image-20210113000533777"></p>
<p>选择<kbd>Developer settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000731905.png" alt="image-20210113000731905"></p>
<p>点击 <kbd>Personal access tokens</kbd>。然后点击<kbd>Generate new token</kbd>，因为是敏感操作，此时需要确认密码。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000830696.png" alt="image-20210113000830696"></p>
<p><code>Note</code>填写 token 用途，用于备忘。下面只需要勾选<code> repo</code>，只给更新仓库的权限。最后点击最下面的<kbd>Generate token</kbd>创建成功。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113001007861.png" alt="image-20210113001007861"></p>
<p>复制字符串下一步使用。注意，为了安全起见此字符串只会出现一次，点击其他页面后就无法再查看了，需要重新创建，所以最好先保存到本地编辑器中。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113001256619.png" alt="image-20210113001256619"></p>
<h4 id="3-PicGo-配置"><a href="#3-PicGo-配置" class="headerlink" title="3. PicGo 配置"></a>3. PicGo 配置</h4><p>打开 PicGo ,选择<code>图床设置</code>，选择<code>GitHub图床</code>，填写参数：</p>
<ul>
<li><code>设定仓库名</code>，填写格式为<code>用户名/仓库名</code></li>
<li><code>设定分支名</code>，填写默认分支<code>master</code>或者<code>main</code></li>
<li><code>设定Token</code>，填写上一步获取的 token 值</li>
<li><code>指定存储路径</code>，选填，可以自定义名称，比如用年月来分类，不填图片会上传在仓库根目录。</li>
<li><code>设定自定义域名</code>，用于修改返回的 url 前缀，不填则返回原始 url。后面配置CDN加速需要更改此项。</li>
</ul>
<p>选择<kbd>设为默认图床</kbd>，点击<kbd>确定</kbd>保存配置。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233928390.png" alt="image-20210112233928390"></p>
<p>配置完成后，点击<code>上传区</code>，随便选择电脑上一张图片拖动到上传区，上传成功后会弹窗提示，将该 url 复制到浏览器打开就可以看到图片。可以在<code>PicGo设置</code>，打开<code>上传后自动复制URL</code>，这样上传成功后图片 url 会自动复制在剪贴板，可以直接粘贴到记事本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113223506305.png" alt="image-20210113223506305"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112235620646.png" alt="image-20210112235620646"></p>
<h4 id="4-CDN-加速-jsDelivr"><a href="#4-CDN-加速-jsDelivr" class="headerlink" title="4. CDN 加速(jsDelivr)"></a>4. CDN 加速(jsDelivr)</h4><p>从上一步可以看到 GitHub 存储的图片地址是 <code>https://raw.githubusercontent.com</code> 开头的网址，这个域名在某些地方可能打不开或者很慢导致图片加载失败，所以我们需要对图片配置 CDN 加速。</p>
<p>CDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。具体原理见<a href="https://www.jianshu.com/p/1dae6e1680ff">CDN加速原理</a>。通俗来讲，就是 CDN 服务商在全球各个地方建立服务器把要加速的站点进行缓存备份，当你访问站点时实际上是从离你最近的服务器访问缓存，速度自然就快了。</p>
<p>既然要搭建这么多服务器，服务肯定是要收费的吧。在这个互联网时代，还真有免费 CDN —— jsDelivr CDN，不仅开源免费而且在中国大陆建有许多服务站点，官网还声称是中国大陆唯一拥有许可证的公有 CDN，所以速度、稳定性都可以放心了。</p>
<p>打开<a href="https://www.jsdelivr.com/">jsDelivr CDN 官网</a>，可以看到 jsDelivr 支持 npm、GitHub、WordPress三个站点的加速，用于我们的GitHub图床是再适合不过了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112225345331.png" alt="image-20210112225345331"></p>
<p>在浏览器输入<code>https://cdn.jsdelivr.net/gh/用户名/仓库名/</code>，(注意最后的<code>/</code>不要丢)，可以打开我们在 GitHub 上创建的仓库的文件列表，说明我们在 Github 上创建的仓库已经默认被 jsDelivr 缓存了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112232127381.png" alt="image-20210112232127381"></p>
<p>所以只要把资源链接中的前面部分更改一下就可以使用 CDN 加速了。</p>
<p>例如，</p>
<p>原始图片地址的格式为<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/目录/图片名.png</code>，<code>https://raw.githubusercontent.com/yushuaige/myblog/master/img/image-20201219114500183.png</code>，</p>
<p>更改后的图片地址的格式<code>https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名/目录/图片名.png</code>，</p>
<p><code>https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20201219114500183.png</code>。</p>
<p>可以分别打开一下两个图片网址感受一下速度区别。</p>
<p><strong>PicGo 中需要改一下自定义域名</strong>，之后上传图片自动生成的链接就是 jsDelivr 的链接了。具体就是在<code>设定自定义域名</code>填写<code>https://cdn.jsdelivr.net/gh/用户名/仓库名@master</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112232746338.png" alt="image-20210112232746338"></p>
<h4 id="5-Typora-配置"><a href="#5-Typora-配置" class="headerlink" title="5. Typora 配置"></a>5. Typora 配置</h4><p>打开<code>文件</code>，<code>偏好设置</code>，<code>图像</code>，选择插入图片时<code>上传图片</code>，勾选图中三个选项，上传服务设定选择<code>PicGo (app)</code>，PicGo 路径通过后面的文件夹选择自己电脑上 PicGo 的安装路径。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233235226.png" alt="image-20210112233235226"></p>
<p>此时，使用 Typora 编辑文件，拖入或者粘贴图片时，会自动调用 PicGo 将图片上传到我们的 GitHub 图床，并把返回的图片链接粘贴到文章中，快去试试吧。</p>
<h2 id="Gitee-图床"><a href="#Gitee-图床" class="headerlink" title="Gitee 图床"></a>Gitee 图床</h2><h4 id="1-新建仓库-1"><a href="#1-新建仓库-1" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h4><p>第一步要先在 Gitee 新建一个仓库用于存储图片。</p>
<p>打开自己 Gitee <a href="https://gitee.com/">主页</a>，点击右上角的<kbd>+</kbd>号新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113220514529.png" alt="image-20210113220514529"></p>
<p>依次填写<code>仓库名称</code>，<code>路径</code>，<code>仓库介绍</code>，注意要勾选<code>公开</code>和<code>使用Readme文件初始化这个仓库</code>，最后点击<kbd>创建</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113221426230.png" alt="image-20210113221426230"></p>
<h4 id="2-获取私人令牌"><a href="#2-获取私人令牌" class="headerlink" title="2. 获取私人令牌"></a>2. 获取私人令牌</h4><p>同样的，<code>私人令牌</code>和 GitHub 上的 token 一样，主要用于让 PicGo 有权限往我们的仓库 push 代码(图片)。</p>
<p>点击自己的头像，选择<code>设置</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222056606.png" alt="image-20210113222056606"></p>
<p>点击<code>私人令牌</code>，选择<kbd>生成新令牌</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222420963.png" alt="image-20210113222420963"></p>
<p>同样的，我们只勾选更新代码的权限。填写<code>私人令牌描述</code>，点击<kbd>提交</kbd>。因为是敏感操作，此时需要确认密码。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222755852.png" alt="image-20210113222755852"></p>
<p>复制字符串下一步使用。注意，为了安全起见此字符串只会出现一次，点击其他页面后就无法再查看了，需要重新创建，所以最好先保存到本地编辑器中。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113223101983.png" alt="image-20210113223101983"></p>
<h4 id="3-PicGo-配置-1"><a href="#3-PicGo-配置-1" class="headerlink" title="3. PicGo 配置"></a>3. PicGo 配置</h4><p>PicGo 本体没有支持 Gitee ，所以需要下载一个插件，有人己经写好了。</p>
<p>打开 PicGo ，点击 <code>插件设置</code>，搜索框输入<code>gitee</code>，目前有两个插件应该都能用，任选一个安装，这里我选择的后面那个。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113225243341.png" alt="image-20210113225243341"></p>
<p>安装好插件后，这时再选择<code>图床设置</code>，选择<code>gitee</code>，填写参数：</p>
<ul>
<li><code>repo</code>，填写格式为<code>用户名/仓库名</code></li>
<li><code>branch</code>，填写默认分支<code>master</code></li>
<li><code>token</code>，填写上一步获取的私人令牌的值</li>
<li><code>path</code>，选填，可以自定义名称，不填图片会上传在仓库根目录。</li>
<li><code>customPath</code>，这个会在上一个参数的基础上再创建一层子文件夹用于按年、年月或年季来分类保存。</li>
<li><code>customUrl</code>，用于修改返回的 url 前缀，不填则返回原始 url。后面解决<code>文件大于1M，登录后可见</code>的问题需要更改此项。</li>
</ul>
<p>在 PicGo 里，GitHub 的设置都是中文的， Gitee 插件的设置反而都是英文的，有点意思hh。</p>
<p>选择<kbd>设为默认图床</kbd>，点击<kbd>确定</kbd>保存配置。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113224703801.png" alt="image-20210113224703801"></p>
<p>配置完成后，点击<code>上传区</code>，随便选择电脑上一张图片拖动到上传区，上传成功后会弹窗提示，将该 url 复制到浏览器打开就可以看到图片。可以在<code>PicGo设置</code>，打开<code>上传后自动复制URL</code>，这样上传成功后图片 url 会自动复制在剪贴板，可以直接粘贴到记事本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112235111559.png" alt="image-20210112235111559"></p>
<p><img src="https://gitee.com/yushuaigee/myblog/raw/master/img/image-20210113224024050.png" alt="image-20210113224024050"></p>
<h4 id="4-Typora-配置"><a href="#4-Typora-配置" class="headerlink" title="4. Typora 配置"></a>4. Typora 配置</h4><p>打开<code>文件</code>，<code>偏好设置</code>，<code>图像</code>，选择插入图片时<code>上传图片</code>，勾选图中三个选项，上传服务设定选择<code>PicGo (app)</code>，PicGo 路径通过后面的文件夹选择自己电脑上 PicGo 的安装路径。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233235226.png" alt="image-20210112233235226"></p>
<p>此时，使用 Typora 编辑文件，拖入或者粘贴图片时，会自动调用 PicGo 将图片上传到我们的 Gitee 图床，并把返回的图片链接粘贴到文章中，快去试试吧。</p>
<h4 id="5-解决”文件大于1M，登录后可见”问题"><a href="#5-解决”文件大于1M，登录后可见”问题" class="headerlink" title="5. 解决”文件大于1M，登录后可见”问题"></a>5. 解决”文件大于1M，登录后可见”问题</h4><p>从上一步可以看到 Gitee 存储的图片地址是 <code>https://gitee.com/yushuaigee/myblog/raw</code> 开头的网址，这个域名是国内站点，速度很快，无需配置CDN加速，图床配置好之后，图片上传成功，在浏览器也能打开，看似没毛病，其实暗藏玄机。</p>
<p>如果你上传的图片大于 1M ，不管是在下一步的 Typora 中还是在浏览器网页中，是无法加载出图片的，比如这张图片<code>https://gitee.com/yushuaigee/myblog/raw/master/img/myblog.gif</code>，输入到浏览器会显示<code>文件大于1M，登录后可见</code>。如果能打开是因为你前面已经登录了 Gitee 了，浏览器新建一个无痕窗口就打不开了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113230821769.png" alt="image-20210113230821769"></p>
<p>可是别人在浏览我们博客时不可能要先登录个 Gitee 吧，所以要想办法解决一下。前面我们将博客仓库打开 Gitee Pages 功能，其他人可以访问我们博客仓库里的博客了，图床仓库也一样，打开它的  Gitee Pages 功能，无需登陆就可以访问里面的图片了。</p>
<p>进入图床仓库主页，点击<code>服务</code>，<code>Gitee Pages</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113231334002.png" alt="image-20210113231334002"></p>
<p>点击<code>启动</code>部署。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113232431704.png" alt="image-20210113232431704"></p>
<p>这样我们就可以通过Gitee Pages 地址来访问图床仓库里的图片了 ，地址前缀需要改一下。</p>
<p>例如，</p>
<p>原始图片地址的格式为<code>https://gitee.com/用户名/仓库名/raw/分支名/目录/图片名.png</code>，<code>https://gitee.com/yushuaigee/myblog/raw/master/img/myblog.gif</code>，</p>
<p>更改后的图片地址的格式<code>https://用户名.gitee.io/仓库名/目录/图片名.png</code>，</p>
<p><code>https://yushuaigee.gitee.io/myblog/img/myblog.gif</code>。</p>
<p><strong>对应的，PicGo 中就需要改一下自定义域名</strong>，之后上传图片自动生成的链接就是 Gitee Pages 上的地址了。具体就是在<code>customUrl</code>填写<code>https://用户名.gitee.io/仓库名</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233142363.png" alt="image-20210113233142363"></p>
<p><strong>这种方法也存在一个问题</strong>，就是因为 Gitee Pages 不支持自动更新 (pro版支持，需要收费)，每次上传完图片后，需要打开浏览器手动点一下更新。你可以写完文章，把图片一把上传，再点一次更新，但是终究还是有点麻烦。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113231428575.png" alt="image-20210113231428575"></p>
<p><strong>为了解决这个问题，我写了一个自动化脚本</strong>，双击启动就可以自动完成 Gitee Pages 部署，其实原理就是利用 pyppeteer 模拟用户登录，到部署页面模拟点击<code>更新</code>按钮，虽然还是需要启动一下脚本，但是也稍微省了点事儿，下一篇文章将自动部署 Hexo 和 自动部署 Gitee Pages  结合起来。</p>
<p><strong>效果</strong></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233250172.png" alt="image-20210113233250172"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233443911.png" alt="image-20210113233443911"></p>
<p><strong>start.bat 源码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:: start.bat 源码</span><br><span class="line">:: python路径 + 空格 + 脚本路径</span><br><span class="line">C:\Python\Scripts\python.exe D:/scripts/post_my_blog.py</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p><strong>post_my_blog.py 源码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post_my_blog.py 源码</span></span><br><span class="line"><span class="comment"># 注意: 更改25、36、52行的用户名密码为自己的Gitee的用户名密码，第45行的仓库名为图床仓库的名字</span></span><br><span class="line"><span class="comment"># 每处延时都有用，是我花了好长时间调试过的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">	browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="comment"># 登录</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_login&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_password&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;使用账号密码登录成功...&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;使用cookies缓存登录成功...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/%s/%s/pages&#x27;</span> % (usr_name, repo_name))</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    page.on(<span class="string">&#x27;dialog&#x27;</span>, <span class="keyword">lambda</span> dialog: asyncio.ensure_future(_handle_dialog(page, dialog)))</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#pages-branch &gt; div.button.orange.redeploy-button.ui.update_deploy&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">20000</span>)</span><br><span class="line">    print(<span class="string">&#x27;更新 Gitee Pages %s 成功...&#x27;</span> % repo_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_handle_dialog</span>(<span class="params">page, dialog</span>):</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    print(<span class="string">&#x27;点击确定更新&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> dialog.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">    asyncio.get_event_loop().run_until_complete(_update_gitee_pages(usr_name, repo_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    update_gitee_pages(<span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;仓库名&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>两个图床都不完美，所以究竟选哪个呢？让我这个强迫症很纠结。我尝试了各种组合方案，最终总结了两个方案：</p>
<ol>
<li> Typora + PicGo + GitHub图床 + jsDelivr CDN加速</li>
<li> Typora + PicGo + Gitee图床 + Gitee Pages + 自动部署脚本</li>
</ol>
<p>第一种方案似乎比较完美，但是美中不足的是虽然CDN加速解决了查看图片的速度，但是上传还是有点慢的，会出现在 Typora 中粘贴了一张图片后需要5秒以上才能上传成功并加载出来，还有就是本地没有分类备份(其实在<code>C:\Users\用户名\AppData\Roaming\Typora\typora-user-images</code>目录下有缓存)。</p>
<p>第二种方案速度没的说，通过 Gitee Pages  也解决了大图片的问题，通过脚本也解决了自动部署的问题，但是在 Typora 中粘贴了一张图片后，由于没有<code>更新</code>部署，实际上还不能访问，所以不能实时预览，需要用脚本自动部署后重新打开 Typora 才能加载出图片。我想了一种办法，就是在 Typora 设置插入图片时保存在本地，这样就实时加载，还能在本地存一份备份，然后写脚本将文件夹里图片用 PicGo 批量上传然后再调脚本自动部署，然后再自动将 md 文件中的本地链接都改成图床链接。看似麻烦还是可行的，下一篇文章中再实现吧。</p>
<p>我暂时选择了第一种方案。.</p>
<p>本篇文章介绍怎么搭建自己的 GitHub 和 Gitee 免费图床并搭配 Typora 和 PicGo 工具使用 ，两种图床都有自己的好处和缺点，我也尝试了提供了解决办法。</p>
<p>自己搭建的博客漂亮且方便，但终究不如在 CSDN 等成熟的平台上发布博客曝光量大。所以我们写完博客想在 CSDN 和自己的博客站点同时发布，我们怎么可能一篇一篇地手动复制呢，当然是自动化脚本实现啦。接下来两篇文章介绍一下怎么一键在三个站点发布博客，以及怎么快速把 CSDN 的旧博客迁移到自己的站点。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</title>
    <url>/2021/01/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第六篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li><strong>从零开始免费搭建自己的博客(六)——<a href="https://yushuaigee.gitee.io/2021/01/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">三个站点一键发布博客</a></strong></li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文目标：本地写好文章后，双击执行一个脚本，文章可以自动发布到自己的 github.io 、gitee.io 和 CSDN。</p>
<p>实现原理：</p>
<ol>
<li>写文章时自己在开头添加好title，date，tags等字段，用python实现文章的新旧版本替换。</li>
<li>配置好 Hexo 的配置文件，用shell脚本实现 <code>hexo g</code>和<code>hexo d</code>等操作，Python脚本实现Gitee Pages更新。</li>
<li>利用puppeteer模拟浏览器登录CSDN发布博客。</li>
<li>将前面三步的代码整合，使用bat脚本双击运行。</li>
</ol>
<h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><p>我平时在本地写文章保存在<code>E:\Markdown</code>目录，而 Hexo 保存在<code>D:\MyBlog</code>目录。发布 Hexo 之前需要先把文章拷贝到<code>D:\MyBlog\source\_posts</code>目录，有时候文章有修改还要重新拷贝覆盖。所以考虑用Python脚本实现拷贝文件，判断文件最后修改时间决定是否需要覆盖旧文章。</p>
<p>因为我们省略了<code>hexo create &quot;title&quot;</code>这一步，直接把文件拷贝到了<code>_posts</code>目录，所以写文章时需要确保在开头加上 title、date、tags、category信息，不然发布的文章会没有没有标题、发布时间、标签、分类信息，其实<code>hexo create</code>命令做的就是这件事。<strong>注意最后的空行一定要有</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2021-01-11 19:50:43</span><br><span class="line">tags: [博客搭建]</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是在 Typora 中编辑，直接在第一行输入<code>---</code>回车就行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210121222437143.png" alt="image-20210121222437143"></p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy_to_hexo.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_to_hexo</span>():</span></span><br><span class="line">    local_list = os.listdir(LOCAL_ARTICLE_PATH)</span><br><span class="line">    hexo_list = os.listdir(HEXO_ARTICLE_PATH)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> local_list:</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">in</span> IGNORE_LIST:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.md&#x27;</span>):</span><br><span class="line">            local_version = os.path.join(LOCAL_ARTICLE_PATH, file)</span><br><span class="line">            hexo_version = os.path.join(HEXO_ARTICLE_PATH, file)</span><br><span class="line">            <span class="keyword">if</span> file <span class="keyword">not</span> <span class="keyword">in</span> hexo_list:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">&quot;新增文章: %s...&quot;</span> % file,</span><br><span class="line">                      <span class="string">&quot;最后修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(local_version)))</span><br><span class="line">                shutil.copy(local_version, hexo_version)</span><br><span class="line">            <span class="keyword">elif</span> os.path.getmtime(local_version) &gt; os.path.getmtime(hexo_version):</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">&quot;更新文章: %s...&quot;</span> % file,</span><br><span class="line">                      <span class="string">&quot;上次修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(hexo_version)),</span><br><span class="line">                      <span class="string">&quot;最后修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(local_version)))</span><br><span class="line">                shutil.copy(local_version, hexo_version)</span><br><span class="line">    print(<span class="string">&#x27;文章无变化&#x27;</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">&#x27;更新完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间格式标准化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TimeStampFormat</span>(<span class="params">timestamp</span>):</span></span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(timestamp))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IGNORE_LIST = [<span class="string">&#x27;欢迎使用Markdown编辑器.md&#x27;</span>]</span><br><span class="line">HEXO_ARTICLE_PATH = <span class="string">&#x27;D:/MyBlog/source/_posts&#x27;</span></span><br><span class="line">LOCAL_ARTICLE_PATH = <span class="string">&#x27;E:/Markdown&#x27;</span></span><br><span class="line"></span><br><span class="line">copy_to_hexo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124222133145.png" alt="image-20210124222133145"></p>
<h2 id="发布Hexo到GitHub-Gitee"><a href="#发布Hexo到GitHub-Gitee" class="headerlink" title="发布Hexo到GitHub/Gitee"></a>发布Hexo到GitHub/Gitee</h2><p>本来以为需要把配置文件<code>deploy</code>参数改成 GitHub 地址 <code>hexo d</code>一次，再改成 Gitee 地址<code>hexo d</code>一次，后来看文档发现 Hexo 支持一次发布到多个仓库，只需要修改一下配置文件，然后<code>hexo g &amp;&amp; hexo d</code>就可以了。</p>
<h4 id="1修改Hexo配置文件"><a href="#1修改Hexo配置文件" class="headerlink" title="1修改Hexo配置文件"></a>1修改Hexo配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:用户名/用户名.github.io.git,main</span></span><br><span class="line">      <span class="attr">gitee:</span> <span class="string">git@gitee.com:用户名/仓库名.git,master</span></span><br></pre></td></tr></table></figure>
<h4 id="shell发布脚本"><a href="#shell发布脚本" class="headerlink" title="shell发布脚本"></a>shell发布脚本</h4><p><kbd>Git Bash</kbd>支持直接运行 shell 脚本，只需要把下面代码保存为 <code>.sh</code>后缀的文件即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> deploy_hexo.sh</span></span><br><span class="line">cd /d/MyBlog</span><br><span class="line">pwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 白底黑字效果</span></span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo g&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">hexo g</span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo d&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">hexo d</span><br><span class="line">sleep 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行完毕不退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124214628069.png" alt="image-20210124214628069"></p>
<h4 id="Gitee-Pages更新脚本"><a href="#Gitee-Pages更新脚本" class="headerlink" title="Gitee Pages更新脚本"></a>Gitee Pages更新脚本</h4><p>上一篇博客已经实现了用 Python 脚本自动更新 Gitee pages，这里直接拿来用就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update_gitee_pages.py</span></span><br><span class="line"><span class="comment"># 注意: 更改25、36、52行的用户名密码为自己的Gitee的用户名密码，第45行的仓库名为图床仓库的名字</span></span><br><span class="line"><span class="comment"># 每处延时都有用，是我花了好长时间调试过的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">	browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="comment"># 登录</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_login&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_password&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;使用账号密码登录成功...&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;使用cookies缓存登录成功...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/%s/%s/pages&#x27;</span> % (usr_name, repo_name))</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    page.on(<span class="string">&#x27;dialog&#x27;</span>, <span class="keyword">lambda</span> dialog: asyncio.ensure_future(_handle_dialog(page, dialog)))</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#pages-branch &gt; div.button.orange.redeploy-button.ui.update_deploy&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">20000</span>)</span><br><span class="line">    print(<span class="string">&#x27;更新 Gitee Pages %s 成功...&#x27;</span> % repo_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_handle_dialog</span>(<span class="params">page, dialog</span>):</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    print(<span class="string">&#x27;点击确定更新&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> dialog.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">    asyncio.get_event_loop().run_until_complete(_update_gitee_pages(usr_name, repo_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    update_gitee_pages(<span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;仓库名&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124214209633.png" alt="image-20210124214209633"></p>
<h2 id="发布到CSDN"><a href="#发布到CSDN" class="headerlink" title="发布到CSDN"></a>发布到CSDN</h2><p>最不好处理的是自动发布文章到 CSDN ，据说 CSDN 官方之前是提供了发布文章的接口的，后来关闭了。一文多发这个功能对于做自媒体的人来说需求很大，于是有了  <a href="https://openwrite.cn/">OpenWrite</a>这种一文多发平台，还有开源的<a href="https://github.com/crawlab-team/artipub">ArtiPub</a>。各大平台都没有提供发布文章的官方接口，这种一分多发平台想必也是通过模拟 http 请求来实现自动发文。</p>
<p>本文利用 Python 的第三方库 <a href="https://github.com/pyppeteer/pyppeteer">puppeteer</a> 操作无头浏览器模拟登陆 CSDN 发布文章，类似 Selenium，更加接近真实操作，防止被网站检测到机器操作导致封号。最近发现 Go 语言的 <a href="https://github.com/go-rod/rod">go-rod</a> 库对于模拟浏览器操作更加好用，官方文档写的很详细，两者都不用另外下载 driver，相比于 Selenium 方便了很多，后面打算用 Golang 重新实现一版，今天先看下 Python 代码。<strong>注意这只是个 Demo，实现了自动发布一篇文章的功能，我们的需求是发布多篇文章，实际使用要稍作修改，实际使用的代码是这个 <a href="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/scripts/post_to_csdn.py">post_to_csdn.py</a>)。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post_to_csdn_demo.py </span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">blog_name, title, content, tags, category</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param blog_name: 博客名字，自己博客主页url的最后部分</span></span><br><span class="line"><span class="string">    :param title: 文章标题</span></span><br><span class="line"><span class="string">    :param content: 文章内容</span></span><br><span class="line"><span class="string">    :param tags: 标签，多个用英文&quot;,&quot;隔开</span></span><br><span class="line"><span class="string">    :param category: 分类</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    print(<span class="keyword">await</span> browser.userAgent())</span><br><span class="line">    pages_list = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    page = pages_list[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># await page.setViewport(viewport=&#123;&#x27;width&#x27;: 1920, &#x27;height&#x27;: 1080&#125;)</span></span><br><span class="line">    <span class="comment"># 打开博客主页</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://blog.csdn.net/%s&#x27;</span> % blog_name)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 先找到已有文章</span></span><br><span class="line">     elements = <span class="keyword">await</span> page.querySelectorAll(<span class="string">&#x27;#articleMeList-blog &gt; div.article-list &gt; div &gt; h4&#x27;</span>)</span><br><span class="line">    article_list = []</span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> elements:</span><br><span class="line">        article = <span class="keyword">await</span> (<span class="keyword">await</span> article.getProperty(<span class="string">&#x27;textContent&#x27;</span>)).jsonValue()</span><br><span class="line">        article_list.append(<span class="built_in">str</span>(article).strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>].strip())</span><br><span class="line">    print(<span class="string">&#x27;已有文章%d篇: &#x27;</span> % <span class="built_in">len</span>(article_list), article_list)</span><br><span class="line">    <span class="comment"># 点击 创作中心</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;#csdn-toolbar &gt; div &gt; div &gt; div.toolbar-container-right &gt; div &gt; div.toolbar-btn.toolbar-btn-write.csdn-toolbar-fl &gt; a&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">4000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        print(<span class="string">&#x27;正在登录...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击 CSDN App扫码</span></span><br><span class="line">        <span class="keyword">await</span> page.click(<span class="string">&#x27;#app &gt; div &gt; div &gt; div.main &gt; div.main-login &gt; div.main-select &gt; ul &gt; li:nth-child(1) &gt; a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 获取登录二维码</span></span><br><span class="line">        img_element = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#appqr &gt; span.app-code-wrap &gt; img&#x27;</span>)</span><br><span class="line">        img_src = <span class="keyword">await</span> (<span class="keyword">await</span> img_element.getProperty(<span class="string">&#x27;src&#x27;</span>)).jsonValue()</span><br><span class="line">        img_src = <span class="built_in">str</span>(img_src).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        img_data = base64.b64decode(img_src)</span><br><span class="line">        img_name = <span class="string">&#x27;login.png&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(img_name):</span><br><span class="line">            os.remove(img_name)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(img_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img_data)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_name)</span><br><span class="line">        img.show()</span><br><span class="line">    <span class="comment"># 等待登录成功，最多等5分钟</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(</span><br><span class="line">        <span class="string">&#x27;#view-containe &gt; div.left_box &gt; div.left_box_top &gt; a.routerlink-bt.routerlink-bt-md &gt; span&#x27;</span>,</span><br><span class="line">        timeout=<span class="number">300</span> * <span class="number">1000</span>)</span><br><span class="line">    print(<span class="string">&#x27;已登录&#x27;</span>)</span><br><span class="line">    <span class="comment"># 点击 Markdown 编辑器</span></span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#view-containe &gt; div.left_box &gt; div.left_box_top &gt; a.routerlink-bt.routerlink-bt-md &gt; span&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">3000</span>)</span><br><span class="line">    <span class="comment"># 切换到写文章页签</span></span><br><span class="line">    pages_list = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    page = pages_list[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 选中标题输入框</span></span><br><span class="line">    print(<span class="string">&#x27;输入标题: %s&#x27;</span> % title)</span><br><span class="line">    title_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.layout__panel--articletitle-bar &gt; div &gt; div.article-bar__input-box &gt; input&#x27;</span>)</span><br><span class="line">    <span class="comment"># 清空原有内容</span></span><br><span class="line">    <span class="keyword">await</span> title_input.focus()</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;KeyA&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Backspace&#x27;</span>)</span><br><span class="line">    <span class="comment"># 输入标题内容</span></span><br><span class="line">    <span class="keyword">await</span> title_input.<span class="built_in">type</span>(title)</span><br><span class="line">    <span class="comment"># 选中文章输入框</span></span><br><span class="line">    print(<span class="string">&#x27;输入文章内容: %s&#x27;</span> % content)</span><br><span class="line">    content_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.flex.flex--row &gt; div &gt; div.layout__panel.flex.flex--row &gt; div.layout__panel.layout__panel--editor &gt; div.editor &gt; pre&#x27;</span>)</span><br><span class="line">    <span class="comment"># 清空原有内容</span></span><br><span class="line">    <span class="keyword">await</span> content_input.focus()</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;KeyA&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Backspace&#x27;</span>)</span><br><span class="line">    <span class="comment"># 输入文章内容</span></span><br><span class="line">    <span class="keyword">await</span> content_input.<span class="built_in">type</span>(content)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment"># 点击 发布文章</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.layout__panel--articletitle-bar &gt; div &gt; div.article-bar__user-box.flex.flex--row &gt; button.btn.btn-publish&#x27;</span>)</span><br><span class="line">    <span class="comment"># 删除原来的标签，如果有的话</span></span><br><span class="line">    exist_tags = <span class="keyword">await</span> page.querySelectorAll(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; span &gt; span &gt; i&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> exist_tags:</span><br><span class="line">        <span class="comment"># 每删一个，页面会有变化</span></span><br><span class="line">        tag = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">            <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; span &gt; span &gt; i&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> tag.click()</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 点击 添加文章标签</span></span><br><span class="line">    print(<span class="string">&#x27;添加标签: %s&#x27;</span> % tags)</span><br><span class="line">    add_tag = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; button&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> add_tag.click()</span><br><span class="line">    <span class="comment"># 添加标签</span></span><br><span class="line">    tag_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div.mark_selection_box &gt; div.mark_selection_box_header &gt; div &gt; div.el-input.el-input--suffix &gt; input&#x27;</span>)</span><br><span class="line">    tag_list = tags.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tag_list:</span><br><span class="line">        <span class="keyword">await</span> tag_input.<span class="built_in">type</span>(tag.strip())</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 收起 添加文章标签</span></span><br><span class="line">    <span class="keyword">await</span> add_tag.click()</span><br><span class="line">    <span class="comment"># 添加分类</span></span><br><span class="line">    print(<span class="string">&#x27;添加分类: %s&#x27;</span> % category)</span><br><span class="line">    add_category = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#tagList &gt; button&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> add_category.click()</span><br><span class="line">    category_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(4) &gt; div &gt; div &gt; input&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> category_input.<span class="built_in">type</span>(category)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 选择文章类型：原创</span></span><br><span class="line">    print(<span class="string">&#x27;文章类型: 原创&#x27;</span>)</span><br><span class="line">    select_box = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div.inline-box &gt; div &gt; div&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> select_box.click()</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 下拉框的 id 是个随机值，每次都不一样，通过按键曲线救国</span></span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;ArrowDown&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">    <span class="comment"># 选择发布形式：公开 2, 私密 4, 粉丝可见 6, VIP可见 8</span></span><br><span class="line">    print(<span class="string">&#x27;发布形式: 公开&#x27;</span>)</span><br><span class="line">    flag = <span class="number">2</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div.form-entry.flex.form-entry__field-switch-box.overflow-unset.form-entry-marginBottom &gt; div &gt; div &gt; label:nth-child(%d)&#x27;</span> % flag)</span><br><span class="line">    <span class="comment"># 发布文章：保存为草稿 btn-c-blue, 发布文章 btn-b-red</span></span><br><span class="line">    print(<span class="string">&#x27;点击发布...&#x27;</span>)</span><br><span class="line">    flag = <span class="string">&#x27;btn-b-red&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__button-bar &gt; button.button.%s&#x27;</span> % flag)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">3000</span>)</span><br><span class="line">    url_element = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#alertSuccess &gt; div &gt; div.pos-top &gt; div:nth-child(4) &gt; a&#x27;</span>)</span><br><span class="line">    url = <span class="keyword">await</span> (<span class="keyword">await</span> url_element.getProperty(<span class="string">&#x27;href&#x27;</span>)).jsonValue()</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line">    print(<span class="string">&#x27;发布成功, 文章地址: %s&#x27;</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blog_name = <span class="string">&#x27;yushuaigee&#x27;</span></span><br><span class="line">title = <span class="string">&#x27;自动发布的第一篇文章&#x27;</span></span><br><span class="line">content = <span class="string">&#x27;自动发布的第一篇文章自动发布的第一篇文章自动发布的第一篇文章&#x27;</span></span><br><span class="line">tags = <span class="string">&#x27;博客搭建,自动发布文章&#x27;</span></span><br><span class="line">category = <span class="string">&#x27;博客搭建&#x27;</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main(blog_name, title, content, tags, category))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124213855158.png" alt="image-20210124213855158"></p>
<h2 id="一键发布脚本！"><a href="#一键发布脚本！" class="headerlink" title="一键发布脚本！"></a>一键发布脚本！</h2><p>上面写的4个脚本一步一步实现了我们的每个小目标，对于 Windows 系统来说，可以使用 bat 脚本把它们整合在一起，完成“一键”发布的需求。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">:: post_my_blog.bat</span><br><span class="line">python copy_to_hexo.py</span><br><span class="line">D:\Git\git<span class="literal">-bash</span>.exe deploy_hexo.sh</span><br><span class="line">python update_gitee_pages.py</span><br><span class="line">python post_to_csdn.py</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>写好文章后，直接双击<code>post_my_blog.bat</code>就可以发布到三个地方了。</p>
<p>最终运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124223519915.png" alt="image-20210124223519915"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>本文解决了一文多发的问题，以前发布在 CSDN 上的博客就不用一篇一篇复制到自己的博客站点了，但是要想一键发布，需要先将 CSDN 上的文章先下载到本地，而且原来的文章是使用富文本编辑器写的，怎么转化成 Markdown 格式呢？下一篇文章将介绍这两个问题的解决方法。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>自动发布博客</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(四)——编写Markdown文章利器 Typora</title>
    <url>/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第四篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li><strong>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></strong></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们利用 Hexo 框架搭建了自己的博客网站，可以注意到 Hexo 默认是使用 Markdown 格式的文件的，所以在写新博客之前，我们要先了解一下  Markdown 语法 。</p>
<p>其实我在上大学时也听说过 Markdown，但是一直以为很麻烦，所以之前在 CSDN 的博客都是用富文本编辑器写的，直到在公司试着写了一篇 Markdown 格式的资料，才领略到它的魅力，要不说一个东西这么流行一定有它的道理呢。平时经常看到推荐 Markdown 的文章，都会提到”让你全程双手不离开键盘就可以写出带格式的文章”，我不以为然：我点几下鼠标就能编辑出很美观的格式，也没浪费多少时间啊，何必为了写文章去学一个新的语法呢？</p>
<p>开始用 Markdown 后，我发现选择 Markdown 起码有这些好处：</p>
<ul>
<li>一次编写，到处编辑，不会出现不同版本word显示效果不同的情况。</li>
<li>语法并不麻烦，从零基础到会使用，十分钟足矣。</li>
<li>简洁且漂亮。我也说不上来为啥，可能是因为程序员更懂程序员的审美吧。</li>
<li>有Typora这样的编辑器。这真是一个很大的加分项，如果你用过其他软件写 Markdown 就知道了。</li>
</ul>
<p>本文先介绍 Markdown 语法，再介绍下 Typora 软件的安装和使用。想必使用 Markdown 写文章的人没有不知道 Typora 的，为了系列文章的完整性还是写一篇，主要介绍下我个人觉得比较方便的使用技巧。</p>
<h2 id="一-、使用-Markdown"><a href="#一-、使用-Markdown" class="headerlink" title="一 、使用 Markdown"></a>一 、使用 Markdown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>创始人 John Gruber 在2004 创造了Markdown语言。 Markdown是一种轻量级标记语言，这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML。</p>
<p>更通俗的解释：我们之所以不用记事本而用 Microsoft Word 写文章，是因为在 Word 里，我们可以用鼠标设置各种标题、字体加粗等格式以及插入表格、插入图片等功能，使文章更加美观易读。而使用 Markdown 语法，在纯文本编辑器中也可以快速写出格式丰富且又美观的文章，手不用离开键盘。</p>
<p>什么叫标记语言，比如在 html 中，用<code>&lt;h1&gt;标题内容&lt;/h1&gt;</code>的形式来标记文字显示的格式，支持 html 解析的软件(浏览器)，读到<code>&lt;h1&gt;</code>就知道这是一个一级标题，然后就把它的字体渲染大一点。Markdown 也是类似的道理，不过作者让标记方法更简单更易读，例如想标记标题就用<code># 标题内容</code>这种形式，我们写文章时随手就能敲出来。当然，想要看到显示效果也需要在支持 Markdown 解析的软件中打开。</p>
<h3 id="十分钟学会-Markdown-语法"><a href="#十分钟学会-Markdown-语法" class="headerlink" title="十分钟学会 Markdown 语法"></a>十分钟学会 Markdown 语法</h3><p>我之所以没有把”十分钟学会…”放在标题里，是因为我这个方法是真的只需要十分钟，我就是这样做的。</p>
<p>下面代码块里的这段文字是 CSDN 的 Markdown 编辑器的新手示例帮助，基本包含了所有的 Markdown 用法，我们只需要在新建一个<code>Markdown示例.md</code>文件，把下面这段话复制进去保存，再用支持md格式的软件(比如后文介绍的Typora)打开，所有的效果所见即所得。先大概浏览一下有哪些效果，写自己的文章时，想用哪种效果直接在示例里面复制源码粘贴到自己的文件再修改就行了。</p>
<p>用这个方法写上一两篇文章，下次再写的时候就不用再参考示例了。因为我们本质上是用语法写文章，没必要上来先背 Markdown 语法，不会的可以现查。就跟学英语不能单纯的背单词而是要多看文章一个道理。</p>
<p>比如，写文章时想用一个按键的效果，就可以到示例文件中找到并复制过来修改一下：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/md_demo.gif" alt="md_demo"></p>
<p>示例内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">@[<span class="string">TOC</span>](<span class="link">这里写自定义目录标题</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 欢迎使用Markdown编辑器</span></span><br><span class="line"></span><br><span class="line">你好！ 这是你第一次使用 <span class="strong">**Markdown编辑器**</span> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</span><br><span class="line"></span><br><span class="line"><span class="section">## 新的改变</span></span><br><span class="line"></span><br><span class="line">我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</span><br><span class="line"></span><br><span class="line"><span class="bullet">  1.</span> <span class="strong">**全新的界面设计**</span> ，将会带来全新的写作体验；</span><br><span class="line"><span class="bullet">  2.</span> 在创作中心设置你喜爱的代码高亮样式，Markdown <span class="strong">**将代码片显示选择的高亮样式**</span> 进行展示；</span><br><span class="line"><span class="bullet">  3.</span> 增加了 <span class="strong">**图片拖拽**</span> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</span><br><span class="line"><span class="bullet">  4.</span> 全新的 <span class="strong">**KaTeX数学公式**</span> 语法；</span><br><span class="line"><span class="bullet">  5.</span> 增加了支持<span class="strong">**甘特图的mermaid语法[^1]**</span> 功能；</span><br><span class="line"><span class="bullet">  6.</span> 增加了 <span class="strong">**多屏幕编辑**</span> Markdown文章功能；</span><br><span class="line"><span class="bullet">  7.</span> 增加了 <span class="strong">**焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置**</span> 等功能，功能按钮位于编辑区域与预览区域中间；</span><br><span class="line"><span class="bullet">  8.</span> 增加了 <span class="strong">**检查列表**</span> 功能。</span><br><span class="line"></span><br><span class="line">[<span class="string">^1</span>]: [<span class="string">mermaid语法说明</span>](<span class="link">https://mermaidjs.github.io/</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 功能快捷键</span></span><br><span class="line"></span><br><span class="line">撤销：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Z<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">重做：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Y<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">加粗：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>B<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">斜体：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>I<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">标题：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>H<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">无序列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>U<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">有序列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>O<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">检查列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>C<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入代码：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>K<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入链接：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>L<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入图片：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>G<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">查找：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>F<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">替换：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>G<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 合理的创建标题，有助于目录的生成</span></span><br><span class="line"></span><br><span class="line">直接输入1次<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>#<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>，并按下<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>space<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>后，将生成1级标题。</span><br><span class="line">输入2次<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>#<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>，并按下<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>space<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>后，将生成2级标题。</span><br><span class="line">以此类推，我们支持6级标题。有助于使用<span class="code">`TOC`</span>语法后生成一个完美的目录。</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何改变文本的样式</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*强调文本*</span> <span class="emphasis">_强调文本_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文本**</span> <span class="strong">__加粗文本__</span></span><br><span class="line"></span><br><span class="line">==标记文本==</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用文本</span></span><br><span class="line"></span><br><span class="line">H~2~O is是液体。</span><br><span class="line"></span><br><span class="line">2^10^ 运算结果是 1024.</span><br><span class="line"></span><br><span class="line"><span class="section">## 插入链接与图片</span></span><br><span class="line"></span><br><span class="line">链接: [<span class="string">link</span>](<span class="link">https://www.csdn.net/</span>).</span><br><span class="line"></span><br><span class="line">图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</span>)</span><br><span class="line"></span><br><span class="line">带尺寸的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30</span>)</span><br><span class="line"></span><br><span class="line">居中的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</span>)</span><br><span class="line"></span><br><span class="line">居中并且带尺寸的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30</span>)</span><br><span class="line"></span><br><span class="line">当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何插入一段漂亮的代码片</span></span><br><span class="line"></span><br><span class="line">去[<span class="string">博客设置</span>](<span class="link">https://mp.csdn.net/console/configBlog</span>)页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <span class="code">`代码片`</span>.</span><br><span class="line"></span><br><span class="line">​<span class="code">```javascript</span></span><br><span class="line"><span class="code">// An highlighted block</span></span><br><span class="line"><span class="code">var foo = &#x27;bar&#x27;;</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 生成一个适合你的列表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 项目</span><br><span class="line"><span class="bullet">  -</span> 项目</span><br><span class="line"><span class="bullet">    -</span> 项目</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 项目1</span><br><span class="line"><span class="bullet">2.</span> 项目2</span><br><span class="line"><span class="bullet">3.</span> 项目3</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [ ] 计划任务</span><br><span class="line"><span class="bullet">-</span> [x] 完成任务</span><br><span class="line"></span><br><span class="line"><span class="section">## 创建一个表格</span></span><br><span class="line"></span><br><span class="line">一个简单的表格是这么创建的：</span><br><span class="line"></span><br><span class="line">| 项目 | Value |</span><br><span class="line">| ---- | ----- |</span><br><span class="line">| 电脑 | $1600 |</span><br><span class="line">| 手机 | $12   |</span><br><span class="line">| 导管 | $1    |</span><br><span class="line"></span><br><span class="line"><span class="section">### 设定内容居中、居左、居右</span></span><br><span class="line"></span><br><span class="line">使用<span class="code">`:---------:`</span>居中</span><br><span class="line">使用<span class="code">`:----------`</span>居左</span><br><span class="line">使用<span class="code">`----------:`</span>居右</span><br><span class="line"></span><br><span class="line">|     第一列     |         第二列 | 第三列         |</span><br><span class="line">| :------------: | -------------: | :------------- |</span><br><span class="line">| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |</span><br><span class="line"></span><br><span class="line"><span class="section">### SmartyPants</span></span><br><span class="line"></span><br><span class="line">SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</span><br><span class="line">|    TYPE   |ASCII                          |HTML</span><br><span class="line">|----------------|-------------------------------|-----------------------------|</span><br><span class="line">|Single backticks|<span class="code">`&#x27;Isn&#x27;t this fun?&#x27;`</span>            |&#x27;Isn&#x27;t this fun?&#x27;            |</span><br><span class="line">|Quotes          |<span class="code">`&quot;Isn&#x27;t this fun?&quot;`</span>            |&quot;Isn&#x27;t this fun?&quot;            |</span><br><span class="line">|Dashes          |<span class="code">`-- is en-dash, --- is em-dash`</span>|-- is en-dash, --- is em-dash|</span><br><span class="line"></span><br><span class="line"><span class="section">## 创建一个自定义列表</span></span><br><span class="line"></span><br><span class="line">Markdown</span><br><span class="line">:  Text-to-HTML conversion tool</span><br><span class="line"></span><br><span class="line">Authors</span><br><span class="line">:  John</span><br><span class="line">:  Luke</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何创建一个注脚</span></span><br><span class="line"></span><br><span class="line">一个具有注脚的文本。[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">注脚的解释</span></span><br><span class="line"></span><br><span class="line"><span class="section">##  注释也是必不可少的</span></span><br><span class="line"></span><br><span class="line">Markdown将文本转换为 HTML。</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*[HTML]:   超文本标记语言</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## KaTeX数学公式</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">您可以使用渲染LaTeX数学表达式 [<span class="string">KaTeX</span>](<span class="link">https://khan.github.io/KaTeX/</span>):</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall</span></span><br><span class="line"><span class="emphasis">n\in\mathbb N$ 是通过欧拉积分</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">$$</span></span><br><span class="line"><span class="emphasis">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&gt; 你可以找到更多关于的信息 <span class="strong">**LaTeX**</span> 数学表达式[<span class="string">here</span>][<span class="symbol">1</span>].</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## 新的甘特图功能，丰富你的文章</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">gantt</span></span><br><span class="line"><span class="emphasis">        dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="emphasis">        title Adding GANTT diagram functionality to mermaid</span></span><br><span class="line"><span class="emphasis">        section 现有任务</span></span><br><span class="line"><span class="emphasis">        已完成               :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="emphasis">        进行中               :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="emphasis">        计划一               :         des3, after des2, 5d</span></span><br><span class="line"><span class="emphasis">        计划二               :         des4, after des3, 5d</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**甘特图**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">2</span>],</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## UML 图表</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">可以使用UML图表进行渲染。 [<span class="string">Mermaid</span>](<span class="link">https://mermaidjs.github.io/</span>). 例如下面产生的一个序列图：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">sequenceDiagram</span></span><br><span class="line"><span class="emphasis">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span></span><br><span class="line"><span class="emphasis">李四--&gt;&gt;王五: 你最近怎么样，王五？</span></span><br><span class="line"><span class="emphasis">李四--x 张三: 我很好，谢谢!</span></span><br><span class="line"><span class="emphasis">李四-x 王五: 我很好，谢谢!</span></span><br><span class="line"><span class="emphasis">Note right of 王五: 李四想了很长时间, 文字太长了<span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>不适合放在一行.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">李四--&gt;&gt;张三: 打量着王五...</span></span><br><span class="line"><span class="emphasis">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">这将产生一个流程图。:</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">graph LR</span></span><br><span class="line"><span class="emphasis">A[长方形] -- 链接 --&gt; B((圆))</span></span><br><span class="line"><span class="emphasis">A --&gt; C(圆角长方形)</span></span><br><span class="line"><span class="emphasis">B --&gt; D&#123;菱形&#125;</span></span><br><span class="line"><span class="emphasis">C --&gt; D</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**Mermaid**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">3</span>],</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## FLowchart流程图</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">我们依旧会支持flowchart的流程图：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">flowchat</span></span><br><span class="line"><span class="emphasis">st=&gt;start: 开始</span></span><br><span class="line"><span class="emphasis">e=&gt;end: 结束</span></span><br><span class="line"><span class="emphasis">op=&gt;operation: 我的操作</span></span><br><span class="line"><span class="emphasis">cond=&gt;condition: 确认？</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">st-&gt;op-&gt;cond</span></span><br><span class="line"><span class="emphasis">cond(yes)-&gt;e</span></span><br><span class="line"><span class="emphasis">cond(no)-&gt;op</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**Flowchart流程图**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">4</span>].</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## 导出与导入</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">###  导出</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <span class="strong">**文章导出**</span> ，生成一个.md文件或者.html文件进行本地保存。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">### 导入</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，</span></span><br><span class="line"><span class="emphasis">继续你的创作。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">[1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference</span></span><br><span class="line"><span class="emphasis">[2]: https://mermaidjs.github.io/</span></span><br><span class="line"><span class="emphasis">[3]: https://mermaidjs.github.io/</span></span><br><span class="line"><span class="emphasis">[4]: http://adrai.github.io/flowchart.js/</span></span><br></pre></td></tr></table></figure>
<h2 id="二、使用-Typora"><a href="#二、使用-Typora" class="headerlink" title="二、使用 Typora"></a>二、使用 Typora</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Typora 是一款支持实时预览的 Markdown 文本编辑器，现在支持有 OS X、Windows、Linux 三个平台的版本。其实像 Pycharm 等 IDE 也支持 md 语法，不过大都是左侧显示源码，右侧显示效果，或者只显示源码/效果，包括 CSDN 的在线 Markdown 编辑器也是这样。而Typora 创新的提出实时预览这种方式，源码和显示效果合一显示，所见即所得，非常的方便。</p>
<p>为什么要用 Typora ？就和你为什么用 jetbrains 全家桶写代码一样，因为它们漂亮、简洁、强大。</p>
<p>这些特点在它的官网(<a href="https://typora.io/">Typora</a>)就能看出来。直接拉到页面最后，下载对应版本安装就可以了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109193749369.png" alt="image-20210109193749369"></p>
<p>网上有很多介绍的 Typora 的文章，推荐两篇写的很详细的文章。</p>
<p>深度介绍(必看)：<a href="https://sspai.com/post/54912">少数派:Typora 完全使用详解</a></p>
<p>快捷键介绍：<a href="https://www.cnblogs.com/hider/p/11614688.html">Typora入门</a></p>
<p>设置：**</p>
<h3 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h3><p>下面介绍几个我觉得很有用很方便的设置。</p>
<p>打开<code>文件</code> –&gt; <code>偏好设置</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109230837590.png" alt="image-20210109230837590"></p>
<h4 id="1-打开自动保存"><a href="#1-打开自动保存" class="headerlink" title="1. 打开自动保存"></a>1. 打开自动保存</h4><p>选择<code>通用</code>，勾选 <code>自动保存</code>。这样软件会定期自动保存我们的编辑内容，防止异常退出时忘记保存。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109231108977.png" alt="image-20210109231108977"></p>
<h4 id="2-打开成对符号"><a href="#2-打开成对符号" class="headerlink" title="2. 打开成对符号"></a>2. 打开成对符号</h4><p>选择<code>编辑器</code>，勾选 <code>匹配括号和引号</code>和<code>匹配 Markdown 字符</code>。这样当我们输入括号(<code>[]()&#123;&#125;</code>)等成对的符号时，只需要输入左边一半，软件会自动补充右边一半。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109231716512.png" alt="image-20210109231716512"></p>
<h4 id="3-打开首行缩进"><a href="#3-打开首行缩进" class="headerlink" title="3. 打开首行缩进"></a>3. 打开首行缩进</h4><p>选择<code>Markdown</code>，勾选 <code>首行缩进</code>。这个看自己需要，只是在 Typora 本地显示中首行缩进，因为 Markdown 语法本身并没有支持首行缩进的符号，所以文件拿到别的地方不会有首行缩进的效果。如果非要首行缩进，可以在段落开头加个<code>&amp;emsp;&amp;emsp;</code>可以在其他地方打开时也能首行缩进。这个仁者见仁，智者见智，开始我是很喜欢首行缩进的，后来发现不缩进也挺好看的，现在已经习惯了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109232158103.png" alt="image-20210109232158103"></p>
<h4 id="4-打开自动保存图片"><a href="#4-打开自动保存图片" class="headerlink" title="4. 打开自动保存图片"></a>4. 打开自动保存图片</h4><p>选择<code>图像</code>，选择<code>插入图片时...</code>自动执行的动作：</p>
<ul>
<li>默认是<code>无特殊操作</code>，当你写文章时，粘贴或者拖动进来的图片会自动保存在<code>C:\Users\&lt;电脑用户名&gt;\AppData\Roaming\Typora\typora-user-images</code>目录下。</li>
<li><code>复制图片到当前文件夹</code>，选择该选项时，粘贴或者拖动进来的图片会自动保存在当前编辑的文件同目录下。</li>
<li><code>复制图片到 ./$&#123;filename&#125;.assets 文件夹</code>，选择该选项时，粘贴或者拖动图片进来，会自动在当前编辑的文件目录下新建文件夹<code>$&#123;filename&#125;.assets</code>并将图片复制到该文件夹下，其中``${filename}<code>是当前编辑的文件名，不包含</code>.md`。</li>
<li><code>上传图片</code>，选择该选项时，粘贴或者拖动图片进来，会根据下面的<code>上传服务设置</code>将图片自动上传到图床，平时最好用这个设置，详细内容在下一篇文章中介绍。</li>
<li><code>复制到指定路经</code>，选择该选项时，可以自己填入一个文件夹，粘贴或者拖动图片进来，会自动创建文件夹并将图片复制进去。</li>
</ul>
<p>建议选择<code>上传图片</code>，按照下篇文章的方法将图片保存在图床。当然，如果写的的文章只保存在本地或者需要断网时浏览，那么可以选择其他几个选项。我有一次手贱把图片文件夹删了，辛苦几天截得图片和录的 GIF 全没了，经过这次教训，我感觉还是上传到图床比较保险，可惜不能同时选择保存到本地和上传图床。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109233120920.png" alt="image-20210109233120920"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>现在我们可以先在本地写好博客，然后按照前两篇文章的方法将它们发布到网站上了。不过还不够完美，我们一直没说带图片的文章要怎么处理，其实 Hexo 本身支持将图片打包发布，需要新建博客时创建对应的图片文件夹，有点麻烦就不介绍了。我们既然已经用了 Markdown 格式，图片在 Markdown 文件里不过就是一个路径或者网址，为什么不用更简便的方法呢？接下来第五篇文章，就介绍怎么搭建自己的免费图床并搭配 Typora 使用。</p>
<p>相信我，用上了 Markdown和 Typora ，你会爱上写博客的。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（三）—— pprint模块</title>
    <url>/2020/12/11/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20pprint%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/109100139">https://blog.csdn.net/yushuaigee/article/details/109100139</a></p>
</blockquote>
<p> </p>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#%E7%AC%AC1~22%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E6%95%B4%E4%BD%93%E6%B3%A8%E9%87%8A%E3%80%81nt%E4%B8%8Eposix">模块整体注释</a></p>
</li>
<li><p><a href="#%E7%AC%AC37~44%E8%A1%8C%20%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E3%80%81%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%8E%A5%E5%8F%A3">依赖模块导入、对外暴露接口</a></p>
</li>
<li><p><a href="#saferepr%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%EF%BC%8C%E5%B9%B6%E4%B8%BA%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%90%E4%BE%9B%E4%BF%9D%E6%8A%A4">saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护</a></p>
</li>
<li><p><a href="#isreadable%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%98%AF%E5%90%A6%E2%80%9C%E5%8F%AF%E8%AF%BB%E2%80%9D">isreadable函数——返回对象的是否“可读”</a></p>
</li>
<li><p><a href="#isrecursive%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84">isrecursive函数——返回对象的是否是无限递归结构</a></p>
</li>
<li><p><a href="#PrettyPrinter%E2%80%94%E2%80%94%E4%BC%98%E9%9B%85%E6%A0%BC%E5%BC%8F%E5%8C%96Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB">PrettyPrinter——优雅格式化Python对象的类</a></p>
</li>
<li><p><a href="#pprint%E2%80%94%E2%80%94%E6%9B%B4%E6%96%B9%E4%BE%BF%E6%9B%B4%E7%BE%8E%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0">pprint——更方便更美观地打印</a></p>
</li>
<li><p><a href="#pformat%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0%E5%99%A8">pformat——格式化字符串构造器</a></p>
</li>
<li><p><a href="#pp%E2%80%94%E2%80%94%E5%90%8Cpprint">pp——同pprint</a></p>
</li>
</ul>
<p><code>print</code> 模块能够美观地对数据结构进行格式化。不仅可以由解释器正确地解析，而且便于人类阅读。输出尽可能地保持在一行，需要分拆到多行时会有缩进表示。 </p>
<p>想象一下，你有下面这么一串 json (这个是我随机生成的)需要打印出来，或者调试程序的时候需要看一下 json 中某个字段的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201015163424822.png" alt="20201015163424822.png"></p>
<p> 用 <code>print()</code> 打印出来回事这么一坨，根本没有可读性：</p>
<blockquote>
<p> {‘_id’: ‘5f8808d57ac946ae591e8929’, ‘index’: 0, ‘guid’: ‘b41b3b14-1ae2-4cc4-b443-105bda03f4f0’, ‘isActive’: True, ‘balance’: ‘$1,985.20’, ‘picture’: ‘<a href="http://placehold.it/32x32&#39;">http://placehold.it/32x32&#39;</a>, ‘age’: 37, ‘eyeColor’: ‘brown’, ‘name’: ‘Alexandra Atkins’, ‘gender’: ‘female’, ‘company’: ‘COSMETEX’, ‘email’: ‘alexandraatkins@cosmetex.com’, ‘phone’: ‘+1 (999) 588-3661’, ‘address’: ‘779 Beayer Place, Belvoir, Washington, 5395’, ‘about’: ‘Laborum Lorem labore sint excepteur ad do esse veniam sunt cillum. Magna ipsum id aliqua consequat. Commodo enim occaecat pariatur ullamco irure incididunt et incididunt. Dolor aliqua eiusmod id laboris non laborum aliqua sunt occaecat eu commodo elit consequat. In mollit aute ullamco officia exercitation eiusmod ea labore id magna adipisicing.\r\n’, ‘registered’: ‘2018-12-29T09:52:41 -08:00’, ‘latitude’: 66.079339, ‘longitude’: 68.156168, ‘tags’: [‘mollit’, ‘velit’, ‘do’, ‘velit’, ‘Lorem’, ‘qui’, ‘irure’], ‘friends’: [{‘id’: 0, ‘name’: ‘Latonya Pena’}, {‘id’: 1, ‘name’: ‘Marion Ayers’}, {‘id’: 2, ‘name’: ‘Bishop Day’}], ‘greeting’: ‘Hello, Alexandra Atkins! You have 3 unread messages.’, ‘favoriteFruit’: ‘banana’} </p>
</blockquote>
<p> 在IDE中调试时，可能打印出来变成了一眼看不到头的一行，然后你就需要拖着进度条一个字段一个字段去找。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201015164001779.png" alt="20201015164001779"></p>
<p> 而用 <code>pprint()</code> 打印出来会自动变成这样美观可读的格式，这就是 <code>pprint </code>库的作用：</p>
<p><img src="C:/Users/LAOGE/Desktop/20201015165529216.png" alt="20201015165529216"></p>
<p> <code>pprint </code>模块主要包含 “<code>pprint</code>“,”<code>pformat</code>“,”<code>isreadable</code>“,”<code>isrecursive</code>“,”<code>saferepr</code>“, “<code>pp</code>“ 方法和一个类“<code>PrettyPrinter</code>“，其中核心是 <code>PrettyPrinter </code>类，其他方法都是调用的这个类。以下文章中的行数是与我所用的3.8.4版本 <code>pprint.py</code> 文件真实的行数对应的。</p>
<h3 id="模块整体注释"><a href="#模块整体注释" class="headerlink" title="模块整体注释"></a>模块整体注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Author:      Fred L. Drake, Jr.</span></span><br><span class="line"><span class="comment">#               fdrake@acm.org</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This is a simple little module I wrote to make life easier.  I didn&#x27;t</span></span><br><span class="line"><span class="comment">#  see anything quite like it in the library, though I may have overlooked</span></span><br><span class="line"><span class="comment">#  something.  I wrote this when I was trying to read some heavily nested</span></span><br><span class="line"><span class="comment">#  tuples with fairly non-descriptive content.  This is modeled very much</span></span><br><span class="line"><span class="comment">#  after Lisp/Scheme - style pretty-printing of lists.  If you find it</span></span><br><span class="line"><span class="comment">#  useful, thank small children who sleep at night.</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Support to pretty-print lists, tuples, &amp;amp; dictionaries recursively.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Very simple, but useful, especially in debugging data structures.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Classes</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">PrettyPrinter()</span></span><br><span class="line"><span class="string">    Handle pretty-printing operations onto a stream using a configured</span></span><br><span class="line"><span class="string">    set of formatting parameters.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Functions</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pformat()</span></span><br><span class="line"><span class="string">    Format a Python object into a pretty-printed representation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pprint()</span></span><br><span class="line"><span class="string">    Pretty-print a Python object to a stream [default is sys.stdout].</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">saferepr()</span></span><br><span class="line"><span class="string">    Generate a &#x27;standard&#x27; repr()-like value, but protect against recursive</span></span><br><span class="line"><span class="string">    data structures.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>模块作者**Fred L. Drake, Jr.**是 PythonLabs 团队的成员，自1995年以来一直在为 Python 做出贡献，许多原始 Python 文档都是他贡献的。下面是他说的话：这是我为了让生活更容易写的一个简单的小模块。我之前没有在 Python 库中看到有类似功能的模块，可能有我没注意到吧。我写这篇文章时，我正在试图读一些嵌套很繁琐的元组，可读性非常差。这个模块仿效Lisp/Scheme（一种编程语言）风格将列表打印的更美观。如果你觉得有用，感谢那些晚上睡觉的孩子们吧（我估计作者的意思是他家孩子晚上睡觉很乖，没打扰他用晚上的业余时间写这个模块，hh）。</p>
<p>支持递归地的将列表、元组、字典优雅地打印出来，非常简单好用，尤其是调试数据的时候。</p>
<ul>
<li>类 <code>PrettyPrinter</code>，作用是根据传入的参数将输入流优雅地打印出来。</li>
<li>方法 <code>format </code>，作用是将 Python 对象格式化成优雅的表现形式。</li>
<li>方法 <code>pprint</code>，作用是将 Python 对象优雅地打印出来。（这个最常用，其实我写这篇博客之前只用过这个库这一个方法。。。）</li>
<li>方法<code>saferepr</code>，作用是返回 object 的字符串表示，并为递归数据结构提供保护。这个怎么理解具体见后面<code>safe_repr()</code>分析。</li>
</ul>
<h3 id="依赖模块导入、对外暴露接口"><a href="#依赖模块导入、对外暴露接口" class="headerlink" title="依赖模块导入、对外暴露接口"></a>依赖模块导入、对外暴露接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="keyword">as</span> _collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys <span class="keyword">as</span> _sys</span><br><span class="line"><span class="keyword">import</span> types <span class="keyword">as</span> _types</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO <span class="keyword">as</span> _StringIO</span><br><span class="line"> </span><br><span class="line">__all__ = [<span class="string">&quot;pprint&quot;</span>,<span class="string">&quot;pformat&quot;</span>,<span class="string">&quot;isreadable&quot;</span>,<span class="string">&quot;isrecursive&quot;</span>,<span class="string">&quot;saferepr&quot;</span>,</span><br><span class="line">           <span class="string">&quot;PrettyPrinter&quot;</span>, <span class="string">&quot;pp&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>collections </code>是Python内建的一个集合模块，提供了许多有用的集合类，像 <code>Deque</code>、<code>Counter</code>等。<code>re </code>是Python自带的标准库提供对正则表达式的支持。<code>sys </code>是一个C实现的内置模块，主要是实现Python解释器、操作系统相关的操作。<code>types </code>定义了一些工具函数，用于协助动态创建新的类型。<code>io</code>提供了 Python 用于处理各种 I/O 类型的主要工具。三种主要的 I/O类型分别为: <em>文本 I/O</em>, <em>二进制 I/O</em> 和 <em>原始 I/O，</em>此处引入的 <code>StringIO </code>即是文本 I/O。<code>pprint </code>库对外暴露的只有<code>pprint</code>、<code>pformat</code>、<code>isreadable</code>、<code>isrecursive</code>、<code>saferepr</code>、<code>PrettyPrinter</code>、<code>pp </code>这几个属性。</p>
<h3 id="saferepr-函数——返回对象的字符串表示，并为无限递归数据结构提供保护"><a href="#saferepr-函数——返回对象的字符串表示，并为无限递归数据结构提供保护" class="headerlink" title="saferepr 函数——返回对象的字符串表示，并为无限递归数据结构提供保护"></a>saferepr 函数——返回对象的字符串表示，并为无限递归数据结构提供保护</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saferepr</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Version of repr() which can handle recursive data structures.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, &#123;&#125;, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>第 65 ~ 67 行， <code>saferepr </code>函数，通过递归调用 <code>_safe_repr</code> 方法，返回传入对象的的字符串表示，类似<code> repr()</code> 和 <code>str() </code>方法（<a href="https://blog.csdn.net/kongsuhongbaby/article/details/87398394">str()、repr()的区别</a>），不同的地方是这个函数对于无限递归的数据结构提供了保护。 如果传入的object包含一个无限递归的数据结构，该递归数据结构会被表示为 <code>&lt;Recursion on typename with id=number&gt;</code>。 </p>
<p>什么是无限递归数据结构？类似下面这种，一个数组包含了它自己，你要是想将它完整打印出来肯定会有问题，下图中结果说明内置的 <code>repr()</code> 和 <code>str()</code> 方法对无限递归数据结构也做了保护，会转换成 <code>[...]</code>，而 <code>saferepr </code>函数将其转化为了字符串 <code>&lt;Recursion on typename with id=number&gt;</code>，包含了对象的类型和id。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201210185221469.png" alt="20201210185221469"></p>
<h3 id="isreadable-函数——返回对象的是否“可读”"><a href="#isreadable-函数——返回对象的是否“可读”" class="headerlink" title="isreadable 函数——返回对象的是否“可读”"></a>isreadable 函数——返回对象的是否“可读”</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isreadable</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Determine if saferepr(object) is readable by eval().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, &#123;&#125;, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">True</span>)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>第69~71行，这里的“可读”的意思是说，该对象是否可被用来通过<code> eval()</code> 重新构建对象的值。一般是判断是否一个字符串是否可以用 <code>eval()</code> 转换成python对象，此函数对于递归对象总是返回 False。</p>
<h3 id="isrecursive-函数——返回对象的是否是无限递归结构"><a href="#isrecursive-函数——返回对象的是否是无限递归结构" class="headerlink" title="isrecursive 函数——返回对象的是否是无限递归结构"></a>isrecursive 函数——返回对象的是否是无限递归结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isrecursive</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Determine if object requires a recursive representation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, &#123;&#125;, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">True</span>)[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>第 73~75行， 判断传入的对象是否是无限递归结构。</p>
<h3 id="PrettyPrinter——优雅格式化Python对象的类"><a href="#PrettyPrinter——优雅格式化Python对象的类" class="headerlink" title="PrettyPrinter——优雅格式化Python对象的类"></a>PrettyPrinter——优雅格式化Python对象的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyPrinter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, indent=<span class="number">1</span>, width=<span class="number">80</span>, depth=<span class="literal">None</span>, stream=<span class="literal">None</span>, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                 compact=<span class="literal">False</span>, sort_dicts=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Handle pretty printing operations onto a stream using a set of</span></span><br><span class="line"><span class="string">        configured parameters.</span></span><br><span class="line"><span class="string">        indent</span></span><br><span class="line"><span class="string">            Number of spaces to indent for each level of nesting.</span></span><br><span class="line"><span class="string">        width</span></span><br><span class="line"><span class="string">            Attempted maximum number of columns in the output.</span></span><br><span class="line"><span class="string">        depth</span></span><br><span class="line"><span class="string">            The maximum depth to print out nested structures.</span></span><br><span class="line"><span class="string">        stream</span></span><br><span class="line"><span class="string">            The desired output stream.  If omitted (or false), the standard</span></span><br><span class="line"><span class="string">            output stream available at construction will be used.</span></span><br><span class="line"><span class="string">        compact</span></span><br><span class="line"><span class="string">            If true, several items will be combined in one line.</span></span><br><span class="line"><span class="string">        sort_dicts</span></span><br><span class="line"><span class="string">            If true, dict keys are sorted.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        indent = <span class="built_in">int</span>(indent)</span><br><span class="line">        width = <span class="built_in">int</span>(width)</span><br><span class="line">        <span class="keyword">if</span> indent &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;indent must be &gt;= 0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> depth &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;depth must be &gt; 0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> width:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;width must be != 0&#x27;</span>)</span><br><span class="line">        self._depth = depth</span><br><span class="line">        self._indent_per_level = indent</span><br><span class="line">        self._width = width</span><br><span class="line">        <span class="keyword">if</span> stream <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._stream = stream</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._stream = _sys.stdout</span><br><span class="line">        self._compact = <span class="built_in">bool</span>(compact)</span><br><span class="line">        self._sort_dicts = sort_dicts</span><br></pre></td></tr></table></figure>
<p>第104~145行，初始化函数，入参的处理和解析。</p>
<ul>
<li><strong>indent：</strong>每个嵌套级别要缩进的空格数，即第 1 层缩进 <strong>indent</strong> 个字符，第 2 层缩进 2 *  <strong>indent</strong> 个字符，默认值 1。</li>
<li><strong>width：</strong> 输出的字符的最大宽度，默认值 80。</li>
<li><strong>depth：</strong> 打印嵌套结构的最大深度，超过这个深度不再换行，默认None表示不限制。</li>
<li><strong>stream：</strong> 所需的输出流。如果省略（或False），将使用标准输出流，即<code> sys.stdout</code> ，这个和 <code>print()</code>一样。</li>
<li>*** ：** keyword-only参数标志，不占参数位置，详见我的另一篇博客 <a href="https://blog.csdn.net/yushuaigee/article/details/107567001">彻底弄懂 Python3中入参里的*号的作用</a> 第5节。</li>
<li><strong>compact：</strong> 如果为True，则多个元素将合并为一行，不会打印换行符，<strong>width</strong> 参数依然生效，默认为 False。</li>
<li><strong>sort_dicts：</strong> 字典打印前是否排序，如果为 True，则打印前根据 key 进行排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprint</span>(<span class="params">self, <span class="built_in">object</span></span>):</span></span><br><span class="line">    self._format(<span class="built_in">object</span>, self._stream, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    self._stream.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第147~149行，<code>pprint(self, object)</code> 函数，我们平时用的最多的 <code>from pprint import pprint</code> 最终也是调用的这个方法。这个方法先调用 <strong>self._format()</strong> 方法，再调用对象的输出流输出一个换行。<strong>这里面的函数层层调用有点多，需要一步一步看。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _format(self, object, stream, indent, allowance, context, level):</span><br><span class="line">    objid &#x3D; id(object)</span><br><span class="line">    if objid in context:</span><br><span class="line">        stream.write(_recursion(object))</span><br><span class="line">        self._recursive &#x3D; True</span><br><span class="line">        self._readable &#x3D; False</span><br><span class="line">        return</span><br><span class="line">    rep &#x3D; self._repr(object, context, level)</span><br><span class="line">    max_width &#x3D; self._width - indent - allowance</span><br><span class="line">    if len(rep) &gt; max_width:</span><br><span class="line">        p &#x3D; self._dispatch.get(type(object).__repr__, None)</span><br><span class="line">        if p is not None:</span><br><span class="line">            context[objid] &#x3D; 1</span><br><span class="line">            p(self, object, stream, indent, allowance, context, level + 1)</span><br><span class="line">            del context[objid]</span><br><span class="line">            return</span><br><span class="line">        elif isinstance(object, dict):</span><br><span class="line">            context[objid] &#x3D; 1</span><br><span class="line">            self._pprint_dict(object, stream, indent, allowance,</span><br><span class="line">                              context, level + 1)</span><br><span class="line">            del context[objid]</span><br><span class="line">            return</span><br><span class="line">    stream.write(rep)</span><br></pre></td></tr></table></figure>
<p>第163~185行的 <strong>self._format()</strong> 方法，这是 <strong>PrettyPrinter</strong> 这个类一个比较核心的递归调用方法。 </p>
<p>入参解析：</p>
<ul>
<li><strong>object：</strong> 需要被格式化的对象。就是要打印的对象。</li>
<li><strong>stream：</strong>所需的输出流。。</li>
<li><strong>indent：</strong>每个嵌套级别要缩进的空格数。</li>
<li><strong>allowance：</strong>额外补偿的缩进空格数。会根据前面的 <strong>width</strong> 和这里的 <strong>allowance，indent</strong> 决定什么时候换行。</li>
<li><strong>context：</strong>以对象的id为键的字典，这些对象是当前表示上下文的一部分。</li>
<li><strong>level：</strong>打印嵌套结构的最大深度，超过这个深度不再换行。</li>
</ul>
<p>第164<del>169行，获取对象的 <strong>id</strong>，如果<strong>object</strong>的 <strong>id</strong> 在 <strong>context</strong> 中，就打印 <strong>_recursion(object)</strong> ，<strong>_recursion()</strong> 在文件第575</del>577行，是个类外的函数，作用是返回对象的类型名字和 id：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;&lt;Recursion on %s with id=%s&gt;&quot;</span></span><br><span class="line">            % (<span class="built_in">type</span>(<span class="built_in">object</span>).__name__, <span class="built_in">id</span>(<span class="built_in">object</span>)))</span><br></pre></td></tr></table></figure>
<p>第170行，<strong>self._repr()</strong> 函数在 <strong>PrettyPrinter</strong> 类内的第403~410行，这里又调用了 <strong>self.format()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_repr</span>(<span class="params">self, <span class="built_in">object</span>, context, level</span>):</span></span><br><span class="line">    <span class="built_in">repr</span>, readable, recursive = self.<span class="built_in">format</span>(<span class="built_in">object</span>, context.copy(),</span><br><span class="line">                                            self._depth, level)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> readable:</span><br><span class="line">        self._readable = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> recursive:</span><br><span class="line">        self._recursive = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">repr</span></span><br></pre></td></tr></table></figure>
<p><strong>self.format()</strong> 在类内的第412~417行，这里又调用了 **_safe_repr()**。注释是说本方法将对象格式化为一个具体的文本，返回一个字符串、是否“可读”、是否无限递归结构。和前面的saferepr函数是一样的，只是saferepr函数只取了第一个返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, <span class="built_in">object</span>, context, maxlevels, level</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Format object for a specific context, returning a string</span></span><br><span class="line"><span class="string">    and flags indicating whether the representation is &#x27;readable&#x27;</span></span><br><span class="line"><span class="string">    and whether the object represents a recursive construct.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, context, maxlevels, level, self._sort_dicts)</span><br></pre></td></tr></table></figure>
<p>所以经过 <strong>rep = self._repr(object, context, level)</strong> 的层层调用，这一步已经获取到了对象的字符串形式，下一步就是按照预定的格式将它美观地打印出来。<strong>self._dispatch</strong> 是一个函数映射字典，以对象类型为键，对应的处理方法为值。<strong>p = self._dispatch.get(type(object).<strong>repr</strong>, None)</strong> 就是根据对象类型不同获取不同的处理函数。</p>
<p>下面就是各种类型的对象的具体处理函数。可以看出它不是一次性输出的，而是用 write 方法一块一块的输出，例如字典，先输出 “{”，然后递归调用fomat方法解析每一个键值对，每一个键值对先解析key输出，再解析value，最后再输出“”。这个debug一下就能直观地看出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_dispatch = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_dict</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    write = stream.write</span><br><span class="line">    write(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> self._indent_per_level &gt; <span class="number">1</span>:</span><br><span class="line">        write((self._indent_per_level - <span class="number">1</span>) * <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    length = <span class="built_in">len</span>(<span class="built_in">object</span>)</span><br><span class="line">    <span class="keyword">if</span> length:</span><br><span class="line">        <span class="keyword">if</span> self._sort_dicts:</span><br><span class="line">            items = <span class="built_in">sorted</span>(<span class="built_in">object</span>.items(), key=_safe_tuple)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items = <span class="built_in">object</span>.items()</span><br><span class="line">        self._format_dict_items(items, stream, indent, allowance + <span class="number">1</span>,</span><br><span class="line">                                context, level)</span><br><span class="line">    write(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">dict</span>.__repr__] = _pprint_dict</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_ordered_dict</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cls = <span class="built_in">object</span>.__class__</span><br><span class="line">    stream.write(cls.__name__ + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    self._format(<span class="built_in">list</span>(<span class="built_in">object</span>.items()), stream,</span><br><span class="line">                 indent + <span class="built_in">len</span>(cls.__name__) + <span class="number">1</span>, allowance + <span class="number">1</span>,</span><br><span class="line">                 context, level)</span><br><span class="line">    stream.write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.OrderedDict.__repr__] = _pprint_ordered_dict</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_list</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    stream.write(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    self._format_items(<span class="built_in">object</span>, stream, indent, allowance + <span class="number">1</span>,</span><br><span class="line">                       context, level)</span><br><span class="line">    stream.write(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">list</span>.__repr__] = _pprint_list</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_tuple</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    stream.write(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    endchar = <span class="string">&#x27;,)&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">object</span>) == <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">    self._format_items(<span class="built_in">object</span>, stream, indent, allowance + <span class="built_in">len</span>(endchar),</span><br><span class="line">                       context, level)</span><br><span class="line">    stream.write(endchar)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">tuple</span>.__repr__] = _pprint_tuple</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_set</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    typ = <span class="built_in">object</span>.__class__</span><br><span class="line">    <span class="keyword">if</span> typ <span class="keyword">is</span> <span class="built_in">set</span>:</span><br><span class="line">        stream.write(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        endchar = <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stream.write(typ.__name__ + <span class="string">&#x27;(&#123;&#x27;</span>)</span><br><span class="line">        endchar = <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">        indent += <span class="built_in">len</span>(typ.__name__) + <span class="number">1</span></span><br><span class="line">    <span class="built_in">object</span> = <span class="built_in">sorted</span>(<span class="built_in">object</span>, key=_safe_key)</span><br><span class="line">    self._format_items(<span class="built_in">object</span>, stream, indent, allowance + <span class="built_in">len</span>(endchar),</span><br><span class="line">                       context, level)</span><br><span class="line">    stream.write(endchar)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">set</span>.__repr__] = _pprint_set</span><br><span class="line">_dispatch[<span class="built_in">frozenset</span>.__repr__] = _pprint_set</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_str</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    write = stream.write</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    chunks = []</span><br><span class="line">    lines = <span class="built_in">object</span>.splitlines(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">        indent += <span class="number">1</span></span><br><span class="line">        allowance += <span class="number">1</span></span><br><span class="line">    max_width1 = max_width = self._width - indent</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">        rep = <span class="built_in">repr</span>(line)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(lines) - <span class="number">1</span>:</span><br><span class="line">            max_width1 -= allowance</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rep) &lt;= max_width1:</span><br><span class="line">            chunks.append(rep)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A list of alternating (non-space, space) strings</span></span><br><span class="line">            parts = re.findall(<span class="string">r&#x27;\S*\s*&#x27;</span>, line)</span><br><span class="line">            <span class="keyword">assert</span> parts</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> parts[-<span class="number">1</span>]</span><br><span class="line">            parts.pop()  <span class="comment"># drop empty last part</span></span><br><span class="line">            max_width2 = max_width</span><br><span class="line">            current = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> j, part <span class="keyword">in</span> <span class="built_in">enumerate</span>(parts):</span><br><span class="line">                candidate = current + part</span><br><span class="line">                <span class="keyword">if</span> j == <span class="built_in">len</span>(parts) - <span class="number">1</span> <span class="keyword">and</span> i == <span class="built_in">len</span>(lines) - <span class="number">1</span>:</span><br><span class="line">                    max_width2 -= allowance</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">repr</span>(candidate)) &gt; max_width2:</span><br><span class="line">                    <span class="keyword">if</span> current:</span><br><span class="line">                        chunks.append(<span class="built_in">repr</span>(current))</span><br><span class="line">                    current = part</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current = candidate</span><br><span class="line">            <span class="keyword">if</span> current:</span><br><span class="line">                chunks.append(<span class="built_in">repr</span>(current))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(chunks) == <span class="number">1</span>:</span><br><span class="line">        write(rep)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">        write(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, rep <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            write(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27; &#x27;</span>*indent)</span><br><span class="line">        write(rep)</span><br><span class="line">    <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">        write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">str</span>.__repr__] = _pprint_str</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_bytes</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    write = stream.write</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">object</span>) &lt;= <span class="number">4</span>:</span><br><span class="line">        write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    parens = level == <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> parens:</span><br><span class="line">        indent += <span class="number">1</span></span><br><span class="line">        allowance += <span class="number">1</span></span><br><span class="line">        write(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    delim = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> rep <span class="keyword">in</span> _wrap_bytes_repr(<span class="built_in">object</span>, self._width - indent, allowance):</span><br><span class="line">        write(delim)</span><br><span class="line">        write(rep)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> delim:</span><br><span class="line">            delim = <span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27; &#x27;</span>*indent</span><br><span class="line">    <span class="keyword">if</span> parens:</span><br><span class="line">        write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">bytes</span>.__repr__] = _pprint_bytes</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_bytearray</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    write = stream.write</span><br><span class="line">    write(<span class="string">&#x27;bytearray(&#x27;</span>)</span><br><span class="line">    self._pprint_bytes(<span class="built_in">bytes</span>(<span class="built_in">object</span>), stream, indent + <span class="number">10</span>,</span><br><span class="line">                       allowance + <span class="number">1</span>, context, level + <span class="number">1</span>)</span><br><span class="line">    write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[<span class="built_in">bytearray</span>.__repr__] = _pprint_bytearray</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_mappingproxy</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    stream.write(<span class="string">&#x27;mappingproxy(&#x27;</span>)</span><br><span class="line">    self._format(<span class="built_in">object</span>.copy(), stream, indent + <span class="number">13</span>, allowance + <span class="number">1</span>,</span><br><span class="line">                 context, level)</span><br><span class="line">    stream.write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_types.MappingProxyType.__repr__] = _pprint_mappingproxy</span><br><span class="line"> </span><br><span class="line"><span class="comment">#......</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_default_dict</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    rdf = self._repr(<span class="built_in">object</span>.default_factory, context, level)</span><br><span class="line">    cls = <span class="built_in">object</span>.__class__</span><br><span class="line">    indent += <span class="built_in">len</span>(cls.__name__) + <span class="number">1</span></span><br><span class="line">    stream.write(<span class="string">&#x27;%s(%s,\n%s&#x27;</span> % (cls.__name__, rdf, <span class="string">&#x27; &#x27;</span> * indent))</span><br><span class="line">    self._pprint_dict(<span class="built_in">object</span>, stream, indent, allowance + <span class="number">1</span>, context, level)</span><br><span class="line">    stream.write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.defaultdict.__repr__] = _pprint_default_dict</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_counter</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cls = <span class="built_in">object</span>.__class__</span><br><span class="line">    stream.write(cls.__name__ + <span class="string">&#x27;(&#123;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> self._indent_per_level &gt; <span class="number">1</span>:</span><br><span class="line">        stream.write((self._indent_per_level - <span class="number">1</span>) * <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    items = <span class="built_in">object</span>.most_common()</span><br><span class="line">    self._format_dict_items(items, stream,</span><br><span class="line">                            indent + <span class="built_in">len</span>(cls.__name__) + <span class="number">1</span>, allowance + <span class="number">2</span>,</span><br><span class="line">                            context, level)</span><br><span class="line">    stream.write(<span class="string">&#x27;&#125;)&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.Counter.__repr__] = _pprint_counter</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_chain_map</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>.maps):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cls = <span class="built_in">object</span>.__class__</span><br><span class="line">    stream.write(cls.__name__ + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    indent += <span class="built_in">len</span>(cls.__name__) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">object</span>.maps):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(<span class="built_in">object</span>.maps) - <span class="number">1</span>:</span><br><span class="line">            self._format(m, stream, indent, allowance + <span class="number">1</span>, context, level)</span><br><span class="line">            stream.write(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._format(m, stream, indent, <span class="number">1</span>, context, level)</span><br><span class="line">            stream.write(<span class="string">&#x27;,\n&#x27;</span> + <span class="string">&#x27; &#x27;</span> * indent)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.ChainMap.__repr__] = _pprint_chain_map</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_deque</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(<span class="built_in">object</span>):</span><br><span class="line">        stream.write(<span class="built_in">repr</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cls = <span class="built_in">object</span>.__class__</span><br><span class="line">    stream.write(cls.__name__ + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    indent += <span class="built_in">len</span>(cls.__name__) + <span class="number">1</span></span><br><span class="line">    stream.write(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">object</span>.maxlen <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._format_items(<span class="built_in">object</span>, stream, indent, allowance + <span class="number">2</span>,</span><br><span class="line">                           context, level)</span><br><span class="line">        stream.write(<span class="string">&#x27;])&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._format_items(<span class="built_in">object</span>, stream, indent, <span class="number">2</span>,</span><br><span class="line">                           context, level)</span><br><span class="line">        rml = self._repr(<span class="built_in">object</span>.maxlen, context, level)</span><br><span class="line">        stream.write(<span class="string">&#x27;],\n%smaxlen=%s)&#x27;</span> % (<span class="string">&#x27; &#x27;</span> * indent, rml))</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.deque.__repr__] = _pprint_deque</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_user_dict</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    self._format(<span class="built_in">object</span>.data, stream, indent, allowance, context, level - <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.UserDict.__repr__] = _pprint_user_dict</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_user_list</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    self._format(<span class="built_in">object</span>.data, stream, indent, allowance, context, level - <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.UserList.__repr__] = _pprint_user_list</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pprint_user_string</span>(<span class="params">self, <span class="built_in">object</span>, stream, indent, allowance, context, level</span>):</span></span><br><span class="line">    self._format(<span class="built_in">object</span>.data, stream, indent, allowance, context, level - <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">_dispatch[_collections.UserString.__repr__] = _pprint_user_string</span><br></pre></td></tr></table></figure>
<h3 id="pprint-——更方便更美观地打印"><a href="#pprint-——更方便更美观地打印" class="headerlink" title="pprint ——更方便更美观地打印"></a>pprint ——更方便更美观地打印</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprint</span>(<span class="params"><span class="built_in">object</span>, stream=<span class="literal">None</span>, indent=<span class="number">1</span>, width=<span class="number">80</span>, depth=<span class="literal">None</span>, *,</span></span></span><br><span class="line"><span class="function"><span class="params">           compact=<span class="literal">False</span>, sort_dicts=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pretty-print a Python object to a stream [default is sys.stdout].&quot;&quot;&quot;</span></span><br><span class="line">    printer = PrettyPrinter(</span><br><span class="line">        stream=stream, indent=indent, width=width, depth=depth,</span><br><span class="line">        compact=compact, sort_dicts=sort_dicts)</span><br><span class="line">    printer.pprint(<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>看明白了 <code>PrettyPrinter </code>类和它的 <code>pprint </code>方法，后面这些就很好理解了。这个<code>pprint</code>方法是实例化一个<code>PrettyPrinter</code>对象并调用对象的<code>pprint</code>方法。这样我们在使用时只需要<code> from pprint import pprint</code>，然后<code>pprint(xxx)</code>就行了，不必每次初始化一个对象再调用<code>pprint</code>方法。</p>
<h3 id="pformat-——格式化字符串构造器"><a href="#pformat-——格式化字符串构造器" class="headerlink" title="pformat ——格式化字符串构造器"></a>pformat ——格式化字符串构造器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pformat</span>(<span class="params"><span class="built_in">object</span>, indent=<span class="number">1</span>, width=<span class="number">80</span>, depth=<span class="literal">None</span>, *,</span></span></span><br><span class="line"><span class="function"><span class="params">            compact=<span class="literal">False</span>, sort_dicts=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Format a Python object into a pretty-printed representation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> PrettyPrinter(indent=indent, width=width, depth=depth,</span><br><span class="line">                         compact=compact, sort_dicts=sort_dicts).pformat(<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def pformat(self, object):</span><br><span class="line">    sio &#x3D; _StringIO()</span><br><span class="line">    self._format(object, sio, 0, 0, &#123;&#125;, 0)</span><br><span class="line">    return sio.getvalue()</span><br></pre></td></tr></table></figure>
<p>这个也是为了方便调用，实例化一个<code>PrettyPrinter </code>对象并返回对象的 <code>pformat </code>方法。pprint 是直接将格式化后的字符串打印出来，<code>pformat</code>是构造好字符串但是不打印出来。也就是说 <code>pprint(test_data)</code> 和 <code>print(pformat(test_data))</code> 是等效的。</p>
<h3 id="pp-——同-pprint"><a href="#pp-——同-pprint" class="headerlink" title="pp ——同 pprint"></a>pp ——同 pprint</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pp</span>(<span class="params"><span class="built_in">object</span>, *args, sort_dicts=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pretty-print a Python object&quot;&quot;&quot;</span></span><br><span class="line">    pprint(<span class="built_in">object</span>, *args, sort_dicts=sort_dicts, **kwargs)</span><br></pre></td></tr></table></figure>
<p>原来和<code>pprint</code>是一样的，看来以后只需要<code> from pprint import pp</code> 了。欧耶，没白看。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pprint</tag>
        <tag>Python标准库</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python实现一个软件自动升级系统</title>
    <url>/2020/04/25/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/105140425">https://blog.csdn.net/yushuaigee/article/details/105140425</a></p>
</blockquote>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF">一、服务端</a></p>
<ul>
<li><input disabled="" type="checkbox"> <a href="#1.%C2%A0XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1. XML配置文件</a></li>
<li><input disabled="" type="checkbox"> <a href="#%C2%A02.%C2%A0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"> 2. 服务端代码设计</a></li>
</ul>
</li>
<li><p><a href="#%E4%BA%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">二、客户端</a></p>
<ul>
<li><input disabled="" type="checkbox"> <a href="#1.%C2%A0XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1. XML配置文件</a></li>
<li><input disabled="" type="checkbox"> <a href="#2.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">2. 客户端代码设计</a></li>
</ul>
</li>
<li><p><a href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">三、运行效果</a></p>
<ul>
<li><input disabled="" type="checkbox"> <a href="#1.%20%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">1. 程序目录结构</a></li>
<li><input disabled="" type="checkbox"> <a href="#2.%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">2. 服务端运行效果</a></li>
<li><input disabled="" type="checkbox"> <a href="#3.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">3. 客户端运行效果</a></li>
</ul>
</li>
<li><p><a href="#%E5%9B%9B%E3%80%81%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF">四、改进思路</a></p>
</li>
<li><p><a href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">五、文件下载</a></p>
</li>
</ul>
<p>软件客户端在发布新版本的时候，有时候只修改了几个文件，没必要让用户重新下载整个客户端再重新安装，同时也不应要求用户每次去手动下载更新的文件，再手动覆盖本地文件。这个时候需要设计一个自动升级机制，在某些条件触发时(比如软件启动的时候)自动查看是否有更新，如果有就将改变的内容下载下来，更新本地旧文件，再根据情况判断是否重启客户端。这个功能现在是桌面程序必备的功能，基本所有的客户端都有这个检查更新的功能。我曾经用Python实现过一个基于http下载的简易自动升级系统，可以独立运行、复用在不同的情景下。</p>
<p>设计思路很简单：当有新版本需要发布时，将文件放在服务端，生成一个记录每个文件变化的配置文件。客户端本地也有一个记录文件信息的配置文件，客户端检查更新时，将服务端的配置文件下载下来，与本地配置文件进行比较，然后下载有变化的文件，覆盖本地文件（如果文件正在使用中，可能无法覆盖，这时候更新前应该先关闭正在运行的客户端），中间有Tkinter做的界面提示更新进度。更新结束后根据策略决定是否重启客户端。</p>
<h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><p>服务端要做的事，首先是选择一个端口号，开启用于响应客户端下载的http服务。然后把指定的目录下的所有文件都扫描一遍，给每个文件记录一个版本号和最后修改日期，再生成一个总版本号，写在XML配置文件里。</p>
<p>比如版本号从0开始，第一次发布程序时，每个文件的版本号都是0，总版本号也是0，第二次发布时，扫描每个文件的最后修改日期，如果日期大于XML文件中记录的日期，将这个文件的记录日期更新，版本号加1。扫描完毕，只要有任意文件的版本号发生变化，总版本号也加1。这样客户端在检查更新时，只需要先比较服务端的总版本号和自己本地的总版本号是否一致。如果不一致，再下载XML文件比较每一个文件版本号变化，如果一致就不用下载XML文件比较了（可以在服务端增加一个接口，客户端请求这个接口时返回一个总版本号字段）。</p>
<h3 id="1-XML配置文件"><a href="#1-XML配置文件" class="headerlink" title="1. XML配置文件"></a>1. <strong>XML</strong>配置文件</h3><p><strong>1.1 XML配置文件结构</strong></p>
<p>ServerInfo节点：记录服务端IP和端口号，可以让客户端知道去哪里下载，当下载地址或端口号变化时，通过更新这个节点，客户端下次更新时就会到新的地址和端口号下载。</p>
<p>ClientVersion节点：要升级的模块的文件信息，包含1个总版本号属性，子节点包括该模块下每个文件的相对路径、文件大小、最后更新时间和版本号。这个节点可以设计多个，用不同的节点名，区分不同的模块，每个模块都有自己的总版本号。这里以1个模块为例。</p>
<p><strong>1.2 XML配置文件示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, xml_path, server_info=<span class="literal">None</span>, module_list=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.xml_path = xml_path</span><br><span class="line">        <span class="keyword">if</span> server_info <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> module_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                module_list = [<span class="string">&quot;ClientVersion&quot;</span>]</span><br><span class="line">            self.create_new_xml(server_info, module_list)</span><br><span class="line">        self.tree = ET.parse(self.xml_path)</span><br><span class="line">        self.root = self.tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_new_xml</span>(<span class="params">self, server_info, module_info</span>):</span></span><br><span class="line">        root = ET.Element(<span class="string">&quot;versionInfo&quot;</span>)</span><br><span class="line">        ServerInfo = ET.SubElement(root, <span class="string">&quot;ServerInfo&quot;</span>)</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;ServerIp&quot;</span>).text = server_info[<span class="number">0</span>]</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;ServerPort&quot;</span>).text = server_info[<span class="number">1</span>]</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;XmlLocalPath&quot;</span>).text = server_info[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> each_module <span class="keyword">in</span> module_info:</span><br><span class="line">            ET.SubElement(root, each_module).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        self.save_change(root)</span><br><span class="line">        print(<span class="string">&quot;I created a new temp xml!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_change</span>(<span class="params">self, root=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            root = self.root</span><br><span class="line">        rough_bytes = ET.tostring(root, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        rough_string = <span class="built_in">str</span>(rough_bytes, encoding=<span class="string">&quot;utf-8&quot;</span>).replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;    &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        content = minidom.parseString(rough_string)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.xml_path, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">            content.writexml(fs, indent=<span class="string">&quot;&quot;</span>, addindent=<span class="string">&quot;\t&quot;</span>, newl=<span class="string">&quot;\n&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changeServerInfo</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(value) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            value = <span class="built_in">str</span>(value)</span><br><span class="line">        Xpath = <span class="string">&quot;ServerInfo/%s&quot;</span> % name</span><br><span class="line">        element = self.root.find(Xpath)</span><br><span class="line">        <span class="keyword">if</span> element <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            element.text = value</span><br><span class="line">            <span class="comment"># self.save_change()</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;ServerInfo/%s\&quot; in xml!&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addObject</span>(<span class="params">self, module_name, file_path, file_size, last_update_time, version</span>):</span></span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="built_in">object</span> = ET.SubElement(moduleVersion, <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;FileRelativePath&quot;</span>).text = <span class="built_in">str</span>(file_path)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;FileSize&quot;</span>).text = <span class="built_in">str</span>(file_size)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;LastUpdateTime&quot;</span>).text = <span class="built_in">str</span>(last_update_time)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;Version&quot;</span>).text = <span class="built_in">str</span>(version)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteObject</span>(<span class="params">self, module_name, file_name</span>):</span></span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        moudleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            <span class="keyword">if</span> element.find(<span class="string">&#x27;FileRelativePath&#x27;</span>).text == file_name:</span><br><span class="line">                moudleVersion.remove(element)</span><br><span class="line">                <span class="comment"># self.save_change()</span></span><br><span class="line">                print(<span class="string">&quot;Delete object: %s&quot;</span> % file_name)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;%s\&quot; in xml!&quot;</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateObject</span>(<span class="params">self, module_name, file_name, version</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(version) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            version = <span class="built_in">str</span>(version)</span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            <span class="keyword">if</span> element.find(<span class="string">&#x27;FileRelativePath&#x27;</span>).text == file_name:</span><br><span class="line">                element.find(<span class="string">&#x27;Version&#x27;</span>).text = version</span><br><span class="line">                <span class="comment"># self.save_change()</span></span><br><span class="line">                <span class="comment"># print(&quot;Update \&quot;%s\&quot; version: %s&quot; % (file_name, version))</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;%s\&quot; in xml!&quot;</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateAttribute</span>(<span class="params">self, module_name, version</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(version) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            version = <span class="built_in">str</span>(version)</span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        moduleVersion.<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, version)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getObjects</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        list_element = []</span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            dict_element = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(element):</span><br><span class="line">                dict_element[value.tag] = value.text</span><br><span class="line">            list_element.append(dict_element)</span><br><span class="line">        <span class="keyword">return</span> list_element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addModule</span>(<span class="params">self, module</span>):</span></span><br><span class="line">        self.root.append(module)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteModule</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        module = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.root.remove(module)</span><br><span class="line">            <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getModules</span>(<span class="params">self</span>):</span></span><br><span class="line">        dict_element = &#123;&#125;</span><br><span class="line">        objects = self.root.getchildren()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(objects):</span><br><span class="line">            dict_element[value.tag] = value.attrib.get(<span class="string">&quot;Version&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> dict_element[<span class="string">&quot;ServerInfo&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> dict_element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAttribute</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">return</span> moduleVersion.get(<span class="string">&quot;Version&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node_value</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;查找某个路径匹配的第一个节点</span></span><br><span class="line"><span class="string">           tree: xml树</span></span><br><span class="line"><span class="string">           path: 节点路径&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = self.tree.find(path)</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> node.text</span><br></pre></td></tr></table></figure>
<h3 id="2-服务端代码设计"><a href="#2-服务端代码设计" class="headerlink" title="2. 服务端代码设计"></a>2. <strong>服务端代码设计</strong></h3><p>源码文件太长，这里只贴出主要的两个方法，具体实现源码文件放在文末下载。</p>
<p>首先是根扫描所有文件，生成一个最新xml配置文件，然后再比较两个xml，分析出增删改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/4/25 20:16</span></span><br><span class="line"><span class="comment"># @Author  : yushuaige</span></span><br><span class="line"><span class="comment"># @File    : AutoCheckVersion.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Function: 实现客户端自动更新（服务端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>():</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 同上面xml类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AutoCheckVersion</span>(<span class="params">old_xml_path, new_xml_path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    比较两个xml的objects节点，分析出增加，更改，和删除的文件列表，并在新xml里更新版本号</span></span><br><span class="line"><span class="string">    :param old_xml: 旧xml的完整路径</span></span><br><span class="line"><span class="string">    :param new_xml: 新xml的完整路径</span></span><br><span class="line"><span class="string">    :return: len(add_list), len(delete_list), len(change_list),</span></span><br><span class="line"><span class="string">    :return: add_list: [filname1, filname2], delete_list: [filname1, filname2] change_list: [filname1, filname2]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Analyze the xml files and update the version number ...&quot;</span>)</span><br><span class="line">    old_xml = VersionInfoXml(old_xml_path)</span><br><span class="line">    new_xml = VersionInfoXml(new_xml_path)</span><br><span class="line">    <span class="comment"># 先分析模块的增、删、改</span></span><br><span class="line">    old_modules = <span class="built_in">list</span>(old_xml.getModules().keys())</span><br><span class="line">    new_modules = <span class="built_in">list</span>(new_xml.getModules().keys())</span><br><span class="line">    add_modules_list = <span class="built_in">list</span>(<span class="built_in">set</span>(new_modules).difference(<span class="built_in">set</span>(old_modules)))</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> add_modules_list:</span><br><span class="line">        ET.SubElement(old_xml.root, module_name).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    common_modules_list = [item <span class="keyword">for</span> item <span class="keyword">in</span> old_modules <span class="keyword">if</span> item <span class="keyword">in</span> new_modules]</span><br><span class="line">    <span class="comment"># 分析每个的模块中的每个文件的增、删、改</span></span><br><span class="line">    total_add_list = []</span><br><span class="line">    total_delete_list = []</span><br><span class="line">    total_change_list = []</span><br><span class="line">    common_modules_list.extend(add_modules_list)</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> common_modules_list:</span><br><span class="line">        old_xml_objects = old_xml.getObjects(module_name)</span><br><span class="line">        new_xml_objects = new_xml.getObjects(module_name)</span><br><span class="line">        old_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> old_xml_objects&#125;</span><br><span class="line">        new_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> new_xml_objects&#125;</span><br><span class="line">        old_data_list = <span class="built_in">set</span>(old_xml_objects_dict.keys())</span><br><span class="line">        new_data_list = <span class="built_in">set</span>(new_xml_objects_dict.keys())</span><br><span class="line">        add_list = <span class="built_in">list</span>(new_data_list.difference(old_data_list))</span><br><span class="line">        delete_list = <span class="built_in">list</span>(old_data_list.difference(new_data_list))</span><br><span class="line">        common_list = <span class="built_in">list</span>(old_data_list.intersection(new_data_list))</span><br><span class="line">        change_list = []</span><br><span class="line">        <span class="comment"># 更新每个文件的版本号信息</span></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> common_list:</span><br><span class="line">            new_version = <span class="built_in">int</span>(old_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>])</span><br><span class="line">            update = TimeFormatComp(new_xml_objects_dict[file_name][<span class="string">&quot;LastUpdateTime&quot;</span>],</span><br><span class="line">                                    old_xml_objects_dict[file_name][<span class="string">&quot;LastUpdateTime&quot;</span>])</span><br><span class="line">            <span class="keyword">if</span> update <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                change_list.append(file_name)</span><br><span class="line">                new_version += <span class="number">1</span></span><br><span class="line">            new_xml.updateObject(module_name, file_name, new_version)</span><br><span class="line">        <span class="comment"># 更新模块版本信息</span></span><br><span class="line">        new_module_version = <span class="built_in">int</span>(old_xml.getAttribute(module_name))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(add_list) <span class="keyword">or</span> <span class="built_in">len</span>(delete_list) <span class="keyword">or</span> <span class="built_in">len</span>(change_list):</span><br><span class="line">            new_module_version = new_module_version + <span class="number">1</span></span><br><span class="line">        new_xml.updateAttribute(module_name, new_module_version)</span><br><span class="line"></span><br><span class="line">        total_add_list.extend(add_list)</span><br><span class="line">        total_delete_list.extend(delete_list)</span><br><span class="line">        total_change_list.extend(change_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    new_xml.save_change()</span><br><span class="line">    print(<span class="string">&quot;Analysis update info done. Save the new xml ...&quot;</span>)</span><br><span class="line">    <span class="comment"># 结果提示</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(total_add_list) <span class="keyword">or</span> <span class="built_in">len</span>(total_delete_list) <span class="keyword">or</span> <span class="built_in">len</span>(total_change_list):</span><br><span class="line">        <span class="comment"># 替换旧的xml文件</span></span><br><span class="line">        os.remove(old_xml_path)</span><br><span class="line">        os.rename(new_xml_path, old_xml_path)</span><br><span class="line">        print(<span class="string">&quot;Done. add: %d, delete: %d, update: %d. The new client version: %s.&quot;</span> % (</span><br><span class="line">            <span class="built_in">len</span>(total_add_list), <span class="built_in">len</span>(total_delete_list), <span class="built_in">len</span>(total_change_list), <span class="built_in">str</span>(new_xml.getModules())))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.remove(new_xml_path)</span><br><span class="line">        print(<span class="string">&quot;No file changed! The current client version: %s.&quot;</span> % (<span class="built_in">str</span>(new_xml.getModules())))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(total_add_list), <span class="built_in">len</span>(total_delete_list), <span class="built_in">len</span>(total_change_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateNewXmlFromFiles</span>(<span class="params">client_dir</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    遍历文件夹所有文件，生成标准xml</span></span><br><span class="line"><span class="string">    :param client_dir: 要遍历的文件夹路径</span></span><br><span class="line"><span class="string">    :return: 生成的xml的完整路径</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Scan the folder and create the temp xml file ...&quot;</span>)</span><br><span class="line">    config_parser = configparser.ConfigParser()</span><br><span class="line">    config_parser.read(os.path.dirname(sys.path[<span class="number">0</span>]) + <span class="string">&#x27;\\cfg.ini&#x27;</span>)</span><br><span class="line">    UPDATE_HOST = config_parser.get(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&#x27;serv&#x27;</span>)</span><br><span class="line">    server_info = [UPDATE_HOST, <span class="string">&quot;8888&quot;</span>, <span class="string">&quot;dev_manage_win&quot;</span>]</span><br><span class="line">    module_list = os.listdir(client_dir)</span><br><span class="line">    new_xml = VersionInfoXml(<span class="string">&quot;VersionInfoTemp.xml&quot;</span>, server_info, module_list)</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> module_list:</span><br><span class="line">        module_dir = os.path.join(client_dir, module_name)</span><br><span class="line">        <span class="keyword">for</span> (dirpath, dirnames, filenames) <span class="keyword">in</span> os.walk(module_dir):</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> filenames:</span><br><span class="line">                file_dir = os.path.join(dirpath, file)</span><br><span class="line">                file_path = file_dir.replace(client_dir, <span class="string">&quot;&quot;</span>).strip(<span class="string">&quot;\\&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                file_size = os.path.getsize(file_dir)</span><br><span class="line">                last_update_time = TimeStampFormat(os.path.getmtime(file_dir))</span><br><span class="line">                version = <span class="number">1</span></span><br><span class="line">                new_xml.addObject(module_name, file_path, file_size, last_update_time, version)</span><br><span class="line">    new_xml.save_change()</span><br><span class="line">    new_xml_path = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;VersionInfoTemp.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> new_xml_path</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><h3 id="1-XML配置文件-1"><a href="#1-XML配置文件-1" class="headerlink" title="1. XML配置文件"></a>1. <strong>XML</strong>配置文件</h3><p>为了简便，客户端和服务端处理xml文件的类用同一个。</p>
<h3 id="2-客户端代码设计"><a href="#2-客户端代码设计" class="headerlink" title="2. 客户端代码设计"></a>2. 客户<strong>端代码设计</strong></h3><p>源码文件太长，这里只贴出主要的两个方法，具体实现源码文件放在文末下载。</p>
<p>下载最新xml配置文件和本地配置文件进行比较，然后分析出增删改，进行下载和删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/4/25 20:16</span></span><br><span class="line"><span class="comment"># @Author  : yushuaige</span></span><br><span class="line"><span class="comment"># @File    : AutoUpdate.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Function: 实现客户端自动更新（客户端）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 同上面xml类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动更新时，检查更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CheckUpdate</span>(<span class="params">server_ip, server_port, module_name, order</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AutoUpdate</span>(<span class="params">server_ip, server_port, module_name, order</span>):</span></span><br><span class="line">    time_start = time.perf_counter()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        download_url = <span class="string">&quot;http://&#123;0&#125;:&#123;1&#125;/&#123;2&#125;&quot;</span>.<span class="built_in">format</span>(server_ip, server_port, <span class="string">&quot;VersionInfo.xml&quot;</span>)</span><br><span class="line">        local_path = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;VersionInfoTemp.xml&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;download_url: &quot;</span> + download_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> download_file_by_http(download_url, local_path):</span><br><span class="line">            <span class="keyword">raise</span> Exception()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># tkinter.messagebox.showerror(&quot;更新无法继续&quot;, &quot;获取最新版本列表文件出现异常！&quot;)</span></span><br><span class="line">        print(<span class="string">&quot;Update error: Can&#x27;t get the latest VersionInfo xml!&quot;</span>)</span><br><span class="line">        <span class="comment"># root.destroy()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    root.update()</span><br><span class="line">    root.deiconify()</span><br><span class="line">    <span class="comment"># 比较文件变化</span></span><br><span class="line">    add_dict, delete_list = analyze_update_info(local_xml_path, update_xml_path, module_name)</span><br><span class="line">    <span class="keyword">if</span> add_dict == &#123;&#125; <span class="keyword">and</span> delete_list == []:</span><br><span class="line">        os.remove(update_xml_path)</span><br><span class="line">        <span class="comment"># tkinter.messagebox.showinfo(&quot;更新无法继续&quot;, &quot;当前客户端已经是最新版本！&quot;)</span></span><br><span class="line">        print(<span class="string">&quot;No file changed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 下载需要更新的文件</span></span><br><span class="line">    download_progress(add_dict)</span><br><span class="line">    <span class="comment"># 文件覆盖到主目录</span></span><br><span class="line">    prompt_info11.<span class="built_in">set</span>(<span class="string">&quot;正在解压...&quot;</span>)</span><br><span class="line">    prompt_info13.<span class="built_in">set</span>(<span class="string">&quot;总体进度：99.9%&quot;</span>)</span><br><span class="line">    prompt_info21.<span class="built_in">set</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    root.update()</span><br><span class="line">    source_dir = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;TempFolder&quot;</span>)</span><br><span class="line">    dest_dir = os.path.dirname(sys.path[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># dest_dir = os.path.join(sys.path[0], &quot;test_main&quot;)</span></span><br><span class="line">    override_dir(source_dir, dest_dir)</span><br><span class="line">    <span class="comment"># 删除要删除的文件</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> delete_list:</span><br><span class="line">        delete_dir(os.path.join(dest_dir, file))</span><br><span class="line">    <span class="comment"># 更新xml文件</span></span><br><span class="line">    <span class="keyword">if</span> module_name == <span class="string">&quot;all_module&quot;</span>:</span><br><span class="line">        os.remove(local_xml_path)</span><br><span class="line">        os.rename(update_xml_path, local_xml_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        update_xml(local_xml_path, update_xml_path, module_name)</span><br><span class="line">    <span class="comment"># 客户端更新结束</span></span><br><span class="line">    time_end = time.perf_counter()</span><br><span class="line">    print(<span class="string">&quot;更新耗时：%ds&quot;</span> % (time_end - time_start))</span><br><span class="line">    prompt_info11.<span class="built_in">set</span>(<span class="string">&quot;更新完毕。&quot;</span>)</span><br><span class="line">    prompt_info13.<span class="built_in">set</span>(<span class="string">&quot;总体进度：100.0%&quot;</span>)</span><br><span class="line">    root.update()</span><br><span class="line">    <span class="comment"># tkinter.messagebox.showinfo(&quot;更新完成&quot;, &quot;更新完毕，耗时：%ds&quot; % (time_end - time_start))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析两个xml文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_update_info</span>(<span class="params">local_xml, update_xml, module_name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    分析本地xml文件和最新xml文件获得增加的文件和要删除的文件</span></span><br><span class="line"><span class="string">    :param local_xml: 本地xml文件路径</span></span><br><span class="line"><span class="string">    :param update_xml: 下载的最新xml文件路径</span></span><br><span class="line"><span class="string">    :return: download_info: &#123;filename1: fizesize1, filename2: fizesize2&#125;, delete_list: [filname1, filname2]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Analyze the xml files and check the version number ...&quot;</span>)</span><br><span class="line">    old_xml = VersionInfoXml(local_xml)</span><br><span class="line">    new_xml = VersionInfoXml(update_xml)</span><br><span class="line">    module_names = []</span><br><span class="line">    <span class="keyword">if</span> module_name == <span class="string">&quot;all_module&quot;</span>:</span><br><span class="line">        module_names = new_xml.getModules()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        module_names.append(module_name)</span><br><span class="line">    download_info_total = &#123;&#125;</span><br><span class="line">    delete_list_total = []</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> module_names:</span><br><span class="line">        <span class="keyword">if</span> old_xml.getAttribute(module_name) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ET.SubElement(old_xml.root, module_name).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> new_xml.getAttribute(module_name) &amp;lt;= old_xml.getAttribute(module_name):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        old_xml_objects = old_xml.getObjects(module_name)</span><br><span class="line">        new_xml_objects = new_xml.getObjects(module_name)</span><br><span class="line">        old_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> old_xml_objects&#125;</span><br><span class="line">        new_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> new_xml_objects&#125;</span><br><span class="line">        old_data_list = <span class="built_in">set</span>(old_xml_objects_dict.keys())</span><br><span class="line">        new_data_list = <span class="built_in">set</span>(new_xml_objects_dict.keys())</span><br><span class="line">        add_list = <span class="built_in">list</span>(new_data_list.difference(old_data_list))</span><br><span class="line">        delete_list = <span class="built_in">list</span>(old_data_list.difference(new_data_list))</span><br><span class="line">        common_list = <span class="built_in">list</span>(old_data_list.intersection(new_data_list))</span><br><span class="line"></span><br><span class="line">        download_info = &#123;file_name: new_xml_objects_dict[file_name][<span class="string">&quot;FileSize&quot;</span>] <span class="keyword">for</span> file_name <span class="keyword">in</span> add_list&#125;</span><br><span class="line">        <span class="comment"># 根据每个文件的版本号，确定是否需要更新</span></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> common_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(new_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>]) &amp;gt; <span class="built_in">int</span>(old_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>]):</span><br><span class="line">                download_info.update(&#123;file_name: new_xml_objects_dict[file_name][<span class="string">&quot;FileSize&quot;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">        download_info_total.update(download_info)</span><br><span class="line">        delete_list_total.extend(delete_list)</span><br><span class="line">    <span class="comment"># return download_info, delete_list</span></span><br><span class="line">    <span class="keyword">return</span> download_info_total, delete_list_total</span><br></pre></td></tr></table></figure>
<h2 id="三、运行效果"><a href="#三、运行效果" class="headerlink" title="三、运行效果"></a>三、运行效果</h2><h3 id="1-程序目录结构"><a href="#1-程序目录结构" class="headerlink" title="1. 程序目录结构"></a>1. 程序目录结构</h3><p><strong>1.1 服务端</strong></p>
<p>ClientFolder目录用来存放要更新的文件夹，</p>
<p>venv是python目录，</p>
<p>cfg.ini文件用来配置ip、端口等信息，</p>
<p>server.py是主程序，</p>
<p>start.bat用来双击启动server.py，</p>
<p>VersionInfo.xml是存放文件信息的xml</p>
<p>       <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425213341739.png" alt="20200425213341739.png"></p>
<p><strong>1.2 客户端</strong></p>
<p>TempFolder目录用来存放下载下来的文件，</p>
<p>venv是python目录，</p>
<p>client.py是主程序，</p>
<p>start.bat用来双击启动server.py，</p>
<p>VersionInfo.xml是存放文件信息的xml，</p>
<p>VersionInfoTemp.xml是更新时自动生成的，是下载的最新配置文件</p>
<p>       <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425213310466.png" alt="20200425213310466.png"></p>
<h3 id="2-服务端运行效果"><a href="#2-服务端运行效果" class="headerlink" title="2. 服务端运行效果"></a>2. 服务端运行效果</h3><p>默认使用本地测试ip 127.0.0.1，默认端口8888</p>
<p>     <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425214624388.png" alt="20200425214624388.png"></p>
<h3 id="3-客户端运行效果"><a href="#3-客户端运行效果" class="headerlink" title="3. 客户端运行效果"></a>3. 客户端运行效果</h3><p>上面窗口是控制台窗口，显示运行过程的日志，下面是更新界面。</p>
<p>如果不想显示控制台界面，只需要把start.bat里前三行的注释打开即可。</p>
<p>文件太小可能会一闪而过，因为程序默认更新完立即退出。</p>
<p>    <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425215953325.png" alt="20200425215953325.png"></p>
<p>   <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425215030334.png" alt="20200425215030334.png"></p>
<h2 id="四、改进思路"><a href="#四、改进思路" class="headerlink" title="四、改进思路"></a>四、改进思路</h2><p><strong>1.多线程提高效率</strong></p>
<p>因为没有测试过文件数量和大小非常大的情况，现在程序的所有步骤都是单线程执行，可以将文件扫描和下载等耗时间的步骤，改进成多线程或者协程同时运行，提高程序的运行效率。</p>
<p><strong>2.文件扫描方式</strong></p>
<p>当前只根据文件相对路径加文件全名的方式，进行文件区分，然后根据最后修改时间来判断是否需要更新，可以增加MD5校验来保证文件的唯一性。</p>
<p><strong>3.界面完善</strong></p>
<p>当前只有在下载文件时有界面提示，可以改进界面，使整个更新过程可视化。</p>
<p><strong>4.启动方式</strong></p>
<p>当前使用bat脚本调命令行的方式启动程序，会有一个黑色窗口，可以将程序打包成exe文件发布。</p>
<h2 id="五、文件下载"><a href="#五、文件下载" class="headerlink" title="五、文件下载"></a>五、文件下载</h2><p>零积分下载整个程序源码：<a href="https://download.csdn.net/download/yushuaigee/12362232">用Python实现一个软件自动升级系统</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（一）—— os模块</title>
    <url>/2020/06/15/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20os%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106755148">https://blog.csdn.net/yushuaigee/article/details/106755148</a></p>
</blockquote>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#%E7%AC%AC1~22%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E6%95%B4%E4%BD%93%E6%B3%A8%E9%87%8A%E3%80%81nt%E4%B8%8Eposix">第1~22行 模块整体注释、nt与posix</a></p>
</li>
<li><p><a href="#%E7%AC%AC24~46%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E3%80%81_exists%E6%96%B9%E6%B3%95%E3%80%81_get_exports_list%E6%96%B9%E6%B3%95">第24~46行 模块引入、_exists方法、_get_exports_list方法</a></p>
</li>
<li><p><a href="#%E7%AC%AC48~97%E8%A1%8C%20%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%90%8C%E5%AF%BC%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7">第48~97行 根据系统不同导入不同的方法和属性</a></p>
</li>
<li><p><a href="#%E7%AC%AC100~185%E8%A1%8C%20?%5B1%5D">第100~185行 ?[1]</a></p>
</li>
<li><p><a href="#%E7%AC%AC188~193%E8%A1%8C%C2%A0%E5%AE%9A%E4%B9%89%E4%B8%89%E4%B8%AA%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F">第188~193行 定义三个枚举变量</a></p>
</li>
<li><p><a href="#%E7%AC%AC195~228%E8%A1%8C%20makedirs%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95">第195~228行 makedirs——创建多级目录</a></p>
</li>
<li><p><a href="#%E7%AC%AC230~250%E8%A1%8C%20removedirs%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95">第230~250行 removedirs——删除多级目录</a></p>
</li>
<li><p><a href="#%E7%AC%AC252~278%E8%A1%8C%20renames%E2%80%94%E2%80%94%E9%87%8D%E5%91%BD%E5%90%8D%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6">第252~278行 renames——重命名目录或文件</a></p>
</li>
<li><p><a href="#%E7%AC%AC280~421%E8%A1%8C%20walk%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%A0%91%E7%94%9F%E6%88%90%E5%99%A8">第280~421行 walk——目录树生成器</a></p>
</li>
<li><p><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%E2%80%A6%E2%80%A6">未完待续……</a></p>
</li>
</ul>
<p>os模块包含了一些与操作系统相关的函数接口，而且它是支持跨平台的，它封装了 nt.py(windows) 和 posix.py (类Unix)两个模块的接口，而后面两个模块是由C语言实现的、直接和系统交互的底层接口。也就是说os模块能够处理平台间的差异问题，使得编写好的程序无需做任何改动就能在不同的平台上运行。如果想要查看os模块的所有内容，可以使用<code>dir(os)</code>方法查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200529172306852.png" alt="20200529172306852"></p>
<p>可以看到os模块中有这么多属性和方法，这些都是可以通过“os.”访问的。因为os模块是使用纯Python实现的标准库，所以在Python安装目录中也可以找到os模块的源码。打开Python安装目录下 \Lib\os.py 文件，或者源码目录下 \Lib\os.py 文件，就可以查看os模块的源码了。整个代码看下来，os.py 主要是将底层接口进行了一层封装，不知道其他标准库是不是也是这样。</p>
<p>以下标题中的行数是与我所用的3.8.4版本os.py文件真实的行数对应的，而分析文字部分所说的行数，是对应截取的代码段的行数，这样比较方便看。</p>
<h3 id="第1-22行-模块整体注释、nt与posix"><a href="#第1-22行-模块整体注释、nt与posix" class="headerlink" title="第1~22行 模块整体注释、nt与posix"></a>第1~22行 模块整体注释、nt与posix</h3><p>首先是第1行到第22行，这是一段整个模块的注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&quot;&quot;&quot;OS routines for NT or Posix depending on what system we&#x27;re on.</span></span><br><span class="line"><span class="string">This exports:</span></span><br><span class="line"><span class="string">  - all functions from posix or nt, e.g. unlink, stat, etc.</span></span><br><span class="line"><span class="string">  - os.path is either posixpath or ntpath</span></span><br><span class="line"><span class="string">  - os.name is either &#x27;posix&#x27; or &#x27;nt&#x27;</span></span><br><span class="line"><span class="string">  - os.curdir is a string representing the current directory (always &#x27;.&#x27;)</span></span><br><span class="line"><span class="string">  - os.pardir is a string representing the parent directory (always &#x27;..&#x27;)</span></span><br><span class="line"><span class="string">  - os.sep is the (or a most common) pathname separator (&#x27;/&#x27; or &#x27;\\&#x27;)</span></span><br><span class="line"><span class="string">  - os.extsep is the extension separator (always &#x27;.&#x27;)</span></span><br><span class="line"><span class="string">  - os.altsep is the alternate pathname separator (None or &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">  - os.pathsep is the component separator used in $PATH etc</span></span><br><span class="line"><span class="string">  - os.linesep is the line separator in text files (&#x27;\r&#x27; or &#x27;\n&#x27; or &#x27;\r\n&#x27;)</span></span><br><span class="line"><span class="string">  - os.defpath is the default search path for executables</span></span><br><span class="line"><span class="string">  - os.devnull is the file path of the null device (&#x27;/dev/null&#x27;, etc.)</span></span><br><span class="line"><span class="string">Programs that import and use &#x27;os&#x27; stand a better chance of being</span></span><br><span class="line"><span class="string">portable between different platforms.  Of course, they must then</span></span><br><span class="line"><span class="string">only use functions that are defined by all platforms (e.g., unlink</span></span><br><span class="line"><span class="string">and opendir), and leave all pathname manipulation to os.path</span></span><br><span class="line"><span class="string">(e.g., split and join).</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段注释解释了OS模块的功能，就是为了支持跨平台的移植代码，根据不同的系统调用对应平台支持的接口。以前也写过跨Windows和Linux的Python程序，当时就是在网上查的，根据os.name的值是字符串’nt’还是’posix’来判断当前是哪种系统，然后走到对应的代码分支，并没有深究就是为什么。这次研究一下什么是NT和Posix：</p>
<p>NT即Windows NT，就是Windows系统的内核，其中的NT意为New Technology。微软一开始命名系统是以内核版本命名的，比如：Microsoft Windows NT 3.1 (1993)、Microsoft Windows NT 3.5 (1994)，知道Windows 2000之后才改成现在的xp、7、Vista、10这种。它的内核版本还是在不断演进的，只是系统对外发布的命名风格发生了变化。所以OS模块中用‘nt’代表Windows系统。</p>
<p>POSIX提供了一套大体上基于Unix的可移植操作系统标准，意在期望获得源代码级别的软件可移植性。为了实现相同的功能，在不同的系统上可能有着不同的接口名字，写代码的时候需要根据不通系统在源代码级别上进行适配。为了解决这个问题，让不同系统都遵循POSIX标准，就是在原来的接口的基础上再封装一层，起一个通用的名字，这样就可以用一份源代码运行在不同的系统上，这个道理和OS模块的功能是一样的。Linux是与POSIX兼容的(现在Window也开始支持这个标准了)，所以OS模块中用‘posix’代表Linux这种类UNIX系统。</p>
<p>为什么选择这两个单词我们不用深究，只是一种规定，我们用的时候只需’判断os.name == ‘nt是Windows系统，os.name == ‘posix’是Linux或Mac系统就行了，至于OS怎么根据‘nt’和‘posix’两个字符串实现区分不同系统的，这个在源码中有体现，后面马上就能看的到。</p>
<h3 id="第24-46行-模块引入、-exists方法、-get-exports-list方法"><a href="#第24-46行-模块引入、-exists方法、-get-exports-list方法" class="headerlink" title="第24~46行 模块引入、_exists方法、_get_exports_list方法"></a>第24~46行 模块引入、_exists方法、_get_exports_list方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> stat <span class="keyword">as</span> st</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> _collections_abc <span class="keyword">import</span> _check_methods</span><br><span class="line"> </span><br><span class="line">_names = sys.builtin_module_names</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Note:  more names are added to __all__ later.</span></span><br><span class="line">__all__ = [<span class="string">&quot;altsep&quot;</span>, <span class="string">&quot;curdir&quot;</span>, <span class="string">&quot;pardir&quot;</span>, <span class="string">&quot;sep&quot;</span>, <span class="string">&quot;pathsep&quot;</span>, <span class="string">&quot;linesep&quot;</span>,</span><br><span class="line">           <span class="string">&quot;defpath&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;devnull&quot;</span>, <span class="string">&quot;SEEK_SET&quot;</span>, <span class="string">&quot;SEEK_CUR&quot;</span>,</span><br><span class="line">           <span class="string">&quot;SEEK_END&quot;</span>, <span class="string">&quot;fsencode&quot;</span>, <span class="string">&quot;fsdecode&quot;</span>, <span class="string">&quot;get_exec_path&quot;</span>, <span class="string">&quot;fdopen&quot;</span>,</span><br><span class="line">           <span class="string">&quot;popen&quot;</span>, <span class="string">&quot;extsep&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_exists</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> <span class="built_in">globals</span>()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_exports_list</span>(<span class="params">module</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(module.__all__)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">dir</span>(module) <span class="keyword">if</span> n[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p> 第2行引入 abc 模块，在os这里主要用到里面的ABC，Abstract Base Class（抽象基类），主要定义了基本类和最基本的抽象方法，可以为子类定义共有的API，不需要具体实现。相当于是Java中的接口或者是抽象类。这个抽象基类的作用一两句话说不清楚，鉴于abc.py也属于Python标准库，下一篇就具体研究一下这个abc模块。</p>
<p>第3行引入sys模块，这是一个C实现的内置模块，主要是实现Python解释器、操作系统相关的操作。</p>
<p>第4行引入stat模块，这个模块主要实现文件状态检查之类的操作，也属于一个标准库，在os这里只是用到了 st.S_ISDIR 这个方法，判断是否是目录。</p>
<p>第6行引入_collections_abc模块的_check_methods方法，这个模块是用于集合的抽象基类，也属于一个标准库，_check_methods用来判断一个对象是否含有某个属性。</p>
<p>第8行 sys.builtin_module_names 返回一个包含内建模块名字的元组，包含所有已经编译到Python解释器的模块名字。这里就可以解释os模块怎么根据‘nt’和‘posix’两个字符串实现区分不同系统的：Window系统的Python会安装nt模块，这个返回的元组中就会包含‘nt’，而其他系统的Python在安装时不安装nt模块，而是安装posix模块，这个返回的元组中就会包含‘posix’。</p>
<p>下面一行是一个注释，提示：更多的名称会在后面慢慢加入到__all__中。</p>
<p>第11行，<strong>all</strong> 是针对模块公开接口的一种约定，以提供了”白名单“的形式暴露接口。如果定义了<strong>all__，其他文件中使用from xxx import *导入该文件时，只会导入 __all</strong> 列出的成员，其他成员都被排除在外。若没定义，则导入模块内的所有公有属性/方法和类 。因为只是一种约定，就像用__前缀表示私有成员一样，它只对import <code>*</code>起作用，对from xxx import xxx不起作用。 </p>
<p>下面定义了_exists方法，用于通过名字获得全局变量中的对象。其中global()方法是解释器内置方法，不需要导入就可以直接用，会以字典类型返回当前位置的全部全局变量。类似的还有locals()方法，后者以字典类型返回当前位置的局部变量。</p>
<p>再下面是_get_exports_list方法，这个了解了上面的__all__就很好理解，就是通过模块名获得对应模块对外暴露的接口，如果该模块没有定义__all__，即发生了AttributeError，就返回模块所有接口里面不是以_前缀开头的接口。可以看出这是在遵守约定。</p>
<h3 id="第48-97行-根据系统不同导入不同的方法和属性"><a href="#第48-97行-根据系统不同导入不同的方法和属性" class="headerlink" title="第48~97行 根据系统不同导入不同的方法和属性"></a>第48~97行 根据系统不同导入不同的方法和属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Any new dependencies of the os module and/or changes in path separator</span></span><br><span class="line"><span class="comment"># requires updating importlib as well.</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;posix&#x27;</span> <span class="keyword">in</span> _names:</span><br><span class="line">    name = <span class="string">&#x27;posix&#x27;</span></span><br><span class="line">    linesep = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> posix <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> posix <span class="keyword">import</span> _exit</span><br><span class="line">        __all__.append(<span class="string">&#x27;_exit&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">import</span> posixpath <span class="keyword">as</span> path</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> posix <span class="keyword">import</span> _have_functions</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">import</span> posix</span><br><span class="line">    __all__.extend(_get_exports_list(posix))</span><br><span class="line">    <span class="keyword">del</span> posix</span><br><span class="line"> </span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;nt&#x27;</span> <span class="keyword">in</span> _names:</span><br><span class="line">    name = <span class="string">&#x27;nt&#x27;</span></span><br><span class="line">    linesep = <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> nt <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> nt <span class="keyword">import</span> _exit</span><br><span class="line">        __all__.append(<span class="string">&#x27;_exit&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">import</span> ntpath <span class="keyword">as</span> path</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">import</span> nt</span><br><span class="line">    __all__.extend(_get_exports_list(nt))</span><br><span class="line">    <span class="keyword">del</span> nt</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> nt <span class="keyword">import</span> _have_functions</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ImportError(<span class="string">&#x27;no os specific module found&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">sys.modules[<span class="string">&#x27;os.path&#x27;</span>] = path</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> (curdir, pardir, sep, pathsep, defpath, extsep, altsep,</span><br><span class="line">    devnull)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> _names</span><br></pre></td></tr></table></figure>
<p>注释是说，os模块的任何新依赖关系、路径分隔符的更改都需要更新导入库。因此下面的 if 和 elif 代码段就是在根据不同的系统更新导入的库。</p>
<p>第3行就是上面说的根据当前已经编译到Python解释器的模块名字判断当前系统是不是遵循POSIX标准的系统(Mac、Linux等)，如果是就将新建属性 name 赋值 posix ，注意这里的属性是属于os模块的，这也是为什么我们在外面导入os模块后，就可以使用os.name来判断系统类型，和文件最开始的注释中的os.name就对上了，看了原理就会发现其实也没什么神奇的。同理，下一行的linesep对应文件最开始的注释中的os.linesep，表示文本文件的分隔符，在Mac、Linux等系统中默认是 ‘\n’。</p>
<p>第6行导入posix模块的全部内容。此模块提供了对基于 C 标准和 POSIX 标准（一种稍加修改的 Unix 接口）进行标准化的系统功能的访问。官方文档都用加粗字体说了：请勿直接导入此模块<strong>。</strong> 而应导入os模块，它提供了此接口的可移植版本，而且没有性能损失。前面说过os模块就是对posix模块和nt模块的封装，在Windows上安装的Python是没有posix模块的，所以IDE里也没法跳转过去，这里暂不深究。</p>
<p>下面五行尝试从 posix 导入 _exit 方法并将其加到<strong>all__中暴露出去，如果没有就pass。前面已经import *了，为什么还要再单独导入一次呢？我觉得这里是因为不确定 posix 里是否有此方法(可能POSIX标准的部分系统没有这个方法)，所以不能直接使用__all</strong>.append(‘_exit’)。</p>
<p>第12行将 posixpath 导入并改名为 path，所以我们平时使用的 os.path 其实不是os模块本身。posixpath 是另外一个用Python实现的专门处理关于路径的问题的库，这个库Windows系统上的Python也会安装，后面的文章再具体分析。</p>
<p>下面是尝试导入_have_functions，这是一个列表，里面包含对应系统所支持的函数名，后面会用到。再下面就是把posix模块对外暴露的方法和属性和当前os模块合并，其中 _get_exports_list 方法是前面刚刚定义的。</p>
<p>再往下看，elif 代码块和前面一模一样，只是把 posix 换成了 nt 。后面还有一个 else 代码块，如果 ‘posix’ 和 ‘nt’都不在内建属性列表中将会报错，说明 os 模块只支持 posix和nt 标准的系统(除了这两种估计也没啥别的标准了)。到这里，当前系统是什么类型已经很明确了，只需将对应系统的路径分隔符等导入进来。</p>
<h3 id="第100-185行-1"><a href="#第100-185行-1" class="headerlink" title="第100~185行 ?[1]"></a>第100~185行 ?[1]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _exists(<span class="string">&quot;_have_functions&quot;</span>):</span><br><span class="line">    _globals = <span class="built_in">globals</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params"><span class="built_in">str</span>, fn</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (fn <span class="keyword">in</span> _globals) <span class="keyword">and</span> (<span class="built_in">str</span> <span class="keyword">in</span> _have_functions):</span><br><span class="line">            _set.add(_globals[fn])</span><br><span class="line"> </span><br><span class="line">    _set = <span class="built_in">set</span>()</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FACCESSAT&quot;</span>,  <span class="string">&quot;access&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHMODAT&quot;</span>,   <span class="string">&quot;chmod&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHOWNAT&quot;</span>,   <span class="string">&quot;chown&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FSTATAT&quot;</span>,    <span class="string">&quot;stat&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FUTIMESAT&quot;</span>,  <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LINKAT&quot;</span>,     <span class="string">&quot;link&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_MKDIRAT&quot;</span>,    <span class="string">&quot;mkdir&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_MKFIFOAT&quot;</span>,   <span class="string">&quot;mkfifo&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_MKNODAT&quot;</span>,    <span class="string">&quot;mknod&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_OPENAT&quot;</span>,     <span class="string">&quot;open&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_READLINKAT&quot;</span>, <span class="string">&quot;readlink&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_RENAMEAT&quot;</span>,   <span class="string">&quot;rename&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_SYMLINKAT&quot;</span>,  <span class="string">&quot;symlink&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_UNLINKAT&quot;</span>,   <span class="string">&quot;unlink&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_UNLINKAT&quot;</span>,   <span class="string">&quot;rmdir&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_UTIMENSAT&quot;</span>,  <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    supports_dir_fd = _set</span><br><span class="line"> </span><br><span class="line">    _set = <span class="built_in">set</span>()</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FACCESSAT&quot;</span>,  <span class="string">&quot;access&quot;</span>)</span><br><span class="line">    supports_effective_ids = _set</span><br><span class="line"> </span><br><span class="line">    _set = <span class="built_in">set</span>()</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHDIR&quot;</span>,     <span class="string">&quot;chdir&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHMOD&quot;</span>,     <span class="string">&quot;chmod&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHOWN&quot;</span>,     <span class="string">&quot;chown&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FDOPENDIR&quot;</span>,  <span class="string">&quot;listdir&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FDOPENDIR&quot;</span>,  <span class="string">&quot;scandir&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FEXECVE&quot;</span>,    <span class="string">&quot;execve&quot;</span>)</span><br><span class="line">    _set.add(stat) <span class="comment"># fstat always works</span></span><br><span class="line">    _add(<span class="string">&quot;HAVE_FTRUNCATE&quot;</span>,  <span class="string">&quot;truncate&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FUTIMENS&quot;</span>,   <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FUTIMES&quot;</span>,    <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FPATHCONF&quot;</span>,  <span class="string">&quot;pathconf&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _exists(<span class="string">&quot;statvfs&quot;</span>) <span class="keyword">and</span> _exists(<span class="string">&quot;fstatvfs&quot;</span>): <span class="comment"># mac os x10.3</span></span><br><span class="line">        _add(<span class="string">&quot;HAVE_FSTATVFS&quot;</span>, <span class="string">&quot;statvfs&quot;</span>)</span><br><span class="line">    supports_fd = _set</span><br><span class="line"> </span><br><span class="line">    _set = <span class="built_in">set</span>()</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FACCESSAT&quot;</span>,  <span class="string">&quot;access&quot;</span>)</span><br><span class="line">    <span class="comment"># Some platforms don&#x27;t support lchmod().  Often the function exists</span></span><br><span class="line">    <span class="comment"># anyway, as a stub that always returns ENOSUP or perhaps EOPNOTSUPP.</span></span><br><span class="line">    <span class="comment"># (No, I don&#x27;t know why that&#x27;s a good design.)  ./configure will detect</span></span><br><span class="line">    <span class="comment"># this and reject it--so HAVE_LCHMOD still won&#x27;t be defined on such</span></span><br><span class="line">    <span class="comment"># platforms.  This is Very Helpful.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># However, sometimes platforms without a working lchmod() *do* have</span></span><br><span class="line">    <span class="comment"># fchmodat().  (Examples: Linux kernel 3.2 with glibc 2.15,</span></span><br><span class="line">    <span class="comment"># OpenIndiana 3.x.)  And fchmodat() has a flag that theoretically makes</span></span><br><span class="line">    <span class="comment"># it behave like lchmod().  So in theory it would be a suitable</span></span><br><span class="line">    <span class="comment"># replacement for lchmod().  But when lchmod() doesn&#x27;t work, fchmodat()&#x27;s</span></span><br><span class="line">    <span class="comment"># flag doesn&#x27;t work *either*.  Sadly ./configure isn&#x27;t sophisticated</span></span><br><span class="line">    <span class="comment"># enough to detect this condition--it only determines whether or not</span></span><br><span class="line">    <span class="comment"># fchmodat() minimally works.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Therefore we simply ignore fchmodat() when deciding whether or not</span></span><br><span class="line">    <span class="comment"># os.chmod supports follow_symlinks.  Just checking lchmod() is</span></span><br><span class="line">    <span class="comment"># sufficient.  After all--if you have a working fchmodat(), your</span></span><br><span class="line">    <span class="comment"># lchmod() almost certainly works too.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># _add(&quot;HAVE_FCHMODAT&quot;,   &quot;chmod&quot;)</span></span><br><span class="line">    _add(<span class="string">&quot;HAVE_FCHOWNAT&quot;</span>,   <span class="string">&quot;chown&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FSTATAT&quot;</span>,    <span class="string">&quot;stat&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LCHFLAGS&quot;</span>,   <span class="string">&quot;chflags&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LCHMOD&quot;</span>,     <span class="string">&quot;chmod&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _exists(<span class="string">&quot;lchown&quot;</span>): <span class="comment"># mac os x10.3</span></span><br><span class="line">        _add(<span class="string">&quot;HAVE_LCHOWN&quot;</span>, <span class="string">&quot;chown&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LINKAT&quot;</span>,     <span class="string">&quot;link&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LUTIMES&quot;</span>,    <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_LSTAT&quot;</span>,      <span class="string">&quot;stat&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_FSTATAT&quot;</span>,    <span class="string">&quot;stat&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;HAVE_UTIMENSAT&quot;</span>,  <span class="string">&quot;utime&quot;</span>)</span><br><span class="line">    _add(<span class="string">&quot;MS_WINDOWS&quot;</span>,      <span class="string">&quot;stat&quot;</span>)</span><br><span class="line">    supports_follow_symlinks = _set</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">del</span> _set</span><br><span class="line">    <span class="keyword">del</span> _have_functions</span><br><span class="line">    <span class="keyword">del</span> _globals</span><br><span class="line">    <span class="keyword">del</span> _add</span><br></pre></td></tr></table></figure>
<p>这段代码的意思看懂了，但是没有明白它的作用。将一些 globals 里和 _have_functions 同时出现的方法名加到 一个set里，并重新赋值给supports_dir_fd、supports_effective_ids、supports_fd、supports_follow_symlinks四个集合。但是只有supports_dir_fd和supports_fd在后面的代码中用到了，另外两个集合整个代码里都没有用过，不知道是什么作用，先跳过，保留疑问[1]。</p>
<h3 id="第188-193行-定义三个枚举变量"><a href="#第188-193行-定义三个枚举变量" class="headerlink" title="第188~193行 定义三个枚举变量"></a>第188~193行 定义三个枚举变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python uses fixed values for the SEEK_ constants; they are mapped</span></span><br><span class="line"><span class="comment"># to native constants if necessary in posixmodule.c</span></span><br><span class="line"><span class="comment"># Other possible SEEK values are directly imported from posixmodule.c</span></span><br><span class="line">SEEK_SET = <span class="number">0</span></span><br><span class="line">SEEK_CUR = <span class="number">1</span></span><br><span class="line">SEEK_END = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注释的意思是: Python对SEEK_常量使用固定值，如果需要，它们在 posixmodule.c 中被映射到本机常量。其他可能的SEEK_常量值直接从posixmodule.c 导入。</p>
<p>这三个常量一般用作fseek函数的一个入参。fseek函数是C语言中用于二进制方式打开的文件时，移动文件读写指针位置。原型是int fseek(FILE *stream, long offset, int fromwhere); 第一个参数stream为文件指针第，第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移， 第三个参数设定从文件的哪里开始偏移,可能取值为：SEEK_SET： 文件开头；SEEK_CUR： 当前位置；EEK_END： 文件结尾。这三个变量我觉得不用深究，鉴于模块开头的 <strong>all</strong> 里也加入了这三个变量名，应该是在模块外面调用别的函数的时候作为入参使用的，这里定义一下可以起到枚举的作用。</p>
<h3 id="第195-228行-makedirs——创建多级目录"><a href="#第195-228行-makedirs——创建多级目录" class="headerlink" title="第195~228行 makedirs——创建多级目录"></a>第195~228行 makedirs——创建多级目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Super directory utilities.</span></span><br><span class="line"><span class="comment"># (Inspired by Eric Raymond; the doc strings are mostly his)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makedirs</span>(<span class="params">name, mode=<span class="number">0o777</span>, exist_ok=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;makedirs(name [, mode=0o777][, exist_ok=False])</span></span><br><span class="line"><span class="string">    Super-mkdir; create a leaf directory and all intermediate ones.  Works like</span></span><br><span class="line"><span class="string">    mkdir, except that any intermediate path segment (not just the rightmost)</span></span><br><span class="line"><span class="string">    will be created if it does not exist. If the target directory already</span></span><br><span class="line"><span class="string">    exists, raise an OSError if exist_ok is False. Otherwise no exception is</span></span><br><span class="line"><span class="string">    raised.  This is recursive.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    head, tail = path.split(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">        head, tail = path.split(head)</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> tail <span class="keyword">and</span> <span class="keyword">not</span> path.exists(head):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            makedirs(head, exist_ok=exist_ok)</span><br><span class="line">        <span class="keyword">except</span> FileExistsError:</span><br><span class="line">            <span class="comment"># Defeats race condition when another thread created the path</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        cdir = curdir</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tail, <span class="built_in">bytes</span>):</span><br><span class="line">            cdir = <span class="built_in">bytes</span>(curdir, <span class="string">&#x27;ASCII&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tail == cdir:           <span class="comment"># xxx/newdir/. exists if xxx/newdir exists</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mkdir(name, mode)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="comment"># Cannot rely on checking for EEXIST, since the operating system</span></span><br><span class="line">        <span class="comment"># could give priority to other errors like EACCES or EROFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exist_ok <span class="keyword">or</span> <span class="keyword">not</span> path.isdir(name):</span><br><span class="line">            <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p>前面大部分都是一些准备工作，到195行这里才刚刚开始正题。</p>
<p>首先是两行注释：关于目录的方法的超级版。(灵感来自Eric Raymond，the doc strings are mostly his(这句没搞明白啥意思，是文档的内容大部分是他的？))。埃里克·史蒂文·雷蒙德，著名的计算机程序员，开源软件运动的旗手。他是INTERCAL编程语言的主要创作者之一，曾经为EMACS编辑器作出贡献。雷蒙德还是著名的Fetchmail程序的作者。他还编写了一个最初用于Linux内核设置的设置程序——百度百科。</p>
<p>下面定义了 makedirs 方法，这是mkdir方法的超级版本，创建一个子目录和所有中间目录。它和mkdir的区别是：如果要在目录a 下新建一个 ‘a/b/c’ 的目录，makedirs 可以一次新建 b 并且在 b 下新建c，而mkdir 需要先新建 b 再进入到 b 下新建 c，需要调用两次。如果目标目录已经存在，并且 exist_ok 参数是 False，则引发 OSError，exist_ok 参数是 True 则不引发异常。这个函数是通过递归实现前面的功能的。它有3个入参, name 是字符串类型的目标路径名，mode 表示创建的目录的权限，默认值是777，该参数在windows下会被忽略，exist_ok 前面注释里说了，就是在目标路径存在的情况下是否报错。这里可以看出os模块也不是仅仅对nt或posix进行简单封装，还加入了一些更加方便的功能。</p>
<p>看代码要先找准代码的主体部分，然后再去看那些辅助部分。这个方法的主体部分就是该段代码的第19行 makedirs(head, exist_ok=exist_ok) 和第29行 mkdir(name, mode) ，其他是一些条件判断或者校验。</p>
<p>第14行调用 path.split 即 posixpath 或者 ntpath模块的 split 方法。我看了ntpath里的 split 方法，考虑了传入字符串的许多种格式，包括一些写错的情况，当前我们只需要知道它的作用是对传入路径进行分割，以最后一个路径分隔符作为分隔，head和tail。比如传入 ‘C:/ttt/eee/sss/ttt’，返回 head = ‘C:/ttt/eee/sss’，tail = ‘ttt’。下面15行判断 tail 如果为空会再执行一次 split，主要是考虑到传入的参数最后带了路径分隔符的情况，比如传入’C:/ttt/eee/sss/ttt/‘ ，第一次执行split 就会返回 head = ‘C:/ttt/eee/sss/ttt’，tail = ‘’。</p>
<p>第17行是说如果 head 和 tail 都不为空，而且 head已经存在的情况下，调用makedirs进行递归。这里注意递归时mode参数被省略了，也就是说如果创建的是多级目录，除了第一层是用传入的权限，其他子目录都是用的默认参数权限即777，当然这是针对非Windows系统来说的。</p>
<p>第20~22行，如果发生路径已存在的异常，就pass，注释说这样为了避免多线程创建路径的情况。</p>
<p>第23行是取curdir，这个在开头注释中有说明，代表当前目录的字符串，就是 “.” 。</p>
<p>第24~27行，是为了适配最后一个路径是 “.” 的情况，还考虑到路径编码是bytes类型的情况。一开始没看出来这段代码的必要性，于是我将这段代码注释，然后执行 os.makedirs(‘test/test/.’) ，结果出现异常如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200611215702925.png" alt="img"></p>
<p>这是在第30行捕获到的OSError类型的异常，这说明调用底层接口 mkdir(name, mode) 时，对于路径 “.” ，系统会自动解析为当前路径(引发异常时的“当前路径”就是 “test/test” ，已经递归创建了 )，当前路径已经存在，再创建自然会引发异常。但是我想应该不会有人这样传参吧，另外我测了一下路径最后是两个点 “..” 的情况，原代码会直接报异常，毕竟不可能把所有异常入参都覆盖到，这也是我平时写代码比较纠结的地方：到底要不得要把能想到的所有异常都主动捕获并处理掉?</p>
<p>后面的代码就好理解了，经过前面的一系列处理和递归，到第29行时，name 参数已经变成一层目录了，直接调用 nt 或 posix 模块的 mkdir() 就可以创建一层目录了。当然可能会出现一些异常，但这里主要是捕获“路径已存在”类型的异常，注释是说这里之所以捕获 OSError 而不是 EEXISTError ，是因为有的系统发现路径已存在时不一定报已存在而会报其他错误。</p>
<h3 id="第230-250行-removedirs——删除多级目录"><a href="#第230-250行-removedirs——删除多级目录" class="headerlink" title="第230~250行 removedirs——删除多级目录"></a>第230~250行 removedirs——删除多级目录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removedirs</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;removedirs(name)</span></span><br><span class="line"><span class="string">    Super-rmdir; remove a leaf directory and all empty intermediate</span></span><br><span class="line"><span class="string">    ones.  Works like rmdir except that, if the leaf directory is</span></span><br><span class="line"><span class="string">    successfully removed, directories corresponding to rightmost path</span></span><br><span class="line"><span class="string">    segments will be pruned away until either the whole path is</span></span><br><span class="line"><span class="string">    consumed or an error occurs.  Errors during this latter phase are</span></span><br><span class="line"><span class="string">    ignored -- they generally mean that a directory was not empty.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rmdir(name)</span><br><span class="line">    head, tail = path.split(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">        head, tail = path.split(head)</span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> tail:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rmdir(head)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        head, tail = path.split(head)</span><br></pre></td></tr></table></figure>
<p>这是一个删除多级目录的方法，而不是删除文件的。方法注释：删除一个子目录和所有空的中间目录。工作方式与rmdir类似，不同的地方是，如果最底层子目录被成功删除后，此时路径段的最右端目录也将被继续删除，直到整个路径被删除或者出现错误。后面这个阶段中的错误将被忽略——它们通常意味着目录不是空的。就是说，如果传参是”D:/ttt/eee/sss/“ 会先删除sss目录，当然前提是 “sss”目录是空的。此时再看”eee”是否为空，如果是也把”eee”删掉，不为空就此退出。</p>
<p>第11行是调用 “nt” 或 “posix”模块的底层方法 rmdir，作用就是删除一个目录，如果非空会报错。</p>
<p>第12~14行和上面makedirs函数作用一样，是将路径最后一层分隔出来，考虑路径最后有两个斜杠的情况。</p>
<p>后面在循环中依次尝试将分隔出来的 head 删掉，知道出现异常跳出循环。很好理解。</p>
<h3 id="第252-278行-renames——重命名目录或文件"><a href="#第252-278行-renames——重命名目录或文件" class="headerlink" title="第252~278行 renames——重命名目录或文件"></a>第252~278行 renames——重命名目录或文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renames</span>(<span class="params">old, new</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;renames(old, new)</span></span><br><span class="line"><span class="string">    Super-rename; create directories as necessary and delete any left</span></span><br><span class="line"><span class="string">    empty.  Works like rename, except creation of any intermediate</span></span><br><span class="line"><span class="string">    directories needed to make the new pathname good is attempted</span></span><br><span class="line"><span class="string">    first.  After the rename, directories corresponding to rightmost</span></span><br><span class="line"><span class="string">    path segments of the old name will be pruned until either the</span></span><br><span class="line"><span class="string">    whole path is consumed or a nonempty directory is found.</span></span><br><span class="line"><span class="string">    Note: this function can fail with the new directory structure made</span></span><br><span class="line"><span class="string">    if you lack permissions needed to unlink the leaf directory or</span></span><br><span class="line"><span class="string">    file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    head, tail = path.split(new)</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> tail <span class="keyword">and</span> <span class="keyword">not</span> path.exists(head):</span><br><span class="line">        makedirs(head)</span><br><span class="line">    rename(old, new)</span><br><span class="line">    head, tail = path.split(old)</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> tail:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            removedirs(head)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">__all__.extend([<span class="string">&quot;makedirs&quot;</span>, <span class="string">&quot;removedirs&quot;</span>, <span class="string">&quot;renames&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>注释是说: 创建必要的目录，并删除所有空的。类似于重命名，不同的是本函数会首先尝试创建使新路径名有效所需的中间目录。在重命名之后，与旧名称最右边路径段对应的目录将被删除，直到把旧的路径都删完或找到一个非空目录。注意:如果您缺乏断开子目录或文件链接所需的权限，那么在创建新目录结构时，此函数可能会失败。</p>
<p>还是直接看代码好理解一点，第16~18行，先判断新目录的倒数第二层路径是否存在，如果不存在就创建。所以这个函数不仅支持”D:/ttt/eee/ –&gt; D:/ttt/sss” 这种只改最后一层子目录的形式，也支持 “D:/ttt/eee/ –&gt; D:/111/222” 这种同时重命名多级目录的形式，要不说是超级版本呢。只是要注意，不管哪种形式，原来的目录为空的话会被删除，所以这个函数不能用于新建目录，新建目录还是用makedirs吧。 </p>
<p>下面还是调用 “nt”或”posix”里的方法，进行重命名，前面已经把新目录的上一层目录创建好了。再后面就是删除旧路径的过程，从最底层的目录开始，一层一层删过去，出现异常忽略。可以看出好多你自以为优雅的写法，只是标准库帮你把异常报错pass了而已。</p>
<p>最后把刚定义的三个函数加入到__all__里，前面说过__all__会不断进行扩充。</p>
<h3 id="第280-421行-walk——目录树生成器"><a href="#第280-421行-walk——目录树生成器" class="headerlink" title="第280~421行 walk——目录树生成器"></a>第280~421行 walk——目录树生成器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk</span>(<span class="params">top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Directory tree generator.</span></span><br><span class="line"><span class="string">    For each directory in the directory tree rooted at top (including top</span></span><br><span class="line"><span class="string">    itself, but excluding &#x27;.&#x27; and &#x27;..&#x27;), yields a 3-tuple</span></span><br><span class="line"><span class="string">        dirpath, dirnames, filenames</span></span><br><span class="line"><span class="string">    dirpath is a string, the path to the directory.  dirnames is a list of</span></span><br><span class="line"><span class="string">    the names of the subdirectories in dirpath (excluding &#x27;.&#x27; and &#x27;..&#x27;).</span></span><br><span class="line"><span class="string">    filenames is a list of the names of the non-directory files in dirpath.</span></span><br><span class="line"><span class="string">    Note that the names in the lists are just names, with no path components.</span></span><br><span class="line"><span class="string">    To get a full path (which begins with top) to a file or directory in</span></span><br><span class="line"><span class="string">    dirpath, do os.path.join(dirpath, name).</span></span><br><span class="line"><span class="string">    If optional arg &#x27;topdown&#x27; is true or not specified, the triple for a</span></span><br><span class="line"><span class="string">    directory is generated before the triples for any of its subdirectories</span></span><br><span class="line"><span class="string">    (directories are generated top down).  If topdown is false, the triple</span></span><br><span class="line"><span class="string">    for a directory is generated after the triples for all of its</span></span><br><span class="line"><span class="string">    subdirectories (directories are generated bottom up).</span></span><br><span class="line"><span class="string">    When topdown is true, the caller can modify the dirnames list in-place</span></span><br><span class="line"><span class="string">    (e.g., via del or slice assignment), and walk will only recurse into the</span></span><br><span class="line"><span class="string">    subdirectories whose names remain in dirnames; this can be used to prune the</span></span><br><span class="line"><span class="string">    search, or to impose a specific order of visiting.  Modifying dirnames when</span></span><br><span class="line"><span class="string">    topdown is false has no effect on the behavior of os.walk(), since the</span></span><br><span class="line"><span class="string">    directories in dirnames have already been generated by the time dirnames</span></span><br><span class="line"><span class="string">    itself is generated. No matter the value of topdown, the list of</span></span><br><span class="line"><span class="string">    subdirectories is retrieved before the tuples for the directory and its</span></span><br><span class="line"><span class="string">    subdirectories are generated.</span></span><br><span class="line"><span class="string">    By default errors from the os.scandir() call are ignored.  If</span></span><br><span class="line"><span class="string">    optional arg &#x27;onerror&#x27; is specified, it should be a function; it</span></span><br><span class="line"><span class="string">    will be called with one argument, an OSError instance.  It can</span></span><br><span class="line"><span class="string">    report the error to continue with the walk, or raise the exception</span></span><br><span class="line"><span class="string">    to abort the walk.  Note that the filename is available as the</span></span><br><span class="line"><span class="string">    filename attribute of the exception object.</span></span><br><span class="line"><span class="string">    By default, os.walk does not follow symbolic links to subdirectories on</span></span><br><span class="line"><span class="string">    systems that support them.  In order to get this functionality, set the</span></span><br><span class="line"><span class="string">    optional argument &#x27;followlinks&#x27; to true.</span></span><br><span class="line"><span class="string">    Caution:  if you pass a relative pathname for top, don&#x27;t change the</span></span><br><span class="line"><span class="string">    current working directory between resumptions of walk.  walk never</span></span><br><span class="line"><span class="string">    changes the current directory, and assumes that the client doesn&#x27;t</span></span><br><span class="line"><span class="string">    either.</span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">    import os</span></span><br><span class="line"><span class="string">    from os.path import join, getsize</span></span><br><span class="line"><span class="string">    for root, dirs, files in os.walk(&#x27;python/Lib/email&#x27;):</span></span><br><span class="line"><span class="string">        print(root, &quot;consumes&quot;, end=&quot;&quot;)</span></span><br><span class="line"><span class="string">        print(sum(getsize(join(root, name)) for name in files), end=&quot;&quot;)</span></span><br><span class="line"><span class="string">        print(&quot;bytes in&quot;, len(files), &quot;non-directory files&quot;)</span></span><br><span class="line"><span class="string">        if &#x27;CVS&#x27; in dirs:</span></span><br><span class="line"><span class="string">            dirs.remove(&#x27;CVS&#x27;)  # don&#x27;t visit CVS directories</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    top = fspath(top)</span><br><span class="line">    dirs = []</span><br><span class="line">    nondirs = []</span><br><span class="line">    walk_dirs = []</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># We may not have read permission for top, in which case we can&#x27;t</span></span><br><span class="line">    <span class="comment"># get a list of the files the directory contains.  os.walk</span></span><br><span class="line">    <span class="comment"># always suppressed the exception then, rather than blow up for a</span></span><br><span class="line">    <span class="comment"># minor reason when (say) a thousand readable directories are still</span></span><br><span class="line">    <span class="comment"># left to visit.  That logic is copied here.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Note that scandir is global in this module due</span></span><br><span class="line">        <span class="comment"># to earlier import-*.</span></span><br><span class="line">        scandir_it = scandir(top)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">        <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            onerror(error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span> scandir_it:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    entry = <span class="built_in">next</span>(scandir_it)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">                <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    onerror(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                is_dir = entry.is_dir()</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="comment"># If is_dir() raises an OSError, consider that the entry is not</span></span><br><span class="line">                <span class="comment"># a directory, same behaviour than os.path.isdir().</span></span><br><span class="line">                is_dir = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> is_dir:</span><br><span class="line">                dirs.append(entry.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nondirs.append(entry.name)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> topdown <span class="keyword">and</span> is_dir:</span><br><span class="line">                <span class="comment"># Bottom-up: recurse into sub-directory, but exclude symlinks to</span></span><br><span class="line">                <span class="comment"># directories if followlinks is False</span></span><br><span class="line">                <span class="keyword">if</span> followlinks:</span><br><span class="line">                    walk_into = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        is_symlink = entry.is_symlink()</span><br><span class="line">                    <span class="keyword">except</span> OSError:</span><br><span class="line">                        <span class="comment"># If is_symlink() raises an OSError, consider that the</span></span><br><span class="line">                        <span class="comment"># entry is not a symbolic link, same behaviour than</span></span><br><span class="line">                        <span class="comment"># os.path.islink().</span></span><br><span class="line">                        is_symlink = <span class="literal">False</span></span><br><span class="line">                    walk_into = <span class="keyword">not</span> is_symlink</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> walk_into:</span><br><span class="line">                    walk_dirs.append(entry.path)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Yield before recursion if going top down</span></span><br><span class="line">    <span class="keyword">if</span> topdown:</span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        islink, join = path.islink, path.join</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span> dirs:</span><br><span class="line">            new_path = join(top, dirname)</span><br><span class="line">            <span class="comment"># Issue #23605: os.path.islink() is used instead of caching</span></span><br><span class="line">            <span class="comment"># entry.is_symlink() result during the loop on os.scandir() because</span></span><br><span class="line">            <span class="comment"># the caller can replace the directory entry during the &quot;yield&quot;</span></span><br><span class="line">            <span class="comment"># above.</span></span><br><span class="line">            <span class="keyword">if</span> followlinks <span class="keyword">or</span> <span class="keyword">not</span> islink(new_path):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        <span class="keyword">for</span> new_path <span class="keyword">in</span> walk_dirs:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">        <span class="comment"># Yield after recursion if going bottom up</span></span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br><span class="line"> </span><br><span class="line">__all__.append(<span class="string">&quot;walk&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我觉得 walk 函数是这个模块看到现在最符合Python特点的方法，强大，方便，优雅。</p>
<p>首先一段很长的注释，主要介绍了出参和入参。该方法返回一个迭代器，包含一个三元元组，dirpath, dirnames, filenames。</p>
<p>dirpath 是当前遍历的目录的名字，从入参top开始(如果topdown为False的话)，字符串类型；</p>
<p>dirnames 是dirpath中的子目录的名字(路径名字)的列表，list类型；</p>
<p>filenames 是dirpath中的非目录的文件的名字(只有名字)的列表，list类型；</p>
<p>第一个入参 top 就是要遍历的文件夹，字符串类型。如果第二个可选入参 topdown 为 True 或未指定，目录是自顶向下生成的。如果 topdown 为 False ，则目录是自底向上生成的。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录结构：</span></span><br><span class="line"><span class="comment"># ttt</span></span><br><span class="line"><span class="comment">#  ├── sss</span></span><br><span class="line"><span class="comment">#  ├    └──333.txt</span></span><br><span class="line"><span class="comment">#  ├── 111.txt</span></span><br><span class="line"><span class="comment">#  └── 222.txt</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> os.walk(<span class="string">&#x27;ttt&#x27;</span>):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ttt [&#x27;sss&#x27;] [&#x27;111.txt&#x27;, &#x27;222.txt&#x27;]</span></span><br><span class="line"><span class="comment"># ttt\sss [] [&#x27;333.txt&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> os.walk(<span class="string">&#x27;ttt&#x27;</span>, topdown=<span class="literal">True</span>):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ttt\sss [] [&#x27;333.txt&#x27;].</span></span><br><span class="line"><span class="comment"># ttt [&#x27;sss&#x27;] [&#x27;111.txt&#x27;, &#x27;222.txt&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>第三个入参 onerror 是一个回调函数，默认情况下，onerror 参数未指定，此时调用 scandir 方法时，出现的错误将被忽略 (scandir 方法就是 nt 或 posix模块里的底层遍历目录的方法，这个内置方法只能遍历一层目录，所以像前面几个函数一样，walk 方法其实可以看做 scandir 方法的超级版本)。如果可选参数 onerror 被指定，它必须是一个包含一个入参的函数，因为后面的循环中如果出现OSError异常，会将OSError类型实例作为参数传给它。</p>
<p>默认情况下，walk方法不遵循符号链接跳转到它们指向的子目录。为了获得此功能，将可选参数 followlinks 设置为True。这里应该是说类似Linux系统的软连接硬连接那种，该参数用来选择是否迭代它们所指向的目录。我在Windows测试，快捷方式文件是不生效的，它会把快捷方式当成一个普通文件。</p>
<p>注意：如果为top传递的是相对路径名，不要在 walk 函数执行期间之间更改当前工作目录。walk 从不更改当前目录，并假设客户机也不更改当前目录。</p>
<p>看看代码部分：第60行将 top 参数传到 fspath 转换了一下，这个方法是在本模块后面1060行定义的，主要作用是判断传入的参数是不是字符串类型的目录名，如果不是，直接报错。fspath 实现细节后面再具体看。在一些其他语言比如C语言中，要调用一个方法和属性必须在调用出现之前进行定义，在Python这里对这个顺序要求不是很在意。</p>
<p>第61~63行，定义了三个列表，dirs用来存放遍历过程中的目录名，nondirs用来存放遍历过程中的文件的名字，walk_dirs 用来存放要遍历的子目录，用于后面继续迭代它们的子目录。</p>
<p>第65~69行注释，在没有top目录的读权限的情况下，无法获得目录中包含的文件列表。大部分情况下walk总是忽略一些异常，这样避免(比方说)在还有1000个可读目录需要访问时，因为一个小原因而崩溃。这个逻辑复制到这里。</p>
<p>第71~73行，这里是walk函数的核心部分，调用 scandir (nt或posix里的)，这个方法返回一个迭代器，包含入参目录下的所有DirEntry类型的子目录和文件，DirEntry是nt(或posix)模块定义的一个类，包含一个目录或文件的基本信息。这里将其返回的迭代器赋值给scandir_it。这里的注释是提醒scandir是在前面对 nt 模块或者 posix 模块 import * 时引入的。我怀疑os模块不是一个人完成的，因为上面几个函数在调用别的模块的方法时，就没有这种提示，还需要自己去找一些方法或属性的出处。</p>
<p>第74~77行，如果第一级目录再进行遍历的时候就出现了 OSError 类型的异常，就调用回调函数 onerror 方法处理(如果有定义的话)，然后直接返回。</p>
<p>79行开始进入循环。第81~89行取出迭代器 scandir_it 的下一个元素，也就是 top 目录下的第一个子目录或者文件，如果迭代器被迭代完了，就pass。这里同遇到异常，会和74到77行的处理方法一样。</p>
<p>第91~101行，判断取出的第一个元素是不是目录，is_dir 方法是DirEntry类型实例的一个方法。（还记得吗，73行scandir_it = scandir(top)返回的迭代器，里面包含的实例是DirEntry类型的，在83行entry = next(scandir_it)取出）。如果该元素是目录就加到列表 dirs 里，否则加到列表 nondirs 里。</p>
<p>此时，如果 topdown 为True 或未指定，循环体就执行完了。接下来继续遍历，直到把第一层目录下的子目录和文件都分类保存在两个列表里（这里应该想到后面肯定会有递归）。如果topdown 参数为False，而且当前元素是个目录(这里来看链接也算目录)，第103~119行，这里又要考虑followlinks参数，如果为True，就将当前元素的路径加入到列表 walk_dirs 里，如果为Flase或者未指定，当前元素是链接的话就不加入待迭代目录列表walk_dirs，不是链接(普通目录)就加入到walk_dirs。</p>
<p>第121~134行，如果是自顶向下生成的，这时候就可以 yield walk这个迭代器的第一个元素了。然后准备第二个元素(这么说可能不对) ：将 top 和 dirs 里的路径名字组合，形成新的路径名，在for循环中调用walk就完成第二层目录的迭代，这样递归下去就可以遍历到所有的子目录，递归的跳出点就在两个return那里。</p>
<p>第135~140行，如果是自底向上生成的，就先不yield，先去处理待迭代的列表里的路径，层层递归，这样就会先 yield 最低层目录，再 yield 上层的目录。</p>
<p>最后，将walk函数加入到__all__列表里。总的来说，walk这个函数利用Python的迭代器，设计的很巧妙，都看完了让我写也写不出来。</p>
<h3 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a><strong>未完待续……</strong></h3><p>今天写了一下午不知道为啥没保存上，晚上回来打开进度又回到上次写的那里，一下午白干了，刚刚才又凭着记忆重写回来，感觉有的地方跟第一遍用词不一样了。</p>
<p>os模块源码共1115行，到现在才写到421行，这篇文章已经太长了，我决定分成两篇文章，后续写在<a href="https://blog.csdn.net/yushuaigee/article/details/108492310">彻底弄懂Python标准库源码（二）—— os模块（续）</a>里。</p>
<p>这篇文章是我看着源码凭自己理解写的，里面有一些自己的臆断，有看到错误的朋友，麻烦帮忙指出来更正，感谢！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（二）—— os模块（续）</title>
    <url>/2020/09/09/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20os%E6%A8%A1%E5%9D%97%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/108492310">https://blog.csdn.net/yushuaigee/article/details/108492310</a></p>
</blockquote>
<p>本文续 <a href="https://blog.csdn.net/yushuaigee/article/details/106755148">彻底弄懂Python标准库源码（一）—— os模块</a></p>
<p>本文所用 Python3.8.3 标准库 os.py文件, 可以在CPython<a href="https://github.com/python/cpython/blob/3.8/Lib/os.py">官方GitHub地址</a>下载 。</p>
<p><strong>目录</strong></p>
<ul>
<li><p><a href="#%E7%AC%AC423~529%E8%A1%8C%20fwalk%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%A0%91%E7%94%9F%E6%88%90%E5%99%A8">第423~529行 fwalk——目录树生成器</a></p>
</li>
<li><p><a href="#%E7%AC%AC531~654%E8%A1%8C%20exec%E5%87%BD%E6%95%B0%E6%97%8F">第531~654行 exec函数族</a></p>
</li>
<li><p><a href="#%E7%AC%AC657~713%E8%A1%8C%20_Environ%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%A1%E6%81%AF%E7%9A%84%E7%B1%BB">第657~713行 _Environ——环境变量信息的类</a></p>
</li>
<li><p><a href="#%E7%AC%AC715~721%E8%A1%8C%20os.putenv%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第715~721行 os.putenv——设置环境变量</a></p>
</li>
<li><p><a href="#%E7%AC%AC723~729%E8%A1%8C%20os.unsetenv%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第723~729行 os.unsetenv——删除环境变量</a></p>
</li>
<li><p><a href="#%E7%AC%AC731~759%E8%A1%8C%20os.environ%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%A1%E6%81%AF">第731~759行 os.environ——环境变量信息</a></p>
</li>
<li><p><a href="#%E7%AC%AC766~770%E8%A1%8C%20getenv%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第766~770行 getenv——获取环境变量</a></p>
</li>
<li><p><a href="#%E7%AC%AC772~794%E8%A1%8C%20environb%EF%BC%8Cgetenvb%E2%80%94%E2%80%94%E5%AD%97%E8%8A%82%E5%9E%8B(byte)%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第772~794行 environb，getenvb——字节型(byte)环境变量</a></p>
</li>
<li><p><a href="#%E7%AC%AC796~827%E8%A1%8C%20fsencode%EF%BC%8Cfsdecode%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E5%90%8D%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81">第796~827行 fsencode，fsdecode——路径名的编码和解码</a></p>
</li>
<li><p><a href="#%E7%AC%AC829~970%E8%A1%8C%20spawn%E5%87%BD%E6%95%B0%E6%97%8F">第829~970行 spawn函数族</a></p>
</li>
<li><p><a href="#%E7%AC%AC973~1016%E8%A1%8C%20popen%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8Ccmd%E6%88%96%E8%80%85shell%E5%91%BD%E4%BB%A4">第973~1016行 popen——执行cmd或者shell命令</a></p>
</li>
<li><p><a href="#%E7%AC%AC1018~1023%E8%A1%8C%20fdopen%E2%80%94%E2%80%94%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">第1018~1023行 fdopen——打开文件</a></p>
</li>
<li><p><a href="#%E7%AC%AC1026~1061%E8%A1%8C%20fspath%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%A0%87%E5%87%86%E5%8C%96">第1026~1061行 fspath——路径标准化</a></p>
</li>
<li><p><a href="#%E7%AC%AC1064~1077%E8%A1%8C%20PathLike%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AFPathLike">第1064~1077行 PathLike——什么是PathLike</a></p>
</li>
<li><p><a href="#%E7%AC%AC1080~1115%E8%A1%8C%20add_dll_directory%E2%80%94%E2%80%94%20%E6%B7%BB%E5%8A%A0DLL%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径</a></p>
</li>
<li><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
</li>
<li><p><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></p>
</li>
</ul>
<h3 id="第423-529行-fwalk——目录树生成器"><a href="#第423-529行-fwalk——目录树生成器" class="headerlink" title="第423~529行 fwalk——目录树生成器"></a>第423~529行 fwalk——目录树生成器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;<span class="built_in">open</span>, stat&#125; &lt;= supports_dir_fd <span class="keyword">and</span> &#123;scandir, stat&#125; &lt;= supports_fd:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fwalk</span>(<span class="params">top=<span class="string">&quot;.&quot;</span>, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, *, follow_symlinks=<span class="literal">False</span>, dir_fd=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Directory tree generator.</span></span><br><span class="line"><span class="string">        This behaves exactly like walk(), except that it yields a 4-tuple</span></span><br><span class="line"><span class="string">            dirpath, dirnames, filenames, dirfd</span></span><br><span class="line"><span class="string">        `dirpath`, `dirnames` and `filenames` are identical to walk() output,</span></span><br><span class="line"><span class="string">        and `dirfd` is a file descriptor referring to the directory `dirpath`.</span></span><br><span class="line"><span class="string">        The advantage of fwalk() over walk() is that it&#x27;s safe against symlink</span></span><br><span class="line"><span class="string">        races (when follow_symlinks is False).</span></span><br><span class="line"><span class="string">        If dir_fd is not None, it should be a file descriptor open to a directory,</span></span><br><span class="line"><span class="string">          and top should be relative; top will then be relative to that directory.</span></span><br><span class="line"><span class="string">          (dir_fd is always supported for fwalk.)</span></span><br><span class="line"><span class="string">        Caution:</span></span><br><span class="line"><span class="string">        Since fwalk() yields file descriptors, those are only valid until the</span></span><br><span class="line"><span class="string">        next iteration step, so you should dup() them if you want to keep them</span></span><br><span class="line"><span class="string">        for a longer period.</span></span><br><span class="line"><span class="string">        Example:</span></span><br><span class="line"><span class="string">        import os</span></span><br><span class="line"><span class="string">        for root, dirs, files, rootfd in os.fwalk(&#x27;python/Lib/email&#x27;):</span></span><br><span class="line"><span class="string">            print(root, &quot;consumes&quot;, end=&quot;&quot;)</span></span><br><span class="line"><span class="string">            print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),</span></span><br><span class="line"><span class="string">                  end=&quot;&quot;)</span></span><br><span class="line"><span class="string">            print(&quot;bytes in&quot;, len(files), &quot;non-directory files&quot;)</span></span><br><span class="line"><span class="string">            if &#x27;CVS&#x27; in dirs:</span></span><br><span class="line"><span class="string">                dirs.remove(&#x27;CVS&#x27;)  # don&#x27;t visit CVS directories</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(top, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(top, <span class="string">&#x27;__index__&#x27;</span>):</span><br><span class="line">            top = fspath(top)</span><br><span class="line">        <span class="comment"># Note: To guard against symlink races, we use the standard</span></span><br><span class="line">        <span class="comment"># lstat()/open()/fstat() trick.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks:</span><br><span class="line">            orig_st = stat(top, follow_symlinks=<span class="literal">False</span>, dir_fd=dir_fd)</span><br><span class="line">        topfd = <span class="built_in">open</span>(top, O_RDONLY, dir_fd=dir_fd)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> (follow_symlinks <span class="keyword">or</span> (st.S_ISDIR(orig_st.st_mode) <span class="keyword">and</span></span><br><span class="line">                                    path.samestat(orig_st, stat(topfd)))):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> _fwalk(topfd, top, <span class="built_in">isinstance</span>(top, <span class="built_in">bytes</span>),</span><br><span class="line">                                  topdown, onerror, follow_symlinks)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            close(topfd)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fwalk</span>(<span class="params">topfd, toppath, isbytes, topdown, onerror, follow_symlinks</span>):</span></span><br><span class="line">        <span class="comment"># Note: This uses O(depth of the directory tree) file descriptors: if</span></span><br><span class="line">        <span class="comment"># necessary, it can be adapted to only require O(1) FDs, see issue</span></span><br><span class="line">        <span class="comment"># #13734.</span></span><br><span class="line"> </span><br><span class="line">        scandir_it = scandir(topfd)</span><br><span class="line">        dirs = []</span><br><span class="line">        nondirs = []</span><br><span class="line">        entries = <span class="literal">None</span> <span class="keyword">if</span> topdown <span class="keyword">or</span> follow_symlinks <span class="keyword">else</span> []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> scandir_it:</span><br><span class="line">            name = entry.name</span><br><span class="line">            <span class="keyword">if</span> isbytes:</span><br><span class="line">                name = fsencode(name)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">                    dirs.append(name)</span><br><span class="line">                    <span class="keyword">if</span> entries <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        entries.append(entry)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nondirs.append(name)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># Add dangling symlinks, ignore disappeared files</span></span><br><span class="line">                    <span class="keyword">if</span> entry.is_symlink():</span><br><span class="line">                        nondirs.append(name)</span><br><span class="line">                <span class="keyword">except</span> OSError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> topdown:</span><br><span class="line">            <span class="keyword">yield</span> toppath, dirs, nondirs, topfd</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> dirs <span class="keyword">if</span> entries <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">zip</span>(dirs, entries):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks:</span><br><span class="line">                    <span class="keyword">if</span> topdown:</span><br><span class="line">                        orig_st = stat(name, dir_fd=topfd, follow_symlinks=<span class="literal">False</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">assert</span> entries <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                        name, entry = name</span><br><span class="line">                        orig_st = entry.stat(follow_symlinks=<span class="literal">False</span>)</span><br><span class="line">                dirfd = <span class="built_in">open</span>(name, O_RDONLY, dir_fd=topfd)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">                <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    onerror(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> follow_symlinks <span class="keyword">or</span> path.samestat(orig_st, stat(dirfd)):</span><br><span class="line">                    dirpath = path.join(toppath, name)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">from</span> _fwalk(dirfd, dirpath, isbytes,</span><br><span class="line">                                      topdown, onerror, follow_symlinks)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                close(dirfd)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> topdown:</span><br><span class="line">            <span class="keyword">yield</span> toppath, dirs, nondirs, topfd</span><br><span class="line"> </span><br><span class="line">    __all__.append(<span class="string">&quot;fwalk&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第423行 {open, stat} 是定义一个集合 (set)，判断这个集合在 supports_dir_fd 这个集合里并且{scandir, stat} 在 supports_fd 这个集合里，才会定义 fwalk 函数。那么什么情况下判断才会成立呢? 先看一下 supports_dir_fd 和supports_fd是什么意思，这两个集合是在前面123行和143行定义的。</p>
<p>fd在Linux中一般指 file_descriptor 文件描述符。Linux为了实现一切皆文件的设计哲学，不仅将数据抽象成了文件，也将一切操作和资源抽象成了文件，比如说硬件设备，socket，磁盘，进程，线程等。在操作这些所谓的文件的时候，我们每操作一次就找一次名字会耗费大量的时间和效率。所以每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。我们将这个索引叫做文件描述符（file descriptor），简称fd，在系统里面是一个非负的整数。每打开或创建一个文件，内核就会向进程返回一个fd，第一个打开文件是0,第二个是1，依次递增。（关于文件描述符详细理解，可以参考我的另一篇博文—— <a href="https://blog.csdn.net/yushuaigee/article/details/107883964">彻底弄懂 Linux 下的文件描述符</a>）</p>
<p>我理解在这里也类似，知道两个集合命名中 fd 的意思有助于理解这两个集合的含义和后面 fwalk 函数最后一个参数的含义。 不同的系统都会支持对文件目录、文件进行一些操作，比如chmod，mkdir这些。这些操作会在Python解释器启动的时候被加载在builtins的globals()字典里变成了内置方法，chmod，mkdir 这些字符串作为键，对应的具体的操作函数作为值。通过102行的_add函数处理进行过滤，只留下当前系统所支持的那些，supports_dir_fd 里面放的就是对文件目录进行操作的函数，supports_fd里面放的就是文件进行操作的函数。过滤过程是根据chmod，mkdir这些键来过滤的，类似根据索引来找具体方法一样。总之，这一行的判断其实可以看做是为了识别在不同的系统中是否定义fwalk 方法，这里经过测试，windows下判断不通过，Linux下判断通过。也就是说os模块，在Linux下有 fwalk 方法，而在Wndows下没有 fwalk 方法。</p>
<p>第425行，可以看出 fwalk 这个函数和前面的 walk 类似，但是多了一个参数 dir_fd=None（参数入参中的那个星号 * 的意思可以参考我的另一篇博客——<a href="https://blog.csdn.net/yushuaigee/article/details/107567001">彻底弄懂 Python3中入参里的*号的作用</a>）。</p>
<p>注释是说：函数作用是目录树生成器。</p>
<p>这个函数除了返回值是一个四元组(dirpath, dirnames, filenames, dirfd)之外，其他实现情况和 walk() 是完全相同的。前三个参数的意义和 walk() 也相同，最后一个参数 dirfd 是目录 dirpath 的文件描述符。</p>
<p>fwalk() 比walk() 的优点是，当可选参数 follow_symlinks is False 时，这个函数对于 symlink race 漏洞是安全的。(symlink race，符号链接竞争漏洞，见 <a href="https://en.wikipedia.org/wiki/Symlink_race">Symlink race—-Wikipedia</a>)。如果 dir_fd 参数不是 None，它应该是指向某个目录的文件描述符，并且 top 参数也应该对应修改，改为相对于该目录的相对路径。(fwalk始终支持dir_fd)。</p>
<p>注意：由于fwalk()产生文件描述符，这些描述符仅在下一个迭代步骤之前有效，所以如果要想保留更长的时间应该用dup()函数处理它们。(dup是一个复制文件描述符的系统函数)。</p>
<p>第458~459行，将 top 转化为标准字符串目录。</p>
<p>第460<del>462行，当 follow_syslinks 为False时，调用系统函数 stat 获取 top 的基本信息。然后调用系统函数 open 获取 top 的文件描述符。(关于 stat 函数见 <a href="https://blog.csdn.net/u011150719/article/details/50865280">linux stat函数（获取文件详细信息）</a>)。通过这些处理能防止 symlink races 漏洞，具体原因见下面 43</del>49 行。</p>
<p>第465~471行，当follow_syslinks 为True时，直接调用 _fwalk 函数返回结果。而 follow_syslinks 为False时，后面的(st.S_ISDIR(orig_st.st_mode) and path.samestat(orig_st, stat(topfd))) 可以生效，首先判断 top 的st_mode(文件的类型和存取的权限)是目录而不是符号链接，然后判断 top 和 top的文件描述符(topfd) 的 st_dev(文件的设备编号) 和 st_dev(节点) 是相同的，只有两个条件都成立时才继续往下调用 _fwalk 函数来返回结果。 _fwalk 函数使用文件描述符进行操作，避免直接操作 top 目录时，中途被伪造成同名的指向其他路径的符号链接。并且经过前面两个条件的验证，保证了传入是原来的 top 目录的文件描述符。</p>
<p>下面的 _fwalk 逻辑和前面的 walk 基本类似，不同的地方是这里递归时用的是文件描述符。</p>
<h3 id="第531-654行-exec函数族"><a href="#第531-654行-exec函数族" class="headerlink" title="第531~654行 exec函数族"></a>第531~654行 exec函数族</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execl</span>(<span class="params">file, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execl(file, *args)</span></span><br><span class="line"><span class="string">    Execute the executable file with argument list args, replacing the</span></span><br><span class="line"><span class="string">    current process. &quot;&quot;&quot;</span></span><br><span class="line">    execv(file, args)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execle</span>(<span class="params">file, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execle(file, *args, env)</span></span><br><span class="line"><span class="string">    Execute the executable file with argument list args and</span></span><br><span class="line"><span class="string">    environment env, replacing the current process. &quot;&quot;&quot;</span></span><br><span class="line">    env = args[-<span class="number">1</span>]</span><br><span class="line">    execve(file, args[:-<span class="number">1</span>], env)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execlp</span>(<span class="params">file, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execlp(file, *args)</span></span><br><span class="line"><span class="string">    Execute the executable file (which is searched for along $PATH)</span></span><br><span class="line"><span class="string">    with argument list args, replacing the current process. &quot;&quot;&quot;</span></span><br><span class="line">    execvp(file, args)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execlpe</span>(<span class="params">file, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execlpe(file, *args, env)</span></span><br><span class="line"><span class="string">    Execute the executable file (which is searched for along $PATH)</span></span><br><span class="line"><span class="string">    with argument list args and environment env, replacing the current</span></span><br><span class="line"><span class="string">    process. &quot;&quot;&quot;</span></span><br><span class="line">    env = args[-<span class="number">1</span>]</span><br><span class="line">    execvpe(file, args[:-<span class="number">1</span>], env)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execvp</span>(<span class="params">file, args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execvp(file, args)</span></span><br><span class="line"><span class="string">    Execute the executable file (which is searched for along $PATH)</span></span><br><span class="line"><span class="string">    with argument list args, replacing the current process.</span></span><br><span class="line"><span class="string">    args may be a list or tuple of strings. &quot;&quot;&quot;</span></span><br><span class="line">    _execvpe(file, args)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execvpe</span>(<span class="params">file, args, env</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;execvpe(file, args, env)</span></span><br><span class="line"><span class="string">    Execute the executable file (which is searched for along $PATH)</span></span><br><span class="line"><span class="string">    with argument list args and environment env, replacing the</span></span><br><span class="line"><span class="string">    current process.</span></span><br><span class="line"><span class="string">    args may be a list or tuple of strings. &quot;&quot;&quot;</span></span><br><span class="line">    _execvpe(file, args, env)</span><br><span class="line"> </span><br><span class="line">__all__.extend([<span class="string">&quot;execl&quot;</span>,<span class="string">&quot;execle&quot;</span>,<span class="string">&quot;execlp&quot;</span>,<span class="string">&quot;execlpe&quot;</span>,<span class="string">&quot;execvp&quot;</span>,<span class="string">&quot;execvpe&quot;</span>])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execvpe</span>(<span class="params">file, args, env=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        exec_func = execve</span><br><span class="line">        argrest = (args, env)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exec_func = execv</span><br><span class="line">        argrest = (args,)</span><br><span class="line">        env = environ</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> path.dirname(file):</span><br><span class="line">        exec_func(file, *argrest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    saved_exc = <span class="literal">None</span></span><br><span class="line">    path_list = get_exec_path(env)</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        file = fsencode(file)</span><br><span class="line">        path_list = <span class="built_in">map</span>(fsencode, path_list)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> path_list:</span><br><span class="line">        fullname = path.join(<span class="built_in">dir</span>, file)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exec_func(fullname, *argrest)</span><br><span class="line">        <span class="keyword">except</span> (FileNotFoundError, NotADirectoryError) <span class="keyword">as</span> e:</span><br><span class="line">            last_exc = e</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            last_exc = e</span><br><span class="line">            <span class="keyword">if</span> saved_exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                saved_exc = e</span><br><span class="line">    <span class="keyword">if</span> saved_exc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> saved_exc</span><br><span class="line">    <span class="keyword">raise</span> last_exc</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_exec_path</span>(<span class="params">env=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the sequence of directories that will be searched for the</span></span><br><span class="line"><span class="string">    named executable (similar to a shell) when launching a process.</span></span><br><span class="line"><span class="string">    *env* must be an environment variable dict or None.  If *env* is None,</span></span><br><span class="line"><span class="string">    os.environ will be used.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Use a local import instead of a global import to limit the number of</span></span><br><span class="line">    <span class="comment"># modules loaded at startup: the os module is always loaded at startup by</span></span><br><span class="line">    <span class="comment"># Python. It may also avoid a bootstrap issue.</span></span><br><span class="line">    <span class="keyword">import</span> warnings</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        env = environ</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># &#123;b&#x27;PATH&#x27;: ...&#125;.get(&#x27;PATH&#x27;) and &#123;&#x27;PATH&#x27;: ...&#125;.get(b&#x27;PATH&#x27;) emit a</span></span><br><span class="line">    <span class="comment"># BytesWarning when using python -b or python -bb: ignore the warning</span></span><br><span class="line">    <span class="keyword">with</span> warnings.catch_warnings():</span><br><span class="line">        warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, BytesWarning)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            path_list = env.get(<span class="string">&#x27;PATH&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            path_list = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> supports_bytes_environ:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                path_listb = env[<span class="string">b&#x27;PATH&#x27;</span>]</span><br><span class="line">            <span class="keyword">except</span> (KeyError, TypeError):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> path_list <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(</span><br><span class="line">                        <span class="string">&quot;env cannot contain &#x27;PATH&#x27; and b&#x27;PATH&#x27; keys&quot;</span>)</span><br><span class="line">                path_list = path_listb</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> path_list <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(path_list, <span class="built_in">bytes</span>):</span><br><span class="line">                path_list = fsdecode(path_list)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> path_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        path_list = defpath</span><br><span class="line">    <span class="keyword">return</span> path_list.split(pathsep)</span><br></pre></td></tr></table></figure>
<p>这里的6个函数类似Linux中6个以exec开头的函数族：execl、execv、execle、execve、execlp、execvp。(并非一一对应)</p>
<p>Linux中的 exec 函数族提供了一种方法，在不改变进程号的情况下用新的进程替代原来的进程。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。这6个函数中真正的系统调用只有execve，其他5个都是库函数，它们最终都会调用execve这个系统调用。(详见 <a href="https://blog.csdn.net/guoping16/article/details/6583383">exec函数</a>)</p>
<p>第531~536行，<strong>execl</strong> 函数，对应Linux中的<strong>execl</strong>函数，作用是调用python内置函数execv执行一个可执行文件替代现有进程，入参是文件完整路径和参数。</p>
<blockquote>
<p>示例： <strong>os.execl(‘/usr/bin/cat’, ‘/root/test.py’, ‘/root/test2.py’)</strong></p>
</blockquote>
<p>第538~544行，<strong>execle</strong> 函数，对应Linux中的<strong>execle</strong>函数，作用是调用python内置函数execve执行一个可执行文件替代现有进程，入参是文件完整路径、参数、新程序的环境变量路径(最后一个参数,字典类型)。这里注意第一个参数要传入新程序的完整路径。传入的环境路径作为新程序的环境变量路径。</p>
<blockquote>
<p>示例 ：<strong>os.execle(‘/usr/bin/cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘SYS’: ‘/root/bin’})</strong></p>
</blockquote>
<p>第546~551行，<strong>execlp</strong> 函数，对应Linux中的<strong>execlp</strong>函数，作用是调用python内置函数execvp执行一个可执行文件替代现有进程，入参是文件名、参数。这里第一个入参只需要填写新程序的文件名，会去系统默认环境变量路径查找该文件。</p>
<blockquote>
<p>示例 ：<strong>os.execlp(‘cat’, ‘/root/test.py’, ‘/root/test2.py’)</strong></p>
</blockquote>
<p>第553~560行，<strong>execlpe</strong> 函数，对应Linux中的<strong>execve</strong>函数，作用是调用python内置函数execvpe执行一个可执行文件替代现有进程，入参是文件名、参数、新程序的环境变量路径。这里注意第一个入参只需要填写新程序的文件名，会去传入的环境路径查找该文件，如果没有则去系统默认环境变量PATH查找。</p>
<blockquote>
<p>示例 ：<strong>os.execlpe(‘cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘SYS’: ‘/root/bin’})</strong></p>
</blockquote>
<p><strong>注意</strong>下面这种情况，比如 cat 程序是在系统环境变量PATH中的’/usr/bin’目录下，传入的环境变量覆盖了系统默认环境变量PATH，没有加’/usr/bin’，此时将找不到 cat (示例1)。此时需要加上 cat 所在的目录，用冒号”<strong>:</strong>“隔开(示例2，示例3)。</p>
<blockquote>
<p>示例 1：<strong>os.execlpe(‘cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘PATH’: ‘/root/bin’})</strong></p>
<p>示例 2：<strong>os.execlpe(‘cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘PATH’: ‘/root/bin:/usr/bin**</strong>‘})**</p>
<p>示例 2：<strong>os.execlpe(‘cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘SYS’: ‘/root/bin:/usr/bin’})</strong></p>
</blockquote>
<p> 第562<del>568行，<strong>execvp</strong> 函数，作用同第546</del>551行 <strong>execlp</strong> 函数，依然对应Linux中的 <strong>execlp</strong> 函数。不同的地方是这里的参数要用列表类型传入。</p>
<blockquote>
<p>示例 ：<strong>os.execvp(‘cat’, [‘/root/test.py’, ‘/root/test2.py’])</strong></p>
</blockquote>
<p> 第570<del>577行，<strong>execvpe</strong> 函数，作用同第553</del>560行 <strong>execlpe</strong> 函数，依然对应Linux中的 <strong>execve</strong> 函数。不同的地方是这里的参数要用列表类型传入。</p>
<blockquote>
<p>示例 ：<strong>os.execvpe(‘cat’, [‘/root/test.py’, ‘/root/test2.py’], {‘SYS’: ‘/root/bin’})</strong></p>
</blockquote>
<p>以上可以看出这6个<strong>exec</strong>函数和Linux原生的6个<strong>exec</strong>函数虽然功能类似，但是还是有些区别的，需要使用时要注意一些细节。</p>
<p>第581~ 654行是<strong>_execvpe</strong> 的定义，<strong>execvp</strong> 函数和<strong>execvpe</strong> 函数均调用此函数。<strong>_execvpe</strong> 将列表参数解成字符串参数，最终还是落到execv和execve函数上。这一段的几个函数看着很冗余，不够优雅，不知道大佬们写的时候怎么想的。</p>
<h3 id="第657-713行-Environ——环境变量信息的类"><a href="#第657-713行-Environ——环境变量信息的类" class="headerlink" title="第657~713行 _Environ——环境变量信息的类"></a>第657~713行 _Environ——环境变量信息的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Change environ to automatically call putenv(), unsetenv if they exist.</span></span><br><span class="line"><span class="keyword">from</span> _collections_abc <span class="keyword">import</span> MutableMapping</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Environ</span>(<span class="params">MutableMapping</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, encodekey, decodekey, encodevalue, decodevalue, putenv, unsetenv</span>):</span></span><br><span class="line">        self.encodekey = encodekey</span><br><span class="line">        self.decodekey = decodekey</span><br><span class="line">        self.encodevalue = encodevalue</span><br><span class="line">        self.decodevalue = decodevalue</span><br><span class="line">        self.putenv = putenv</span><br><span class="line">        self.unsetenv = unsetenv</span><br><span class="line">        self._data = data</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self._data[self.encodekey(key)]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># raise KeyError with the original key value</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.decodevalue(value)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        key = self.encodekey(key)</span><br><span class="line">        value = self.encodevalue(value)</span><br><span class="line">        self.putenv(key, value)</span><br><span class="line">        self._data[key] = value</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        encodedkey = self.encodekey(key)</span><br><span class="line">        self.unsetenv(encodedkey)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self._data[encodedkey]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># raise KeyError with the original key value</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># list() from dict object is an atomic operation</span></span><br><span class="line">        keys = <span class="built_in">list</span>(self._data)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">yield</span> self.decodekey(key)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._data)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;environ(&#123;&#123;&#123;&#125;&#125;&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;, &#x27;</span>.join(</span><br><span class="line">            (<span class="string">&#x27;&#123;!r&#125;: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(self.decodekey(key), self.decodevalue(value))</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> self._data.items())))</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(self)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setdefault</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            self[key] = value</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br></pre></td></tr></table></figure>
<p>这个类实际上就是生成 os.environ 的类，能够获取系统所有的环境变量信息。</p>
<p>第658行，从抽象类模块_collections_abc 导入 MutableMapping类，python3中这个类也是字典的父类。平时我们经常用os.environ.get(‘xxx’)，和字典很类似，就是因为_Environ这个类重写了<strong>getitem</strong>()等方法。但是os.environ并不是字典类型，如果用 print(type(os.environ)) 会发现，它的类型是 &lt;class ‘os._Environ’&gt; 。</p>
<p>为什么要定义 encode和decode 那几个入参，见772~794行。</p>
<h3 id="第715-721行-os-putenv——设置环境变量"><a href="#第715-721行-os-putenv——设置环境变量" class="headerlink" title="第715~721行 os.putenv——设置环境变量"></a>第715~721行 os.putenv——设置环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _putenv = putenv</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    _putenv = <span class="keyword">lambda</span> key, value: <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;putenv&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> __all__:</span><br><span class="line">        __all__.append(<span class="string">&quot;putenv&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>调用 nt 或者 posix 库的 putenv 方法， 通过**os.putenv(‘key’, ‘value’)**将名为 key 的环境变量值设置为 value。该变量名修改会影响由 os.system(),popen(),fork()和execv()发起的子进程。但是putenv()的调用不会更新 os.environ，因此最好使用os.environ来更改环境变量。</p>
<h3 id="第723-729行-os-unsetenv——删除环境变量"><a href="#第723-729行-os-unsetenv——删除环境变量" class="headerlink" title="第723~729行 os.unsetenv——删除环境变量"></a>第723~729行 os.unsetenv——删除环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _unsetenv = unsetenv</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    _unsetenv = <span class="keyword">lambda</span> key: _putenv(key, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;unsetenv&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> __all__:</span><br><span class="line">        __all__.append(<span class="string">&quot;unsetenv&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第723-729行-os-unsetenv——删除环境变量-1"><a href="#第723-729行-os-unsetenv——删除环境变量-1" class="headerlink" title="第723~729行 os.unsetenv——删除环境变量"></a>第723~729行 os.unsetenv——删除环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _unsetenv = unsetenv</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    _unsetenv = <span class="keyword">lambda</span> key: _putenv(key, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;unsetenv&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> __all__:</span><br><span class="line">        __all__.append(<span class="string">&quot;unsetenv&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>调用 nt 或者 posix 库的 unsetenv 方法， 通过**os.unsetenv (‘key’)**删除名为 key 的环境变量。该变量名删除会影响由 os.system(),popen(),fork()和execv()发起的子进程。但是unsetenv()的调用不会更新 os.environ，因此最好直接删除 os.environ 中的变量。</p>
<h3 id="第731-759行-os-environ——环境变量信息"><a href="#第731-759行-os-environ——环境变量信息" class="headerlink" title="第731~759行 os.environ——环境变量信息"></a>第731~759行 os.environ——环境变量信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_createenviron</span>():</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        <span class="comment"># Where Env Var Names Must Be UPPERCASE</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check_str</span>(<span class="params">value</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">&quot;str expected, not %s&quot;</span> % <span class="built_in">type</span>(value).__name__)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        encode = check_str</span><br><span class="line">        decode = <span class="built_in">str</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">encodekey</span>(<span class="params">key</span>):</span></span><br><span class="line">            <span class="keyword">return</span> encode(key).upper()</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> environ.items():</span><br><span class="line">            data[encodekey(key)] = value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Where Env Var Names Can Be Mixed Case</span></span><br><span class="line">        encoding = sys.getfilesystemencoding()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">value</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">&quot;str expected, not %s&quot;</span> % <span class="built_in">type</span>(value).__name__)</span><br><span class="line">            <span class="keyword">return</span> value.encode(encoding, <span class="string">&#x27;surrogateescape&#x27;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">value</span>):</span></span><br><span class="line">            <span class="keyword">return</span> value.decode(encoding, <span class="string">&#x27;surrogateescape&#x27;</span>)</span><br><span class="line">        encodekey = encode</span><br><span class="line">        data = environ</span><br><span class="line">    <span class="keyword">return</span> _Environ(data,</span><br><span class="line">        encodekey, decode,</span><br><span class="line">        encode, decode,</span><br><span class="line">        _putenv, _unsetenv)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># unicode environ</span></span><br><span class="line">environ = _createenviron()</span><br><span class="line"><span class="keyword">del</span> _createenviron</span><br></pre></td></tr></table></figure>
<p>这段代码就是生成 os.environ 的过程。注意743行和755行，用到了 environ，而搜索整个 os.py 文件，只有在后面762行定义了 environ ，看上去好像自己定义自己了，这是怎么回事呢？</p>
<p>因为此 environ 非彼 environ，经过打桩调试，可以发现743行和755行的 environ 是字典类型，表示当前系统的所有环境变量的键值对，是在53行(from posix import *)或73行(from nt import *)从内置库引入的(取决于系统类型)。这段代码太有迷惑性了，还是挺坑的。理解了这个，也就可以明白 os.environ 其实还是对 nt 或者 posix 库里的environ的一层封装，整个os库其实做的就是封装这件事。至于为啥把原来的字典类型变成一种新的类型，我也不知道，额 ~。</p>
<h3 id="第766-770行-getenv——获取环境变量"><a href="#第766-770行-getenv——获取环境变量" class="headerlink" title="第766~770行 getenv——获取环境变量"></a>第766~770行 getenv——获取环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getenv</span>(<span class="params">key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get an environment variable, return None if it doesn&#x27;t exist.</span></span><br><span class="line"><span class="string">    The optional second argument can specify an alternate default.</span></span><br><span class="line"><span class="string">    key, default and the result are str.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> environ.get(key, default)</span><br></pre></td></tr></table></figure>
<p> 通过**os.unsetenv (‘key’)**获取环境变量key的值，如果存在，返回环境变量key的值，否则返回default的值。key和返回值均为str字符串类型。</p>
<h3 id="第772-794行-environb，getenvb——字节型-byte-环境变量"><a href="#第772-794行-environb，getenvb——字节型-byte-环境变量" class="headerlink" title="第772~794行 environb，getenvb——字节型(byte)环境变量"></a>第772~794行 environb，getenvb——字节型(byte)环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">supports_bytes_environ = (name != <span class="string">&#x27;nt&#x27;</span>)</span><br><span class="line">__all__.extend((<span class="string">&quot;getenv&quot;</span>, <span class="string">&quot;supports_bytes_environ&quot;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> supports_bytes_environ:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_bytes</span>(<span class="params">value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;bytes expected, not %s&quot;</span> % <span class="built_in">type</span>(value).__name__)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># bytes environ</span></span><br><span class="line">    environb = _Environ(environ._data,</span><br><span class="line">        _check_bytes, <span class="built_in">bytes</span>,</span><br><span class="line">        _check_bytes, <span class="built_in">bytes</span>,</span><br><span class="line">        _putenv, _unsetenv)</span><br><span class="line">    <span class="keyword">del</span> _check_bytes</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getenvb</span>(<span class="params">key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get an environment variable, return None if it doesn&#x27;t exist.</span></span><br><span class="line"><span class="string">        The optional second argument can specify an alternate default.</span></span><br><span class="line"><span class="string">        key, default and the result are bytes.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> environb.get(key, default)</span><br><span class="line"> </span><br><span class="line">    __all__.extend((<span class="string">&quot;environb&quot;</span>, <span class="string">&quot;getenvb&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>设置标志位 supports_bytes_environ 判断当前系统类型是否是Windows。顾名思义，Windows不支持byte类型的环境变量。</p>
<p>在支持byte类型的环境变量的系统中，定义byte类型的 <strong>os.environb</strong> 对应字符串类型的 <strong>os.environ ,</strong> 定义byte类型的 <strong>os.getenvb</strong> 对应字符串类型的 <strong>os.getenv</strong> 。到这里也就明白为什么前面 _Environ 类要定义 encode和decode 那些入参了。</p>
<h3 id="第796-827行-fsencode，fsdecode——路径名的编码和解码"><a href="#第796-827行-fsencode，fsdecode——路径名的编码和解码" class="headerlink" title="第796~827行 fsencode，fsdecode——路径名的编码和解码"></a>第796~827行 fsencode，fsdecode——路径名的编码和解码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fscodec</span>():</span></span><br><span class="line">    encoding = sys.getfilesystemencoding()</span><br><span class="line">    errors = sys.getfilesystemencodeerrors()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fsencode</span>(<span class="params">filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encode filename (an os.PathLike, bytes, or str) to the filesystem</span></span><br><span class="line"><span class="string">        encoding with &#x27;surrogateescape&#x27; error handler, return bytes unchanged.</span></span><br><span class="line"><span class="string">        On Windows, use &#x27;strict&#x27; error handler if the file system encoding is</span></span><br><span class="line"><span class="string">        &#x27;mbcs&#x27; (which is the default encoding).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        filename = fspath(filename)  <span class="comment"># Does type-checking of `filename`.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(filename, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> filename.encode(encoding, errors)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filename</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fsdecode</span>(<span class="params">filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decode filename (an os.PathLike, bytes, or str) from the filesystem</span></span><br><span class="line"><span class="string">        encoding with &#x27;surrogateescape&#x27; error handler, return str unchanged. On</span></span><br><span class="line"><span class="string">        Windows, use &#x27;strict&#x27; error handler if the file system encoding is</span></span><br><span class="line"><span class="string">        &#x27;mbcs&#x27; (which is the default encoding).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        filename = fspath(filename)  <span class="comment"># Does type-checking of `filename`.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(filename, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">return</span> filename.decode(encoding, errors)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filename</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> fsencode, fsdecode</span><br><span class="line"> </span><br><span class="line">fsencode, fsdecode = _fscodec()</span><br><span class="line"><span class="keyword">del</span> _fscodec</span><br></pre></td></tr></table></figure>
<p>先将路径名转化成标准路径名，即 os.PathLike 的，然后再进行编码和解码的操作，没啥好说的。</p>
<h3 id="第829-970行-spawn函数族"><a href="#第829-970行-spawn函数族" class="headerlink" title="第829~970行 spawn函数族"></a>第829~970行 spawn函数族</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Supply spawn*() (probably only for Unix)</span></span><br><span class="line"><span class="keyword">if</span> _exists(<span class="string">&quot;fork&quot;</span>) <span class="keyword">and</span> <span class="keyword">not</span> _exists(<span class="string">&quot;spawnv&quot;</span>) <span class="keyword">and</span> _exists(<span class="string">&quot;execv&quot;</span>):</span><br><span class="line"> </span><br><span class="line">    P_WAIT = <span class="number">0</span></span><br><span class="line">    P_NOWAIT = P_NOWAITO = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    __all__.extend([<span class="string">&quot;P_WAIT&quot;</span>, <span class="string">&quot;P_NOWAIT&quot;</span>, <span class="string">&quot;P_NOWAITO&quot;</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># XXX Should we support P_DETACH?  I suppose it could fork()**2</span></span><br><span class="line">    <span class="comment"># and close the std I/O streams.  Also, P_OVERLAY is the same</span></span><br><span class="line">    <span class="comment"># as execv*()?</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_spawnvef</span>(<span class="params">mode, file, args, env, func</span>):</span></span><br><span class="line">        <span class="comment"># Internal helper; func is the exec*() function to use</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(args, (<span class="built_in">tuple</span>, <span class="built_in">list</span>)):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;argv must be a tuple or a list&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> args <span class="keyword">or</span> <span class="keyword">not</span> args[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;argv first element cannot be empty&#x27;</span>)</span><br><span class="line">        pid = fork()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pid:</span><br><span class="line">            <span class="comment"># Child</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> env <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    func(file, args)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    func(file, args, env)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                _exit(<span class="number">127</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Parent</span></span><br><span class="line">            <span class="keyword">if</span> mode == P_NOWAIT:</span><br><span class="line">                <span class="keyword">return</span> pid <span class="comment"># Caller is responsible for waiting!</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                wpid, sts = waitpid(pid, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> WIFSTOPPED(sts):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> WIFSIGNALED(sts):</span><br><span class="line">                    <span class="keyword">return</span> -WTERMSIG(sts)</span><br><span class="line">                <span class="keyword">elif</span> WIFEXITED(sts):</span><br><span class="line">                    <span class="keyword">return</span> WEXITSTATUS(sts)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> OSError(<span class="string">&quot;Not stopped, signaled or exited???&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnv</span>(<span class="params">mode, file, args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnv(mode, file, args) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file with arguments from args in a subprocess.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _spawnvef(mode, file, args, <span class="literal">None</span>, execv)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnve</span>(<span class="params">mode, file, args, env</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnve(mode, file, args, env) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file with arguments from args in a subprocess with the</span></span><br><span class="line"><span class="string">specified environment.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _spawnvef(mode, file, args, env, execve)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Note: spawnvp[e] isn&#x27;t currently supported on Windows</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnvp</span>(<span class="params">mode, file, args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnvp(mode, file, args) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file (which is looked for along $PATH) with arguments from</span></span><br><span class="line"><span class="string">args in a subprocess.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _spawnvef(mode, file, args, <span class="literal">None</span>, execvp)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnvpe</span>(<span class="params">mode, file, args, env</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnvpe(mode, file, args, env) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file (which is looked for along $PATH) with arguments from</span></span><br><span class="line"><span class="string">args in a subprocess with the supplied environment.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _spawnvef(mode, file, args, env, execvpe)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    __all__.extend([<span class="string">&quot;spawnv&quot;</span>, <span class="string">&quot;spawnve&quot;</span>, <span class="string">&quot;spawnvp&quot;</span>, <span class="string">&quot;spawnvpe&quot;</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> _exists(<span class="string">&quot;spawnv&quot;</span>):</span><br><span class="line">    <span class="comment"># These aren&#x27;t supplied by the basic Windows code</span></span><br><span class="line">    <span class="comment"># but can be easily implemented in Python</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnl</span>(<span class="params">mode, file, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnl(mode, file, *args) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file with arguments from args in a subprocess.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> spawnv(mode, file, args)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnle</span>(<span class="params">mode, file, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnle(mode, file, *args, env) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file with arguments from args in a subprocess with the</span></span><br><span class="line"><span class="string">supplied environment.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        env = args[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> spawnve(mode, file, args[:-<span class="number">1</span>], env)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    __all__.extend([<span class="string">&quot;spawnl&quot;</span>, <span class="string">&quot;spawnle&quot;</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> _exists(<span class="string">&quot;spawnvp&quot;</span>):</span><br><span class="line">    <span class="comment"># At the moment, Windows doesn&#x27;t implement spawnvp[e],</span></span><br><span class="line">    <span class="comment"># so it won&#x27;t have spawnlp[e] either.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnlp</span>(<span class="params">mode, file, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnlp(mode, file, *args) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file (which is looked for along $PATH) with arguments from</span></span><br><span class="line"><span class="string">args in a subprocess with the supplied environment.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> spawnvp(mode, file, args)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spawnlpe</span>(<span class="params">mode, file, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;spawnlpe(mode, file, *args, env) -&gt; integer</span></span><br><span class="line"><span class="string">Execute file (which is looked for along $PATH) with arguments from</span></span><br><span class="line"><span class="string">args in a subprocess with the supplied environment.</span></span><br><span class="line"><span class="string">If mode == P_NOWAIT return the pid of the process.</span></span><br><span class="line"><span class="string">If mode == P_WAIT return the process&#x27;s exit code if it exits normally;</span></span><br><span class="line"><span class="string">otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</span></span><br><span class="line">        env = args[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> spawnvpe(mode, file, args[:-<span class="number">1</span>], env)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    __all__.extend([<span class="string">&quot;spawnlp&quot;</span>, <span class="string">&quot;spawnlpe&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>此处的 spawn 函数族对应 LInux 中的 spawn 函数族，并不完全相同。实际上，Linux中spawn()函数族与exec()函数族有相似也有区别。exec()是启动一个程序并取代原来的程序，spawn()函数既可以在结束原来的程序后启动另一个程序，也可以启动另一个程序并在该程序结束后返回到原来的程序，通过 mode 参数来控制。见 <a href="https://blog.csdn.net/xiaosi2468/article/details/6401874">spawn 系列函数</a>。</p>
<p>第832~835行，定义 mode 参数的两个枚举值，P_WAIT = 0 ，表示阻塞的方式启动子进程，父进程挂起直到子进程执行完毕，P_NOWAIT = 1表示非阻塞的方式启动子进程，父进程和子进程同时运行。(Linux中mode还有另外一个枚举值 P_OVERLAY = 2 ，表示子进程将覆盖父进程原有的存储区位置。这与 exec族函数族调用是相同的，这也是为什么os库的spawn 函数族没有这个枚举值，下面的838行注释有说）。可以看出来spawn函数族和fork有点像，其实往下看代码可以知道，os库里的spawn确实是通过调用folk来实现的。</p>
<p>第841行，定义_spawnvef 函数，后面四个函数都是调用这个函数。</p>
<p>第843~846行，args 参数必须是元组或者列表，且不能为空。</p>
<p>第847行，folk一个子进程，获取返回pid。使用fork函数得到的子进程从父进程的继承了当前进程的整个地址空间，但是pid是不同的，所以可以根据这个来分别控制父进程和子进程的行为。关于fork见 <a href="https://blog.csdn.net/jason314/article/details/5640969">linux中fork函数详解</a> 和 <a href="https://www.unix.com/unix-for-advanced-and-expert-users/178644-spawn-vs-fork.html">spawn() Vs. fork()</a></p>
<p>第848~856行，在子进程中，fork返回0，所以进入 if not pid 分支，执行传入的func函数。出现异常时返回127，一般是环境变量或者当前路径没找到file这个文件。</p>
<p>第857~870行，在父进程中，fork返回新创建子进程的进程ID，所以进入 else 分支。如果是非阻塞模式即mode == P_NOWAIT，函数直接返回。如说是阻塞模式，则父进程一直检测子进程的状态，直到子进程执行结束。</p>
<p>第872~914行：</p>
<ul>
<li><strong>spawnv</strong> 函数， 调用_spawnvef，最终执行的是 execv，执行一个可执行文件替代现有进程。</li>
<li><strong>spawnve</strong> 函数， 调用_spawnvef，最终执行的是 execve，执行一个可执行文件替代现有进程。</li>
<li><strong>spawnvp</strong> 函数， 调用_spawnvef，最终执行的是 execvp，执行一个可执行文件替代现有进程。</li>
<li><strong>spawnvp</strong> 函数， 调用_spawnvef，最终执行的是 execvpe，执行一个可执行文件替代现有进程。</li>
</ul>
<p>第917~970行，这4个函数对应上面4个函数，不同的地方是将最后一个参数从列表或元组变为可变参数类型。例如调用<strong>spawnv(mode, file, [args1, args2, args3])</strong> 变成 <strong>spawnl(mode, file, args1, args2, args3)。</strong></p>
<ul>
<li><strong>spawnl</strong> 函数， 对应前面 <strong>spawnv</strong> 函数。</li>
<li><strong>spawnle</strong> 函数， 对应前面 <strong>spawnve</strong> 函数。</li>
<li><strong>spawnlp</strong> 函数， 对应前面 <strong>spawnvp</strong> 函数。</li>
<li><strong>spawnlpe</strong> 函数， 对应前面 <strong>spawnvp</strong> 函数。</li>
</ul>
<h3 id="第973-1016行-popen——执行cmd或者shell命令"><a href="#第973-1016行-popen——执行cmd或者shell命令" class="headerlink" title="第973~1016行 popen——执行cmd或者shell命令"></a>第973~1016行 popen——执行cmd或者shell命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Supply os.popen()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen</span>(<span class="params">cmd, mode=<span class="string">&quot;r&quot;</span>, buffering=-<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(cmd, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;invalid cmd type (%s, expected string)&quot;</span> % <span class="built_in">type</span>(cmd))</span><br><span class="line">    <span class="keyword">if</span> mode <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;r&quot;</span>, <span class="string">&quot;w&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;invalid mode %r&quot;</span> % mode)</span><br><span class="line">    <span class="keyword">if</span> buffering == <span class="number">0</span> <span class="keyword">or</span> buffering <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;popen() does not support unbuffered streams&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> subprocess, io</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        proc = subprocess.Popen(cmd,</span><br><span class="line">                                shell=<span class="literal">True</span>,</span><br><span class="line">                                stdout=subprocess.PIPE,</span><br><span class="line">                                bufsize=buffering)</span><br><span class="line">        <span class="keyword">return</span> _wrap_close(io.TextIOWrapper(proc.stdout), proc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        proc = subprocess.Popen(cmd,</span><br><span class="line">                                shell=<span class="literal">True</span>,</span><br><span class="line">                                stdin=subprocess.PIPE,</span><br><span class="line">                                bufsize=buffering)</span><br><span class="line">        <span class="keyword">return</span> _wrap_close(io.TextIOWrapper(proc.stdin), proc)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Helper for popen() -- a proxy for a file whose close waits for the process</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_wrap_close</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, stream, proc</span>):</span></span><br><span class="line">        self._stream = stream</span><br><span class="line">        self._proc = proc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stream.close()</span><br><span class="line">        returncode = self._proc.wait()</span><br><span class="line">        <span class="keyword">if</span> returncode == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> returncode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> returncode &lt;&lt; <span class="number">8</span>  <span class="comment"># Shift left to match old behavior</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._stream, name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._stream)</span><br></pre></td></tr></table></figure>
<p>这个方法很常用，功能是执行一条命令，就像在cmd或者shell里执行一条命令一样。原来内部是使用 subprocess.Popen 实现的。下面重点看一下 io.TextIOWrapper 的意思：</p>
<p>为了使复杂的I/O软件具有清晰的结构，良好的可移植性和适应性，在I/O软件中普遍釆用了层次式结构，将系统输入/输出功能组织成一系列的层次，每一层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。Python中主要分了三层，文本I/O，二进制I/O和原始I/O。每一种都有对应的类实现。I/O层次结构的顶部是抽象基类IOBase,它定义了流的基本接口，但读取和写入流之间没有分离。TextIOBase类继承IOBase,用于处理字节表示文本流，并从字符串处理编码和解码。而TextIOWrapper是TextIOBase类的子类，用来缓冲原始流BufferedIOBase的缓冲文本接口。(详见 <a href="https://www.cnblogs.com/lincappu/p/12801539.html">python3之模块io</a> 和 <a href="http://c.biancheng.net/cpp/html/2632.html">I/O子系统的层次结构</a>) 。 其实在这里只需要知道 os.Popen 和 原始subprocess.Popen 的区别是 os.Popen会把返回值用 _wrap_close 封装一次。</p>
<h3 id="第1018-1023行-fdopen——打开文件"><a href="#第1018-1023行-fdopen——打开文件" class="headerlink" title="第1018~1023行 fdopen——打开文件"></a>第1018~1023行 fdopen——打开文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Supply os.fdopen()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fdopen</span>(<span class="params">fd, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(fd, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;invalid fd type (%s, expected integer)&quot;</span> % <span class="built_in">type</span>(fd))</span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">return</span> io.<span class="built_in">open</span>(fd, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>传入打开文件描述符 <em>fd</em> ，返回对应文件的对象。类似内建 open 函数，二者接受同样的参数。不同之处在于fdopen第一个参数应该为整数(文件描述符)。关于最后的 r<strong>eturn  io.open</strong> , <a href="https://docs.python.org/3.8/library/io.html#io.open">官方文档</a> 说 io.open 和内建函数 open 的区别是：io.open 是 open 的别名 (This is an alias for the builtin open() function)。</p>
<h3 id="第1026-1061行-fspath——路径标准化"><a href="#第1026-1061行-fspath——路径标准化" class="headerlink" title="第1026~1061行 fspath——路径标准化"></a>第1026~1061行 fspath——路径标准化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For testing purposes, make sure the function is available when the C</span></span><br><span class="line"><span class="comment"># implementation exists.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fspath</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the path representation of a path-like object.</span></span><br><span class="line"><span class="string">    If str or bytes is passed in, it is returned unchanged. Otherwise the</span></span><br><span class="line"><span class="string">    os.PathLike interface is used to get the path representation. If the</span></span><br><span class="line"><span class="string">    path representation is not str or bytes, TypeError is raised. If the</span></span><br><span class="line"><span class="string">    provided path is not str, bytes, or os.PathLike, TypeError is raised.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(path, (<span class="built_in">str</span>, <span class="built_in">bytes</span>)):</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Work from the object&#x27;s type to match method resolution of other magic</span></span><br><span class="line">    <span class="comment"># methods.</span></span><br><span class="line">    path_type = <span class="built_in">type</span>(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        path_repr = path_type.__fspath__(path)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(path_type, <span class="string">&#x27;__fspath__&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;expected str, bytes or os.PathLike object, &quot;</span></span><br><span class="line">                            <span class="string">&quot;not &quot;</span> + path_type.__name__)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(path_repr, (<span class="built_in">str</span>, <span class="built_in">bytes</span>)):</span><br><span class="line">        <span class="keyword">return</span> path_repr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;expected &#123;&#125;.__fspath__() to return str or bytes, &quot;</span></span><br><span class="line">                        <span class="string">&quot;not &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path_type.__name__,</span><br><span class="line">                                        <span class="built_in">type</span>(path_repr).__name__))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># If there is no C implementation, make the pure Python version the</span></span><br><span class="line"><span class="comment"># implementation as transparently as possible.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _exists(<span class="string">&#x27;fspath&#x27;</span>):</span><br><span class="line">    fspath = _fspath</span><br><span class="line">    fspath.__name__ = <span class="string">&quot;fspath&quot;</span></span><br></pre></td></tr></table></figure>
<p>第1028~1055行， _fspath 方法的作用是返回一个 os 模块能处理的标准路径形式，其实就是字符串。如果传入的是 str 或 bytes 类型的字符串，将原样返回。否则将调用传入参数的<code>__fspath__</code>方法，如果得到的是一个 str 或 bytes 类型的对象，那就返回这个值。<code>__fspath__</code> 方法应该是这样定义的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fspath__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.path.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 第1059~1061行，只有在 buildin 的内建方法 globals() 里不包含 fspath 时，才会调用上面的_fspath方法去定义 os.fspath。实测 windows 下不会走这个分支，也就是说 Windows 下内建方法已经存在 fspath 了。</p>
<h3 id="第1064-1077行-PathLike——什么是PathLike"><a href="#第1064-1077行-PathLike——什么是PathLike" class="headerlink" title="第1064~1077行 PathLike——什么是PathLike"></a>第1064~1077行 PathLike——什么是PathLike</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathLike</span>(<span class="params">abc.ABC</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Abstract base class for implementing the file system path protocol.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__fspath__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the file system path representation of the object.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, subclass</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> PathLike:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(subclass, <span class="string">&#x27;__fspath__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>
<p>前面提到好多次，路径要是 PathLike 的，这个抽象类就是为了解释到底什么样的类才是 “ PathLike的”。里面用到了@abc.abstractmethod 装饰器，说明这个类是抽象类不能被实例化。但是可以被继承，<code>__subclasshook__</code>检查子类是否实现了<code>__fspath__</code> 方法。也就是说一个类如果是 “PathLike 的”，首先它必须要实现 <code>__fspath__</code> 方法。</p>
<h3 id="第1080-1115行-add-dll-directory——-添加DLL文件搜索路径"><a href="#第1080-1115行-add-dll-directory——-添加DLL文件搜索路径" class="headerlink" title="第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径"></a>第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_AddedDllDirectory</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path, cookie, remove_dll_directory</span>):</span></span><br><span class="line">            self.path = path</span><br><span class="line">            self._cookie = cookie</span><br><span class="line">            self._remove_dll_directory = remove_dll_directory</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">            self._remove_dll_directory(self._cookie)</span><br><span class="line">            self.path = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">            self.close()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.path:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&amp;lt;AddedDllDirectory(&#123;!r&#125;)&amp;gt;&quot;</span>.<span class="built_in">format</span>(self.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;lt;AddedDllDirectory()&amp;gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_dll_directory</span>(<span class="params">path</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Add a path to the DLL search path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This search path is used when resolving dependencies for imported</span></span><br><span class="line"><span class="string">        extension modules (the module itself is resolved through sys.path),</span></span><br><span class="line"><span class="string">        and also by ctypes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Remove the directory by calling close() on the returned object or</span></span><br><span class="line"><span class="string">        using it in a with statement.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> nt</span><br><span class="line">        cookie = nt._add_dll_directory(path)</span><br><span class="line">        <span class="keyword">return</span> _AddedDllDirectory(</span><br><span class="line">            path,</span><br><span class="line">            cookie,</span><br><span class="line">            nt._remove_dll_directory</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Python中调用C/C++编写的dll文件时，需要提供这个dll文件的搜索路径(类似环境变量)。add_dll_directory 函数就用于在导入扩展模块或使用 ctypes 加载 DLL 时，依赖提供额外搜索路径。调用返回的_AddedDllDirectory 的close方法可以删除这个路径。主要调用 nt._add_dll_directory方法实现，所以只在Windows系统有效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>《彻底弄懂Python标准库源码》计划，才完成第一篇，最大的感受就是读标准库源码跟我想象很不一样，太太太难了。我以为标准库一定都很通俗易懂吧，应该挺简单的吧，可事实上看过来，这些标准库方法在外面调用起来的确挺优雅的，它们的实现过程还挺复杂的。我们调用的时候只需要关注入参和出参是什么就行了，有时候感觉好神奇好方便啊，我传个A竟然能返回我想要的B。而研究源码就是要看它为什么是这样的，为什么这么神奇，这就要求每一行代码的意思都要搞明白。作为一个程序员，我们要一直保持着一颗好奇心，我们不会相信有什么黑科技，我们一定要看看这些 magic 的背后是什么原理 。</p>
<p>可能也和第一篇选的os库有关系，这个和系统交互的库，大部分是把C的库进行了一层封装。后半部分涉及很多系统底层的的东西，好多不了解的知识，导致看的很煎熬，中间各种查资料补课，还另外补充了几篇博客。好在没想过放弃，自己立的 flag 一定要把它完成。</p>
<p>本来想学习标准库的优雅写法，可是看完我发现我并学不会，os库也不是想象的那么优雅，更多的是为了更有效地实现功能。感觉要想达到学习代码写法的目的，还是看 requests 这种有名的第三方库比较好。还有这篇博客这种一行一行贴代码流水账式的分析意义也不大，白白占用很大篇幅，以后考虑换一种风格。</p>
<ol start="2">
<li><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li>如果只是想看 os 库的用法，官方文档写的很全很详细</li>
</ol>
<p>​       官方文档 <a href="https://docs.python.org/zh-cn/3/library/os.html">os — 多种操作系统接口</a> </p>
<p>​       官方文档 <a href="https://docs.python.org/zh-cn/3/library/io.html">io — 处理流的核心工具</a></p>
<ol start="2">
<li><p><a href="https://blog.csdn.net/yushuaigee/article/details/107883964">彻底弄懂 Linux 下的文件描述符 —— 杰克小麻雀</a></p>
</li>
<li><p><a href="https://blog.csdn.net/yushuaigee/article/details/107567001">彻底弄懂 Python3中入参里的*号的作用 —— 杰克小麻雀</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Symlink_race">Symlink race —- Wikipedia</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u011150719/article/details/50865280">linux stat函数（获取文件详细信息）—— mastodon</a></p>
</li>
<li><p><a href="https://blog.csdn.net/guoping16/article/details/6583383">exec函数 —— guoping16</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xiaosi2468/article/details/6401874">spawn 系列函数 —— xiaosi2468</a></p>
</li>
<li><p><a href="https://blog.csdn.net/jason314/article/details/5640969">linux中fork函数详解 —— jason314</a> </p>
</li>
<li><p><a href="https://www.unix.com/unix-for-advanced-and-expert-users/178644-spawn-vs-fork.html">spawn() Vs. fork() —— The UNIX and Linux Forums</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/lincappu/p/12801539.html">python3之模块io —— lincappu</a> </p>
</li>
<li><p><a href="http://c.biancheng.net/cpp/html/2632.html">I/O子系统的层次结构 —— C语言中文网</a><a href="http://c.biancheng.net/cpp/html/2632.html">http://c.biancheng.net/cpp/html/2632.html</a>)</p>
</li>
</ol>
</li>
</ol>
<hr>
<p>前文见 </p>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/106329590">彻底弄懂Python标准库源码（零）—— 学习计划</a></p>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/106755148">彻底弄懂Python标准库源码（一）—— os模块</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>编程语言</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>实用软件推荐(二)——最强大的截图工具 (Snipaste)</title>
    <url>/2021/03/19/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90(%E4%BA%8C)%E2%80%94%E2%80%94%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%20(Snipaste)/</url>
    <content><![CDATA[<p>截图功能已经成了现在工作和聊天的必备需求了，这也成了聊天软件的必备功能，相信每个人都用过 QQ 或者微信的截图功能，一看到剪刀的图标就知道是截图用的，我记住的第一个电脑快捷键恐怕就是QQ的截图快捷键<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>了。</p>
<p>现在手机上的截图功能特别方便，连使用智能手机并不怎么熟练的父母都能用的很溜。早期的安卓就已经支持电源键加音量键截取屏幕了，后来更是发展到系统自带滚动截屏（长截屏）、屏幕录制等功能。而电脑上（这里指Windows）的截图功能却一直不怎么好用，<kbd>Print Screen</kbd>键按下去，只能截整个屏幕，没有任何提示，都不知道是不是截上了，直到打开画图工具粘贴进去才能看到。而 QQ 自带的截图，不但能随意选择区域，还能直接在截图上添加一些标注和涂鸦，所以 QQ 的截图功能非常受欢迎，很多人甚至根本不知道 Windows 自带了截图功能。</p>
<h2 id="我用过的截图软件"><a href="#我用过的截图软件" class="headerlink" title="我用过的截图软件"></a>我用过的截图软件</h2><h3 id="聊天软件带的截图"><a href="#聊天软件带的截图" class="headerlink" title="聊天软件带的截图"></a>聊天软件带的截图</h3><p>因为以前只有聊天的时候需要截图，所以最开始我也是只会用QQ自带的截图，点击小剪刀或者按<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>，选中自定义区域后点击对勾，图片就自动被放在了聊天框，有时还会加一些箭头和文字标注，非常方便。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319211916108.png" alt="image-20210319211916108"></p>
<h3 id="360-安全卫士带的截图"><a href="#360-安全卫士带的截图" class="headerlink" title="360 安全卫士带的截图"></a>360 安全卫士带的截图</h3><p>后来有了写 word 文档的需要，想插入截图的时候还需要打开QQ ，然后再打开一个聊天框才能使用截图功能，这就有些不方便了。以前还在用 360 全家桶，它会自带许多小工具，像什么软件小助手，流量悬浮球，一键加速之类的，其中就有截图工具，我记得快捷键是<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Z</kbd>。要不说 360 全家桶流行还是有原因的，确实带了一些方便的小工具。这个截图工具和QQ的功能基本类似，我用了很长时间，直到卸载 360 全家桶之后，我还专门下载了一个 360 截图工具独立版。</p>
<p>今天不小心按一下了<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>X</kbd>，发现跳出来一个 360 截图，原来现在用的 360 极速浏览器也内置了截图功能，快捷键就是<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>X</kbd>，不但能截浏览器内的网页，还能截电脑桌面上任意区域，还支持网页长截图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319213259662.png" alt="image-20210319213259662"></p>
<h3 id="Win7-自带的截图"><a href="#Win7-自带的截图" class="headerlink" title="Win7 自带的截图"></a>Win7 自带的截图</h3><p>虽然下载的 360 截图工具独立版已经精简的只有截图功能，但是要多一个开机启动项，还是让我很不爽。于是我想到系统自带的截图，当然不是指<kbd>Print Screen</kbd>键，这个太难用了。Win7 和  Win10 系统直接在开始菜单搜索<code>截图工具</code>，就会看到系统自带的一个截图软件，功能还算齐全吧，其实并不如 QQ 截图好用。不过这个软件已经支持自定义截图区域了，它还支持延时几秒后截图，这个功能有时候还挺有用的。我把它固定在任务栏，这样就不需要每次用的时候再去搜索了，尽管它很丑，但是我为了不额外安装软件，还是用了它很久。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319214811330.png" alt="image-20210319214811330"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319215713290.png" alt="image-20210319215713290"></p>
<h3 id="Win10-自带的截图"><a href="#Win10-自带的截图" class="headerlink" title="Win10 自带的截图"></a>Win10 自带的截图</h3><p>升级 win 10 之后，我还是用了上面这个自带截图很长一段时间，直到后来一次系统更新，我发现更新了一个新的截图快捷键，<kbd>Win</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>。按完快捷键之后，会在屏幕顶部弹出一个简洁的窗口，四个选项依次是矩形截图（随意画框）、自定义截图（随意画不规则图形）、窗口截图（截某个应用的窗口）、全屏截图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319220044410.png" alt="image-20210319220044410"></p>
<p>选择区域后，松开鼠标，会弹出截图成功的通知，提示截图已经被保存到剪贴板了，可以直接<kbd>Ctrl</kbd>+<kbd>V</kbd>直接粘贴了。这也意味着一旦松手就不能重新选择区域了，想调整区域只能重来，所以这个工具只能说颜值还行功能还行吧，只适合在别人的电脑上没有装任何截图工具的情况下临时使用一下，不适合重度使用用户。这个 Windows 自带的截图工具发展了这么多年了，微软还是没有把它做的尽如人意啊。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210319220508873.png" alt="image-20210319220508873"></p>
<h2 id="本文主角-Snipaste"><a href="#本文主角-Snipaste" class="headerlink" title="本文主角 Snipaste"></a>本文主角 Snipaste</h2><p>前面说了，截图功能已经成了现在工作和聊天的必备需求，但是竟然没有一个十全十美的截图工具，这时终于有个大佬看不下去了，凭自己一人之力，做出来一款好用得让人直跺脚而且还完全免费的截图神器。</p>
<p>后来工作之后，截图的需求激增，我从网上疯狂搜索，终于发现这款提高工作效率的神器。最早是在 V2EX 上看到作者自己发的一篇推广帖子：<a href="https://www.v2ex.com/t/295433">Snipaste - 开发了三年的截图工具，但不只是截图</a>。后来又在微信公众号看到介绍这个软件的 GitHub 项目：<a href="https://github.com/Snipaste/">Snipaste</a>。再后来下载新版本的时候发现这个软件已经火了，作者还建立了官方网站：<a href="https://zh.snipaste.com/">Snipaste中文官网</a>。Snipaste 后来的更新采纳吸收了许多使用者的建议，现在功能越来越完善了，而且已经有了Mac版，Linux版也在开发中。</p>
<p>Snipaste 功能非常强大，不需要安装，解压即可使用。这里我只介绍一下我平时用的比较多的功能，更详细的介绍见官网和文末的链接。</p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210405123701897.png" alt="image-20210405123701897"></p>
<p>外观看上去貌似和其他截图软件大同小异，依次是方框标注、划线标注、箭头标注、画笔标注、涂鸦标注、马赛克标注、文字标注、橡皮擦、撤销，回退等。等你用起来的时候就会发现细节上的用心之处，我们还可以用它完成一些简单的PS操作，非常方便。</p>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210405123920784.png" alt="image-20210405123920784"></p>
<p>图标是作者自己设计的，适配 Win7 和 Win10，在我看来这个图标完美适配 Win10 的界面，就像自带功能一样，这就可以说服大部分强迫症用户允许它开机启动，这也是我放在开机启动的唯二的两个第三方软件之一。</p>
<h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>所有的标注功能都是可二次编辑的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu1.gif" alt="jietu1"></p>
<p>支持像素级微调。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu2.gif" alt="jietu2"></p>
<p>快捷键查看所有截图历史。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu3.gif" alt="jietu3"></p>
<p>可以进行简单的 PS 操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu5.gif" alt="jietu5"></p>
<h3 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h3><p>剧据作者所说，Snipaste 的名字的意思是 Snip + Paste ，也就是截图 + 贴图，最初写这个软件的原因也是为了满足他贴图的需求。</p>
<p>先看下什么是贴图，功能栏有一个图钉按钮，点击它，就会把刚才的截图贴在屏幕上图片原来的的位置，而且还能放大、透明、旋转。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu6.gif" alt="jietu6"></p>
<p>我常用的场景有两个，一个是多个截图合并为一张时，还有就是比较两个文件时。</p>
<p>多张截图合并为一张，展示更加清晰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu7.gif" alt="jietu7"></p>
<p>比较两个文件内容或者同一个文件的上下两部分内容时，只需要将其中一个截图贴在屏幕旁边，就不用来回滚动屏幕了，以后写代码<del>抄代码</del>更方便了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu8.gif" alt="jietu8"></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>Snipaste 基本所有的功能都支持自定义设置和自定义快捷键，当然如果你嫌自定义设置太麻烦，可以使用所有默认设置，它们以及被调到最优了。我由于以前的习惯，仅改动了一个截图快捷键，将默认的<kbd>F1</kbd>改成了<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/jietu9.gif" alt="jietu9"></p>
<h3 id="更多介绍"><a href="#更多介绍" class="headerlink" title="更多介绍"></a>更多介绍</h3><p>上面我回顾了一下自己选择截图软件的过程，对 Snipaste 进行了简单介绍和推荐，供大家参考。以上只是粗略介绍了我常用的功能，它还有许多更高级的玩法，我在少数派网站看到几篇关于  Snipaste 的文章，内容丰富排版优美，大家可以参考下面几篇文章。</p>
<p>Snipaste 真的很符合我的口味，不只是它的功能，还有它的设计理念。曾几何时，自己独立开发一款强大且优雅的软件也是我的梦想啊，而如今自己只能在大佬后面喊 666，梦想终究变成了“梦想”。</p>
<ul>
<li><a href="https://sspai.com/post/34962">Windows 上最好的免费截图标注工具：Snipaste</a></li>
<li><a href="https://sspai.com/post/42459">记住这 5 点，用 Snipaste 快速做出一张美观的标注</a></li>
<li><a href="https://sspai.com/post/35097">幕后丨他做了最强免费「截图」工具 Snipaste 后，还有上万字的话想说</a></li>
</ul>
]]></content>
      <categories>
        <category>软件推荐</category>
      </categories>
      <tags>
        <tag>截图工具</tag>
        <tag>软件推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 相关文件常见的后缀名详解</title>
    <url>/2021/05/02/Python%20%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%8E%E7%BC%80%E5%90%8D%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>常见的 Python 文件后缀有：<code>py </code>、<code>pyc</code> 、<code>pyo</code>、 <code>pyi</code>、<code>pyw</code>、 <code>pyd </code>、 <code>pyx</code> 等。</p>
<p>本文只介绍相对常见的一些后缀名，至于一些特别冷门的文件格式，例如一些文章提到的<code>pyz</code>、<code>pywz</code>、<code>rpy</code>、<code>pyde</code>、<code>pyp</code>、 <code>pyt</code>等，并没有进行研究。因为这些扩展名资料很少，网上搜到的文章似乎都是同一个出处，只是简单提了一句，说了等于没说。</p>
<h3 id="py"><a href="#py" class="headerlink" title="py"></a>py</h3><p>最常见的 Python 源代码文件。</p>
<p>实际上如果用 <code>python + 文件</code> 的方式运行代码，只要文件内容相同，后缀名是不重要的，也就是说下面的运行结果都是等价的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python test.py</span><br><span class="line">python test.txt</span><br><span class="line">python test</span><br></pre></td></tr></table></figure>
<h3 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h3><p>常见的 Python 字节码缓存文件。</p>
<p><code>pyc</code>文件和<code>py</code>文件一样，都可以直接执行，下面的运行结果都是等价的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python test.py</span><br><span class="line">python test.pyc</span><br></pre></td></tr></table></figure>
<h5 id="作用一：提升加载性能"><a href="#作用一：提升加载性能" class="headerlink" title="作用一：提升加载性能"></a>作用一：提升加载性能</h5><p>我们知道 Python 代码在执行时，会先由 Python 解析器翻译成 PyCodeObject 对象，俗称字节码 (Byte code)，然后交给 Python 解释器来执行字节码。</p>
<p>上述过程中翻译后的字节码是保存在内存中，程序运行结束就没了，而代码没有修改的情况下，每次生成的字节码是一样的，所以每次跑程序都再走一遍翻译字节码的过程有点浪费性能。因此为了提高加载效率，Python 在程序执行结束后会把每个文件的字节码写入到硬盘中保存为 <code>xxx.pyc</code> 文件，这样下一次再执行这个程序时先在目录下找有没有<code>xxx.pyc</code> 文件，如果有这个对应文件且修改时间和<code>xxx.py</code> 文件的修改时间一样，就不用再执行翻译成字节码的过程，直接读取<code>xxx.pyc</code> 文件执行。其实缓存<code>pyc</code> 文件的方式对性能的提升很微小，只有项目文件非常多的时候才能看到显著提升。</p>
<p>默认情况下，我们发现并不是所有的<code>py</code> 文件都会自动生成<code>pyc</code> 文件，只有被其他文件 import 过的文件才会生成对应的<code>pyc</code> 文件。可能 Python 认为被 import 的文件重复使用的概率比较高，而主文件一般只需要加载一次。</p>
<p>简单做个实验可以验证，新建两个 Python 文件<code>hello.py</code>和<code>import.py</code>，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import.py</span></span><br><span class="line">impot hello</span><br></pre></td></tr></table></figure>
<p>直接运行 <code>python hello.py</code>，并没有生成<code>pyc</code> 文件，而运行<code>python import.py</code>，在当前目录下生成了<code>hello.py</code>对应的<code>pyc</code> 文件。</p>
<p>这里 Python2 和 Python3 有些不同， Python2 是直接在当前目录下生成同名 <code>pyc</code> 文件，Python3 是在当前目录下创建了<code>__pycache__</code>文件夹，然后在文件夹内创建了一个包含 Python 版本信息的<code>xxx.cpython-37.pyc</code> 文件。</p>
<p>Python2</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2021050217225593.png" alt="2021050217225593"></p>
<p>Python3</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172327565.png" alt="20210502172327565"></p>
<h5 id="作用二：隐藏源代码"><a href="#作用二：隐藏源代码" class="headerlink" title="作用二：隐藏源代码"></a>作用二：隐藏源代码</h5><p><code>pyc</code>格式是给解释器看的二进制文件，直接用编辑器打开看上去是乱码，所以将 Python 代码先编译成<code>pyc</code>文件再交付给别人使用，一定程度上实现隐藏源代码的效果。</p>
<p>默认情况下，主文件不会生成<code>pyc</code>文件，可以通过 Python 自带的<code>py_compile </code>或<code>compileall </code> 库，手动将所有<code>py</code>文件”编译”成<code>pyc</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m py_compile *.py</span><br><span class="line">python -m compileall *.py</span><br></pre></td></tr></table></figure>
<p>Python2</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172344295.png" alt="20210502172344295"></p>
<p>Python3</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172352924.png" alt="20210502172352924"></p>
<h5 id="反编译-pyc"><a href="#反编译-pyc" class="headerlink" title="反编译 pyc"></a>反编译 pyc</h5><p>前面说了，是“一定程度上实现隐藏源代码的效果”，其实可以通过反编译<code>pyc</code>文件来获得<code>py</code>源码，而且反编译的难度并不大。</p>
<p><code>uncompyle6</code>是一个专门用于将<code>pyc</code>反编译为<code>py</code>源码的第三方库，安装方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install uncompyle6</span><br></pre></td></tr></table></figure>
<p>执行下面命令可以将刚才生成的<code>pyc</code>反编译为<code>py</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uncompyle6 -o . *.pyc</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172413998.png" alt="20210502172413998"></p>
<p>打开生成的文件<code>hello.cpython-37.py</code>和<code>import.cpython-37.py</code>，可以看到和之前的<code>py</code>代码内容一模一样，不过多了一些 Python 的版本信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502173823484.png" alt="20210502173823484"></p>
<p> 魔高一尺，道高一丈，有反编译技术就有防止反编译技术，更多了解参见这篇文章：<a href="https://blog.csdn.net/ir0nf1st/article/details/61650984">通过字节码混淆来保护Python代码</a>。</p>
<h3 id="pyo"><a href="#pyo" class="headerlink" title="pyo"></a>pyo</h3><p>优化后的 Python 字节码缓存文件。</p>
<p><code>pyo</code>文件的作用和<code>pyc</code>文件没啥区别，唯一的优化就是去掉了断言语句，即<code>assert</code>语句。官方文档描述：</p>
<blockquote>
<p>When the Python interpreter is invoked with the -O flag, optimized code is generated and stored in .pyo files. The optimizer currently doesn’t help much; it only removes assert statements. When -O is used, all bytecode is optimized; .pyc files are ignored and .py files are compiled to optimized bytecode.</p>
</blockquote>
<p>同样可以利用<code>py_compile </code>或<code>compileall </code> 库将上面示例的两个文件编译成<code>pyo</code>文件，只是多加一个参数<code>-O</code>，运行结果也没有任何变化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -O -m py_compile *.py</span><br><span class="line">python -O -m compileall *.py</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172534260.png" alt="20210502172534260"></p>
<p>从 Python3.5 开始，Python 只使用 <code>pyc</code> 而不再使用<code>pyo</code>，所以下面命令也无法生成 <code>pyo</code>文件，生成的依然是 <code>pyc</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -O -m py_compile *.py</span><br><span class="line">python3 -O -m compileall *.py</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/202105021725479.png" alt="202105021725479"></p>
<h3 id="pyi"><a href="#pyi" class="headerlink" title="pyi"></a>pyi</h3><p>Python 的存根文件，用于代码检查时的类型提示。</p>
<p><code>pyi</code>文件是<code>PEP484</code>提案规定的一种用于 Python 代码类型提示（Type Hints）的文件。<code>PEP</code>即<code>Python Enhancement Proposals</code>，是经过 Python 社区核心开发者讨论并一致同意后，对外发布的一些正式规范文档，例如我们常说的Python之禅(<code>PEP20</code>)，代码风格 PEP8 格式化(<code>PEP8</code>)，将 print 改为函数(<code>PEP3105</code>)等，关于<code>PEP</code>的更多了解见这篇文章：<a href="https://www.jiqizhixin.com/articles/2018-11-09-4">学习Python，怎能不懂点PEP呢?</a>。</p>
<p>常用的 IDE 都会有类型检查提示功能，比如在 PyCharm 中，当我们给一个函数传入一个错误的类型时会给出对应的提示，这其实不是 IDE 的特殊开发的功能，它只是集成了<code>PEP484</code>的规定，利用了已经预先生成好的 <code>pyi</code>文件。</p>
<p>举个例子，<code>os.makedirs</code>是标准库中用于创建文件夹路径的函数，它的入参应该是一个字符串类型，如果传入一个 int 类型，IDE 会立刻给出提示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172622846.png" alt="20210502172622846"></p>
<p>按住<code>ctrl</code>点进去，进入到 os 模块定义<code>os.makedirs</code>的地方，发现前面有个<code>*</code>号，鼠标放上去会提示<code>Has stub item in __init__.pyi</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172637274.png" alt="20210502172637274"></p>
<p>点击<code>*</code>号就会跳到对应的<code>__init__.pyi</code>文件，这个文件里按照<code>PEP484</code>规定，为<code>os</code>模块每个函数都定义了对应的类型检查规则。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172648395.png" alt="20210502172648395"></p>
<p>关于<code>pyi</code>文件的定义规则以及自己如何生成，详见官方文档：<a href="https://www.python.org/dev/peps/pep-0484/">PEP 484 – Type Hints</a></p>
<h3 id="pyw"><a href="#pyw" class="headerlink" title="pyw"></a>pyw</h3><p>一种 Python 源代码文件，一般只存在于 Windows 系统。</p>
<p><code>pyw</code>文件和<code>py</code>文件除了后缀名不一样之外没有任何区别，两者都是 Python 源码文件，前面 <code>py</code>那一节说过“如果用 <code>python + 文件</code> 的方式运行代码，只要文件内容相同，后缀名是不重要的”，这一点在 Windows 系统和 Linux 系统都是一样的。</p>
<p>Windows 系统，新建两个内容相同的 Python 文件<code>hello.py</code>和<code>hello.pyw</code>，用<code>python + 文件</code> 的方式运行，结果一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.pyw</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2021050217270625.png" alt="2021050217270625"></p>
<p>那为什么还要有<code>pyw</code>文件呢？</p>
<p>在Windows 系统上双击文件时，系统会根据文件扩展名来调用关联的<code>exe</code>程序来运行这个文件，打开 Python 安装目录，可以看到有<code>python.exe</code>和<code>pythonw.exe</code>两个<code>exe</code>，其中<code>python.exe</code>关联了<code>py</code>文件，<code>pythonw.exe</code>关联了<code>pyw</code>文件。跟 <code>python.exe</code> 相比，<code>pythonw.exe </code>运行时不会弹出控制台窗口， stdout 、stderr 和 stdin 都无效，所以像 print 这种把内容输出到 stdout 的操作就不会有打印结果（cmd 窗口都没有了也没有地方显示了）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20210502172716282.png" alt="20210502172716282"></p>
<p>所以在用 Python 开发 GUI 程序时，如果不想让程序运行的时候弹出一个黑乎乎的 cmd 框，就可以将源码文件后缀名改为<code>pyw</code>格式。但是我感觉这个<code>pww</code>格式用处并不大，实际使用很少有人双击<code>py</code>或者<code>pyw</code>文件来运行 Python 代码。我之前曾用<code>tkinter</code>开发过带 Windows 界面的 Python 程序，当时是通过双击 <code>bat</code>脚本启动 Python 脚本同时关闭 cmd 界面框，来避免弹出黑框框的。</p>
<h3 id="pyd"><a href="#pyd" class="headerlink" title="pyd"></a>pyd</h3><p>Python 可直接调用的 C 语言动态链接库文件，一般只存在于 Windows 系统。</p>
<p>Python 是一种胶水语言，我们可以将对速度要求比较高的那一部分代码使用 C 语言编写，编译成动态链接库文件，再通过 Python 来调用。一般来说，在 Linux 上是 <code>so</code>文件，在 Windows 系统上是<code>DLL</code>文件。</p>
<p>例如有一个 C 语言编写的  Windows 动态链接库 <code>test_lib.dll</code>，编译前的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在 Python 代码中通过下面的方式来调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_lib.dll 放在当前目录下</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">test_lib = ctypes.windll.LoadLibrary(<span class="string">&quot;test_lib.dll&quot;</span>)</span><br><span class="line">a = ctypes.c_int(<span class="number">1</span>)</span><br><span class="line">b = ctypes.c_int(<span class="number">2</span>)</span><br><span class="line">out = test_lib.<span class="built_in">sum</span>(a, b)</span><br><span class="line">print(out) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>在 Windows 系统上，Python 还有一种 <code>pyd</code>格式的动态链接库，上面的调用方式是先通过<code>ctypes.windll.LoadLibrary</code> 方法将动态链接库加载进来，而<code>pyd</code>格式就可以在 Python 代码中直接<code>import</code>进来，类似下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_lib.pyd 放在当前目录下</span></span><br><span class="line"><span class="keyword">import</span> test_lib</span><br><span class="line"></span><br><span class="line">out = test_lib.<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(out) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>pyd</code>文件和<code>dll</code>文件的区别，可参考<a href="https://docs.python.org/3/faq/windows.html#is-a-pyd-file-the-same-as-a-dll">官方文档的说明</a>：</p>
<blockquote>
<p><strong>Is a <code>*.pyd</code> file the same as a DLL?</strong></p>
<p>Yes, .pyd files are dll’s, but there are a few differences. If you have a DLL named <code>foo.pyd</code>, then it must have a function <code>PyInit_foo()</code>. You can then write Python “import foo”, and Python will search for foo.pyd (as well as foo.py, foo.pyc) and if it finds it, will attempt to call <code>PyInit_foo()</code> to initialize it. You do not link your .exe with foo.lib, as that would cause Windows to require the DLL to be present.</p>
<p>Note that the search path for foo.pyd is PYTHONPATH, not the same as the path that Windows uses to search for foo.dll. Also, foo.pyd need not be present to run your program, whereas if you linked your program with a dll, the dll is required. Of course, foo.pyd is required if you want to say <code>import foo</code>. In a DLL, linkage is declared in the source code with <code>__declspec(dllexport)</code>. In a .pyd, linkage is defined in a list of available functions.</p>
</blockquote>
<p>C 语言代码和 Python 代码都可以通过一定的方法编译成<code>pyd</code>格式的文件，本人并没有实际使用过<code>pyd</code>文件，详细方法可参考下面的文章：</p>
<p><a href="https://blog.csdn.net/pengyancai/article/details/54587955">使用C++创建Pyd文件扩展Python模块</a></p>
<p><a href="https://blog.csdn.net/kdongyi/article/details/102678595">Python源代码保护(Python文件编译生成pyd/so库文件)</a></p>
<h3 id="pyx"><a href="#pyx" class="headerlink" title="pyx"></a>pyx</h3><p>Cython 源代码文件。</p>
<p>注意是 Cython 不是 CPython。Cython 可以说是一种编程语言， 它结合了Python 的语法和有 C/C++的效率，用 Cython 写完的代码可以很容易转成 C 语言代码，然后又可以再编译成动态链接库(<code>pyd</code>或<code>dll</code>)供 Python 调用，所以 Cython 一般用来编写 Python 的 C 扩展，上面说的 Python 文件编译生成 <code>pyd</code> 文件就是利用 Cython 来实现的 。Cython 的源代码文件一般为<code>pyx</code>后缀。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>后缀名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>py</td>
<td>最常见的 Python 源代码文件。</td>
</tr>
<tr>
<td>pyc</td>
<td>常见的 Python 字节码缓存文件，可以反编译成 py 文件。</td>
</tr>
<tr>
<td>pyo</td>
<td>另一种 Python 字节码缓存文件，只存在于 Python2 及 Python3.5 之前的版本。</td>
</tr>
<tr>
<td>pyi</td>
<td>Python 的存根文件，常用于 IDE 代码格式检查时的类型提示。</td>
</tr>
<tr>
<td>pyw</td>
<td>另一种 Python 源代码文件，一般只存在于 Windows 系统。</td>
</tr>
<tr>
<td>pyd</td>
<td>一种 Python 可直接调用的 C 语言动态链接库文件，一般只存在于 Windows 系统。</td>
</tr>
<tr>
<td>pyx</td>
<td>Cython 源代码文件，一般用来编写 Python 的 C 扩展。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pyc</tag>
        <tag>pyo</tag>
        <tag>pyi</tag>
        <tag>pyw</tag>
        <tag>pyd</tag>
        <tag>pyx</tag>
      </tags>
  </entry>
</search>
